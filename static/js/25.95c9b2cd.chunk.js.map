{"version":3,"file":"static/js/25.95c9b2cd.chunk.js","mappings":"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CAAC,CACRU,aAAc,UACdb,KAAM,GACND,KAAM,YAERM,gBAAiB,OACjBN,KAAM,YACL,CACDG,OAAQ,GACRF,KAAM,aACNG,QAAS,CAAC,CACRU,aAAc,UACdb,KAAM,GACND,KAAM,YAERM,gBAAiB,OACjBN,KAAM,YACL,CACDG,OAAQ,GACRF,KAAM,gBACNG,QAAS,CAAC,CACRU,aAAc,UACdb,KAAM,GACND,KAAM,YAERM,gBAAiB,OACjBN,KAAM,YACL,CACDG,OAAQ,CAAC,CACPW,aAAc,UACdb,KAAM,GACND,KAAM,YAERC,KAAM,mBACNG,QAAS,CAAC,CACRU,aAAc,UACdb,KAAM,GACND,KAAM,YAERM,gBAAiB,OACjBN,KAAM,YACL,CACDG,OAAQ,CAAC,CACPW,aAAc,UACdb,KAAM,GACND,KAAM,YAERC,KAAM,sBACNG,QAAS,CAAC,CACRU,aAAc,UACdb,KAAM,GACND,KAAM,YAERM,gBAAiB,OACjBN,KAAM,YACL,CACDG,OAAQ,CAAC,CACPW,aAAc,UACdb,KAAM,GACND,KAAM,YAERC,KAAM,mBACNG,QAAS,CAAC,CACRU,aAAc,UACdb,KAAM,GACND,KAAM,YAERM,gBAAiB,OACjBN,KAAM,YACL,CACDG,OAAQ,CAAC,CACPW,aAAc,UACdb,KAAM,GACND,KAAM,YAERC,KAAM,mBACNG,QAAS,CAAC,CACRU,aAAc,UACdb,KAAM,GACND,KAAM,YAERM,gBAAiB,OACjBN,KAAM,YACL,CACDG,OAAQ,CAAC,CACPQ,WAAY,CAAC,CACXG,aAAc,OACdb,KAAM,eACND,KAAM,QACL,CACDc,aAAc,OACdb,KAAM,gBACND,KAAM,QACL,CACDc,aAAc,UACdb,KAAM,WACND,KAAM,WACL,CACDc,aAAc,UACdb,KAAM,SACND,KAAM,WACL,CACDc,aAAc,UACdb,KAAM,QACND,KAAM,WACL,CACDc,aAAc,QACdb,KAAM,OACND,KAAM,UAERc,aAAc,oCACdb,KAAM,OACND,KAAM,YAERC,KAAM,YACNG,QAAS,CAAC,CACRU,aAAc,SACdb,KAAM,aACND,KAAM,UACL,CACDc,aAAc,UAC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","sources":["../node_modules/@0xsequence/abi/dist/0xsequence-abi.esm.js","../node_modules/@0xsequence/api/dist/0xsequence-api.esm.js","../node_modules/@0xsequence/auth/node_modules/@0xsequence/ethauth/dist/index.es.js","../node_modules/@0xsequence/network/dist/0xsequence-network.esm.js","../node_modules/@0xsequence/multicall/dist/0xsequence-multicall.esm.js","../node_modules/@0xsequence/config/dist/0xsequence-config.esm.js","../node_modules/@0xsequence/indexer/dist/0xsequence-indexer.esm.js","../node_modules/@0xsequence/metadata/dist/0xsequence-metadata.esm.js","../node_modules/@0xsequence/transactions/dist/0xsequence-transactions.esm.js","../node_modules/@0xsequence/relayer/dist/0xsequence-relayer.esm.js","../node_modules/@0xsequence/wallet/dist/0xsequence-wallet.esm.js","../node_modules/@0xsequence/auth/dist/0xsequence-auth.esm.js","../node_modules/@0xsequence/guard/dist/0xsequence-guard.esm.js","../node_modules/@web3-onboard/sequence/node_modules/@0xsequence/provider/dist/0xsequence-provider.esm.js","../node_modules/@web3-onboard/sequence/node_modules/0xsequence/dist/0xsequence.esm.js"],"sourcesContent":["const abi$5 = [{\n  type: 'function',\n  name: 'isValidSignature',\n  constant: true,\n  inputs: [{\n    type: 'bytes32'\n  }, {\n    type: 'bytes'\n  }],\n  outputs: [{\n    type: 'bytes4'\n  }],\n  payable: false,\n  stateMutability: 'view'\n}];\nconst returns = {\n  isValidSignatureBytes32: '0x1626ba7e'\n};\n\nvar erc1271 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  abi: abi$5,\n  returns: returns\n});\n\nconst abi$4 = [{\n  type: 'function',\n  name: 'deploy',\n  constant: false,\n  inputs: [{\n    type: 'address'\n  }, {\n    type: 'bytes32'\n  }],\n  outputs: [],\n  payable: true,\n  stateMutability: 'payable'\n}];\n\nvar factory = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  abi: abi$4\n});\n\nconst abi$3 = [{\n  type: 'function',\n  name: 'nonce',\n  constant: true,\n  inputs: [],\n  outputs: [{\n    type: 'uint256'\n  }],\n  payable: false,\n  stateMutability: 'view'\n}, {\n  type: 'function',\n  name: 'readNonce',\n  constant: true,\n  inputs: [{\n    type: 'uint256'\n  }],\n  outputs: [{\n    type: 'uint256'\n  }],\n  payable: false,\n  stateMutability: 'view'\n}, {\n  type: 'function',\n  name: 'updateImplementation',\n  constant: false,\n  inputs: [{\n    type: 'address'\n  }],\n  outputs: [],\n  payable: false,\n  stateMutability: 'nonpayable'\n}, {\n  type: 'function',\n  name: 'selfExecute',\n  constant: false,\n  inputs: [{\n    components: [{\n      type: 'bool',\n      name: 'delegateCall'\n    }, {\n      type: 'bool',\n      name: 'revertOnError'\n    }, {\n      type: 'uint256',\n      name: 'gasLimit'\n    }, {\n      type: 'address',\n      name: 'target'\n    }, {\n      type: 'uint256',\n      name: 'value'\n    }, {\n      type: 'bytes',\n      name: 'data'\n    }],\n    type: 'tuple[]'\n  }],\n  outputs: [],\n  payable: false,\n  stateMutability: 'nonpayable'\n}, {\n  type: 'function',\n  name: 'execute',\n  constant: false,\n  inputs: [{\n    components: [{\n      type: 'bool',\n      name: 'delegateCall'\n    }, {\n      type: 'bool',\n      name: 'revertOnError'\n    }, {\n      type: 'uint256',\n      name: 'gasLimit'\n    }, {\n      type: 'address',\n      name: 'target'\n    }, {\n      type: 'uint256',\n      name: 'value'\n    }, {\n      type: 'bytes',\n      name: 'data'\n    }],\n    type: 'tuple[]'\n  }, {\n    type: 'uint256'\n  }, {\n    type: 'bytes'\n  }],\n  outputs: [],\n  payable: false,\n  stateMutability: 'nonpayable'\n}, {\n  type: 'function',\n  name: 'createContract',\n  inputs: [{\n    type: 'bytes'\n  }],\n  payable: true,\n  stateMutability: 'payable'\n}];\n\nvar mainModule = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  abi: abi$3\n});\n\nconst abi$2 = [{\n  type: 'function',\n  name: 'updateImageHash',\n  constant: true,\n  inputs: [{\n    type: 'bytes32'\n  }],\n  outputs: [],\n  payable: false,\n  stateMutability: 'view'\n}, {\n  type: 'function',\n  name: 'imageHash',\n  constant: true,\n  inputs: [],\n  outputs: [{\n    type: 'bytes32'\n  }],\n  payable: false,\n  stateMutability: 'view'\n}];\n\nvar mainModuleUpgradable = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  abi: abi$2\n});\n\nconst abi$1 = [{\n  inputs: [{\n    internalType: 'address',\n    name: '_factory',\n    type: 'address'\n  }, {\n    internalType: 'address',\n    name: '_mainModule',\n    type: 'address'\n  }],\n  stateMutability: 'nonpayable',\n  type: 'constructor'\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: 'address',\n    name: '_wallet',\n    type: 'address'\n  }, {\n    indexed: true,\n    internalType: 'bytes32',\n    name: '_imageHash',\n    type: 'bytes32'\n  }, {\n    indexed: false,\n    internalType: 'uint256',\n    name: '_threshold',\n    type: 'uint256'\n  }, {\n    indexed: false,\n    internalType: 'bytes',\n    name: '_signers',\n    type: 'bytes'\n  }],\n  name: 'RequiredConfig',\n  type: 'event'\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: 'address',\n    name: '_wallet',\n    type: 'address'\n  }, {\n    indexed: true,\n    internalType: 'address',\n    name: '_signer',\n    type: 'address'\n  }],\n  name: 'RequiredSigner',\n  type: 'event'\n}, {\n  inputs: [{\n    internalType: 'address',\n    name: '_addr',\n    type: 'address'\n  }],\n  name: 'callBalanceOf',\n  outputs: [{\n    internalType: 'uint256',\n    name: '',\n    type: 'uint256'\n  }],\n  stateMutability: 'view',\n  type: 'function'\n}, {\n  inputs: [],\n  name: 'callBlockNumber',\n  outputs: [{\n    internalType: 'uint256',\n    name: '',\n    type: 'uint256'\n  }],\n  stateMutability: 'view',\n  type: 'function'\n}, {\n  inputs: [{\n    internalType: 'uint256',\n    name: '_i',\n    type: 'uint256'\n  }],\n  name: 'callBlockhash',\n  outputs: [{\n    internalType: 'bytes32',\n    name: '',\n    type: 'bytes32'\n  }],\n  stateMutability: 'view',\n  type: 'function'\n}, {\n  inputs: [],\n  name: 'callChainId',\n  outputs: [{\n    internalType: 'uint256',\n    name: 'id',\n    type: 'uint256'\n  }],\n  stateMutability: 'pure',\n  type: 'function'\n}, {\n  inputs: [{\n    internalType: 'address',\n    name: '_addr',\n    type: 'address'\n  }],\n  name: 'callCode',\n  outputs: [{\n    internalType: 'bytes',\n    name: 'code',\n    type: 'bytes'\n  }],\n  stateMutability: 'view',\n  type: 'function'\n}, {\n  inputs: [{\n    internalType: 'address',\n    name: '_addr',\n    type: 'address'\n  }],\n  name: 'callCodeHash',\n  outputs: [{\n    internalType: 'bytes32',\n    name: 'codeHash',\n    type: 'bytes32'\n  }],\n  stateMutability: 'view',\n  type: 'function'\n}, {\n  inputs: [{\n    internalType: 'address',\n    name: '_addr',\n    type: 'address'\n  }],\n  name: 'callCodeSize',\n  outputs: [{\n    internalType: 'uint256',\n    name: 'size',\n    type: 'uint256'\n  }],\n  stateMutability: 'view',\n  type: 'function'\n}, {\n  inputs: [],\n  name: 'callCoinbase',\n  outputs: [{\n    internalType: 'address',\n    name: '',\n    type: 'address'\n  }],\n  stateMutability: 'view',\n  type: 'function'\n}, {\n  inputs: [],\n  name: 'callDifficulty',\n  outputs: [{\n    internalType: 'uint256',\n    name: '',\n    type: 'uint256'\n  }],\n  stateMutability: 'view',\n  type: 'function'\n}, {\n  inputs: [],\n  name: 'callGasLeft',\n  outputs: [{\n    internalType: 'uint256',\n    name: '',\n    type: 'uint256'\n  }],\n  stateMutability: 'view',\n  type: 'function'\n}, {\n  inputs: [],\n  name: 'callGasLimit',\n  outputs: [{\n    internalType: 'uint256',\n    name: '',\n    type: 'uint256'\n  }],\n  stateMutability: 'view',\n  type: 'function'\n}, {\n  inputs: [],\n  name: 'callGasPrice',\n  outputs: [{\n    internalType: 'uint256',\n    name: '',\n    type: 'uint256'\n  }],\n  stateMutability: 'view',\n  type: 'function'\n}, {\n  inputs: [],\n  name: 'callOrigin',\n  outputs: [{\n    internalType: 'address',\n    name: '',\n    type: 'address'\n  }],\n  stateMutability: 'view',\n  type: 'function'\n}, {\n  inputs: [],\n  name: 'callTimestamp',\n  outputs: [{\n    internalType: 'uint256',\n    name: '',\n    type: 'uint256'\n  }],\n  stateMutability: 'view',\n  type: 'function'\n}, {\n  inputs: [{\n    internalType: 'address',\n    name: '',\n    type: 'address'\n  }],\n  name: 'knownImageHashes',\n  outputs: [{\n    internalType: 'bytes32',\n    name: '',\n    type: 'bytes32'\n  }],\n  stateMutability: 'view',\n  type: 'function'\n}, {\n  inputs: [{\n    internalType: 'bytes32',\n    name: '',\n    type: 'bytes32'\n  }],\n  name: 'lastImageHashUpdate',\n  outputs: [{\n    internalType: 'uint256',\n    name: '',\n    type: 'uint256'\n  }],\n  stateMutability: 'view',\n  type: 'function'\n}, {\n  inputs: [{\n    internalType: 'address',\n    name: '',\n    type: 'address'\n  }],\n  name: 'lastSignerUpdate',\n  outputs: [{\n    internalType: 'uint256',\n    name: '',\n    type: 'uint256'\n  }],\n  stateMutability: 'view',\n  type: 'function'\n}, {\n  inputs: [{\n    internalType: 'address',\n    name: '',\n    type: 'address'\n  }],\n  name: 'lastWalletUpdate',\n  outputs: [{\n    internalType: 'uint256',\n    name: '',\n    type: 'uint256'\n  }],\n  stateMutability: 'view',\n  type: 'function'\n}, {\n  inputs: [{\n    components: [{\n      internalType: 'bool',\n      name: 'delegateCall',\n      type: 'bool'\n    }, {\n      internalType: 'bool',\n      name: 'revertOnError',\n      type: 'bool'\n    }, {\n      internalType: 'uint256',\n      name: 'gasLimit',\n      type: 'uint256'\n    }, {\n      internalType: 'address',\n      name: 'target',\n      type: 'address'\n    }, {\n      internalType: 'uint256',\n      name: 'value',\n      type: 'uint256'\n    }, {\n      internalType: 'bytes',\n      name: 'data',\n      type: 'bytes'\n    }],\n    internalType: 'struct IModuleCalls.Transaction[]',\n    name: '_txs',\n    type: 'tuple[]'\n  }],\n  name: 'multiCall',\n  outputs: [{\n    internalType: 'bool[]',\n    name: '_successes',\n    type: 'bool[]'\n  }, {\n    internalType: 'bytes[]',\n    name: '_results',\n    type: 'bytes[]'\n  }],\n  stateMutability: 'payable',\n  type: 'function'\n}, {\n  inputs: [{\n    internalType: 'address',\n    name: '_wallet',\n    type: 'address'\n  }, {\n    internalType: 'uint256',\n    name: '_threshold',\n    type: 'uint256'\n  }, {\n    components: [{\n      internalType: 'uint256',\n      name: 'weight',\n      type: 'uint256'\n    }, {\n      internalType: 'address',\n      name: 'signer',\n      type: 'address'\n    }],\n    internalType: 'struct RequireUtils.Member[]',\n    name: '_members',\n    type: 'tuple[]'\n  }, {\n    internalType: 'bool',\n    name: '_index',\n    type: 'bool'\n  }],\n  name: 'publishConfig',\n  outputs: [],\n  stateMutability: 'nonpayable',\n  type: 'function'\n}, {\n  inputs: [{\n    internalType: 'address',\n    name: '_wallet',\n    type: 'address'\n  }, {\n    internalType: 'bytes32',\n    name: '_hash',\n    type: 'bytes32'\n  }, {\n    internalType: 'uint256',\n    name: '_sizeMembers',\n    type: 'uint256'\n  }, {\n    internalType: 'bytes',\n    name: '_signature',\n    type: 'bytes'\n  }, {\n    internalType: 'bool',\n    name: '_index',\n    type: 'bool'\n  }],\n  name: 'publishInitialSigners',\n  outputs: [],\n  stateMutability: 'nonpayable',\n  type: 'function'\n}, {\n  inputs: [{\n    internalType: 'address',\n    name: '_wallet',\n    type: 'address'\n  }, {\n    internalType: 'uint256',\n    name: '_nonce',\n    type: 'uint256'\n  }],\n  name: 'requireMinNonce',\n  outputs: [],\n  stateMutability: 'view',\n  type: 'function'\n}, {\n  inputs: [{\n    internalType: 'uint256',\n    name: '_expiration',\n    type: 'uint256'\n  }],\n  name: 'requireNonExpired',\n  outputs: [],\n  stateMutability: 'view',\n  type: 'function'\n}];\n\nvar sequenceUtils = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  abi: abi$1\n});\n\nconst abi = [{\n  inputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  name: \"requireFreshSigner\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}];\n\nvar requireFreshSigner = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  abi: abi\n});\n\nconst walletContracts = {\n  erc1271,\n  factory,\n  mainModule,\n  mainModuleUpgradable,\n  sequenceUtils,\n  requireFreshSigner\n};\n\nexport { walletContracts };\n","import fetch from 'cross-fetch';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\n/* eslint-disable */\n// sequence-api v0.4.0 d026b8c7eb9ac3c9c5ed52994a34e2463c1aaa14\n// --\n// This file has been generated by https://github.com/webrpc/webrpc using gen/typescript\n// Do not edit by hand. Update your webrpc schema and re-generate.\n// WebRPC description and code-gen version\nconst WebRPCVersion = \"v1\"; // Schema version of your RIDL schema\n\nconst WebRPCSchemaVersion = \"v0.4.0\"; // Schema hash generated from your RIDL schema\n\nconst WebRPCSchemaHash = \"d026b8c7eb9ac3c9c5ed52994a34e2463c1aaa14\"; //\n// Types\n//\n\nlet SmartRampOrderStatus;\n\n(function (SmartRampOrderStatus) {\n  SmartRampOrderStatus[\"UNKNOWN\"] = \"UNKNOWN\";\n  SmartRampOrderStatus[\"RUNNING_CHECKS\"] = \"RUNNING_CHECKS\";\n  SmartRampOrderStatus[\"PROCESSING\"] = \"PROCESSING\";\n  SmartRampOrderStatus[\"FAILED\"] = \"FAILED\";\n  SmartRampOrderStatus[\"COMPLETE\"] = \"COMPLETE\";\n})(SmartRampOrderStatus || (SmartRampOrderStatus = {}));\n\nlet SortOrder;\n\n(function (SortOrder) {\n  SortOrder[\"DESC\"] = \"DESC\";\n  SortOrder[\"ASC\"] = \"ASC\";\n})(SortOrder || (SortOrder = {}));\n\n//\n// Client\n//\nclass API {\n  constructor(hostname, fetch) {\n    this.hostname = void 0;\n    this.fetch = void 0;\n    this.path = '/rpc/API/';\n\n    this.ping = headers => {\n      return this.fetch(this.url('Ping'), createHTTPRequest({}, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: _data.status\n          };\n        });\n      });\n    };\n\n    this.version = headers => {\n      return this.fetch(this.url('Version'), createHTTPRequest({}, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            version: _data.version\n          };\n        });\n      });\n    };\n\n    this.runtimeStatus = headers => {\n      return this.fetch(this.url('RuntimeStatus'), createHTTPRequest({}, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: _data.status\n          };\n        });\n      });\n    };\n\n    this.getSequenceContext = headers => {\n      return this.fetch(this.url('GetSequenceContext'), createHTTPRequest({}, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            data: _data.data\n          };\n        });\n      });\n    };\n\n    this.getAuthToken = (args, headers) => {\n      return this.fetch(this.url('GetAuthToken'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: _data.status,\n            jwtToken: _data.jwtToken,\n            address: _data.address,\n            user: _data.user\n          };\n        });\n      });\n    };\n\n    this.sendPasswordlessLink = (args, headers) => {\n      return this.fetch(this.url('SendPasswordlessLink'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: _data.status\n          };\n        });\n      });\n    };\n\n    this.friendList = (args, headers) => {\n      return this.fetch(this.url('FriendList'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            page: _data.page,\n            friends: _data.friends\n          };\n        });\n      });\n    };\n\n    this.getFriendByAddress = (args, headers) => {\n      return this.fetch(this.url('GetFriendByAddress'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: _data.status,\n            friend: _data.friend\n          };\n        });\n      });\n    };\n\n    this.searchFriends = (args, headers) => {\n      return this.fetch(this.url('SearchFriends'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            friends: _data.friends\n          };\n        });\n      });\n    };\n\n    this.addFriend = (args, headers) => {\n      return this.fetch(this.url('AddFriend'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: _data.status,\n            friend: _data.friend\n          };\n        });\n      });\n    };\n\n    this.updateFriendNickname = (args, headers) => {\n      return this.fetch(this.url('UpdateFriendNickname'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: _data.status,\n            friend: _data.friend\n          };\n        });\n      });\n    };\n\n    this.removeFriend = (args, headers) => {\n      return this.fetch(this.url('RemoveFriend'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: _data.status\n          };\n        });\n      });\n    };\n\n    this.contractCall = (args, headers) => {\n      return this.fetch(this.url('ContractCall'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            returns: _data.returns\n          };\n        });\n      });\n    };\n\n    this.decodeContractCall = (args, headers) => {\n      return this.fetch(this.url('DecodeContractCall'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            call: _data.call\n          };\n        });\n      });\n    };\n\n    this.lookupContractCallSelectors = (args, headers) => {\n      return this.fetch(this.url('LookupContractCallSelectors'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            signatures: _data.signatures\n          };\n        });\n      });\n    };\n\n    this.userStorageFetch = (args, headers) => {\n      return this.fetch(this.url('UserStorageFetch'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            object: _data.object\n          };\n        });\n      });\n    };\n\n    this.userStorageSave = (args, headers) => {\n      return this.fetch(this.url('UserStorageSave'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            ok: _data.ok\n          };\n        });\n      });\n    };\n\n    this.userStorageDelete = (args, headers) => {\n      return this.fetch(this.url('UserStorageDelete'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            ok: _data.ok\n          };\n        });\n      });\n    };\n\n    this.userStorageFetchAll = (args, headers) => {\n      return this.fetch(this.url('UserStorageFetchAll'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            objects: _data.objects\n          };\n        });\n      });\n    };\n\n    this.getMoonpayLink = (args, headers) => {\n      return this.fetch(this.url('GetMoonpayLink'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            signedUrl: _data.signedUrl\n          };\n        });\n      });\n    };\n\n    this.isUsingGoogleMail = (args, headers) => {\n      return this.fetch(this.url('IsUsingGoogleMail'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            yes: _data.yes\n          };\n        });\n      });\n    };\n\n    this.isValidSignature = (args, headers) => {\n      return this.fetch(this.url('IsValidSignature'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            isValid: _data.isValid\n          };\n        });\n      });\n    };\n\n    this.isValidMessageSignature = (args, headers) => {\n      return this.fetch(this.url('IsValidMessageSignature'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            isValid: _data.isValid\n          };\n        });\n      });\n    };\n\n    this.isValidTypedDataSignature = (args, headers) => {\n      return this.fetch(this.url('IsValidTypedDataSignature'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            isValid: _data.isValid\n          };\n        });\n      });\n    };\n\n    this.isValidETHAuthProof = (args, headers) => {\n      return this.fetch(this.url('IsValidETHAuthProof'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            isValid: _data.isValid\n          };\n        });\n      });\n    };\n\n    this.getCoinPrices = (args, headers) => {\n      return this.fetch(this.url('GetCoinPrices'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            tokenPrices: _data.tokenPrices\n          };\n        });\n      });\n    };\n\n    this.getCollectiblePrices = (args, headers) => {\n      return this.fetch(this.url('GetCollectiblePrices'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            tokenPrices: _data.tokenPrices\n          };\n        });\n      });\n    };\n\n    this.getExchangeRate = (args, headers) => {\n      return this.fetch(this.url('GetExchangeRate'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            exchangeRate: _data.exchangeRate\n          };\n        });\n      });\n    };\n\n    this.listPayCardsOnFile = headers => {\n      return this.fetch(this.url('ListPayCardsOnFile'), createHTTPRequest({}, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            payCards: _data.payCards\n          };\n        });\n      });\n    };\n\n    this.savePayCard = (args, headers) => {\n      return this.fetch(this.url('SavePayCard'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            ok: _data.ok,\n            payCard: _data.payCard\n          };\n        });\n      });\n    };\n\n    this.updatePayCardCVC = (args, headers) => {\n      return this.fetch(this.url('UpdatePayCardCVC'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            ok: _data.ok\n          };\n        });\n      });\n    };\n\n    this.deletePayCard = (args, headers) => {\n      return this.fetch(this.url('DeletePayCard'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            ok: _data.ok\n          };\n        });\n      });\n    };\n\n    this.smartRampQuote = (args, headers) => {\n      return this.fetch(this.url('SmartRampQuote'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: _data.status,\n            quoteDetails: _data.quoteDetails\n          };\n        });\n      });\n    };\n\n    this.smartRampPurchase = (args, headers) => {\n      return this.fetch(this.url('SmartRampPurchase'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            processing: _data.processing,\n            receipt: _data.receipt\n          };\n        });\n      });\n    };\n\n    this.smartRampWaitOrderConfirmation = (args, headers) => {\n      return this.fetch(this.url('SmartRampWaitOrderConfirmation'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            done: _data.done,\n            receipt: _data.receipt\n          };\n        });\n      });\n    };\n\n    this.smartRampGetOrder = (args, headers) => {\n      return this.fetch(this.url('SmartRampGetOrder'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            order: _data.order\n          };\n        });\n      });\n    };\n\n    this.smartRampCheckCardAuthorization = (args, headers) => {\n      return this.fetch(this.url('SmartRampCheckCardAuthorization'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            cardAuth: _data.cardAuth\n          };\n        });\n      });\n    };\n\n    this.smartRampSubmitCardAuthorization = (args, headers) => {\n      return this.fetch(this.url('SmartRampSubmitCardAuthorization'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: _data.status\n          };\n        });\n      });\n    };\n\n    this.smartRampOrdersList = (args, headers) => {\n      return this.fetch(this.url('SmartRampOrdersList'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            page: _data.page,\n            orders: _data.orders\n          };\n        });\n      });\n    };\n\n    this.getInviteInfo = headers => {\n      return this.fetch(this.url('GetInviteInfo'), createHTTPRequest({}, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            inviteInfo: _data.inviteInfo\n          };\n        });\n      });\n    };\n\n    this.isValidAccessCode = (args, headers) => {\n      return this.fetch(this.url('IsValidAccessCode'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: _data.status\n          };\n        });\n      });\n    };\n\n    this.internalClaimAccessCode = (args, headers) => {\n      return this.fetch(this.url('InternalClaimAccessCode'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: _data.status\n          };\n        });\n      });\n    };\n\n    this.walletRecover = (args, headers) => {\n      return this.fetch(this.url('WalletRecover'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            encryptedWallet: _data.encryptedWallet\n          };\n        });\n      });\n    };\n\n    this.hostname = hostname;\n    this.fetch = fetch;\n  }\n\n  url(name) {\n    return this.hostname + this.path + name;\n  }\n\n}\n\nconst createHTTPRequest = (body = {}, headers = {}) => {\n  return {\n    method: 'POST',\n    headers: _extends({}, headers, {\n      'Content-Type': 'application/json'\n    }),\n    body: JSON.stringify(body || {})\n  };\n};\n\nconst buildResponse = res => {\n  return res.text().then(text => {\n    let data;\n\n    try {\n      data = JSON.parse(text);\n    } catch (err) {\n      throw {\n        code: 'unknown',\n        msg: `expecting JSON, got: ${text}`,\n        status: res.status\n      };\n    }\n\n    if (!res.ok) {\n      throw data; // webrpc error response\n    }\n\n    return data;\n  });\n};\n\nclass SequenceAPIClient extends API {\n  constructor(hostname, jwtAuth) {\n    super(hostname.endsWith('/') ? hostname.slice(0, -1) : hostname, fetch);\n    this.jwtAuth = jwtAuth;\n\n    this._fetch = (input, init) => {\n      // automatically include jwt auth header to requests\n      // if its been set on the api client\n      const headers = {};\n\n      if (this.jwtAuth && this.jwtAuth.length > 0) {\n        headers['Authorization'] = `BEARER ${this.jwtAuth}`;\n      } // before the request is made\n\n\n      init.headers = _extends({}, init.headers, headers);\n      return fetch(input, init);\n    };\n\n    this.fetch = this._fetch;\n  }\n\n}\n\nexport { API, SequenceAPIClient, SmartRampOrderStatus, SortOrder, WebRPCSchemaHash, WebRPCSchemaVersion, WebRPCVersion };\n","import { ethers } from 'ethers';\nimport { Base64 } from 'js-base64';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\n\nvar encodeTypedDataHash = function (typedData) {\r\n    return ethers.utils._TypedDataEncoder.hash(typedData.domain, typedData.types, typedData.message);\r\n};\r\nvar encodeTypedDataDigest = function (typedData) {\r\n    var hash = encodeTypedDataHash(typedData);\r\n    var digest = ethers.utils.arrayify(ethers.utils.keccak256(hash));\r\n    return digest;\r\n};\n\nvar Proof = /** @class */ (function () {\r\n    function Proof(args) {\r\n        this.prefix = ETHAuthPrefix;\r\n        this.address = (args === null || args === void 0 ? void 0 : args.address) ? args.address.toLowerCase() : '';\r\n        this.claims = (args === null || args === void 0 ? void 0 : args.claims) ? args.claims : { app: '', iat: 0, exp: 0, v: ETHAuthVersion };\r\n        this.signature = (args === null || args === void 0 ? void 0 : args.signature) ? args.signature : '';\r\n        this.extra = (args === null || args === void 0 ? void 0 : args.extra) ? args.extra : '';\r\n    }\r\n    Proof.prototype.setIssuedAtNow = function () {\r\n        this.claims.iat = Math.round((new Date()).getTime() / 1000);\r\n    };\r\n    Proof.prototype.setExpiryIn = function (seconds) {\r\n        this.claims.exp = Math.round((new Date()).getTime() / 1000) + seconds;\r\n    };\r\n    Proof.prototype.validateClaims = function () {\r\n        return validateClaims(this.claims);\r\n    };\r\n    Proof.prototype.messageDigest = function () {\r\n        var isValid = this.validateClaims();\r\n        if (isValid.err) {\r\n            throw isValid.err;\r\n        }\r\n        return ethers.utils.arrayify(encodeTypedDataHash(this.messageTypedData()));\r\n    };\r\n    Proof.prototype.messageTypedData = function () {\r\n        var domain = __assign({}, ETHAuthEIP712Domain);\r\n        var types = {\r\n            'Claims': []\r\n        };\r\n        var message = {};\r\n        var typedData = { domain: domain, types: types, message: message };\r\n        if (this.claims.app && this.claims.app.length > 0) {\r\n            typedData.types.Claims.push({ name: 'app', type: 'string' });\r\n            typedData.message['app'] = this.claims.app;\r\n        }\r\n        if (this.claims.iat && this.claims.iat > 0) {\r\n            typedData.types.Claims.push({ name: 'iat', type: 'int64' });\r\n            typedData.message['iat'] = this.claims.iat;\r\n        }\r\n        if (this.claims.exp && this.claims.exp > 0) {\r\n            typedData.types.Claims.push({ name: 'exp', type: 'int64' });\r\n            typedData.message['exp'] = this.claims.exp;\r\n        }\r\n        if (this.claims.n && this.claims.n > 0) {\r\n            typedData.types.Claims.push({ name: 'n', type: 'uint64' });\r\n            typedData.message['n'] = this.claims.n;\r\n        }\r\n        if (this.claims.typ && this.claims.typ.length > 0) {\r\n            typedData.types.Claims.push({ name: 'typ', type: 'string' });\r\n            typedData.message['typ'] = this.claims.typ;\r\n        }\r\n        if (this.claims.ogn && this.claims.ogn.length > 0) {\r\n            typedData.types.Claims.push({ name: 'ogn', type: 'string' });\r\n            typedData.message['ogn'] = this.claims.ogn;\r\n        }\r\n        if (this.claims.v && this.claims.v.length > 0) {\r\n            typedData.types.Claims.push({ name: 'v', type: 'string' });\r\n            typedData.message['v'] = this.claims.v;\r\n        }\r\n        return typedData;\r\n    };\r\n    return Proof;\r\n}());\r\nvar validateClaims = function (claims) {\r\n    if (claims.app === '') {\r\n        return { ok: false, err: new Error('claims: app is empty') };\r\n    }\r\n    var now = Math.round((new Date()).getTime() / 1000);\r\n    var drift = 5 * 60; // 5 minutes\r\n    var max = (60 * 60 * 24 * 365) + drift; // 1 year\r\n    if (claims.v === '') {\r\n        return { ok: false, err: new Error('claims: ethauth version is empty') };\r\n    }\r\n    if (claims.iat && claims.iat !== 0 && (claims.iat > now + drift || claims.iat < now - max)) {\r\n        return { ok: false, err: new Error('claims: iat is invalid') };\r\n    }\r\n    if (claims.exp < now - drift || claims.exp > now + max) {\r\n        return { ok: false, err: new Error('claims: token has expired') };\r\n    }\r\n    return { ok: true };\r\n};\n\n// ValidateEOAProof verifies the account proof, testing if the proof claims have been signed with an\r\n// EOA (externally owned account) and will return success/failture, the account address as a string, and any errors.\r\nvar ValidateEOAProof = function (provider, chainId, proof) { return __awaiter(void 0, void 0, void 0, function () {\r\n    var messageDigest, address;\r\n    return __generator(this, function (_a) {\r\n        messageDigest = proof.messageDigest();\r\n        address = ethers.utils.verifyMessage(messageDigest, proof.signature);\r\n        if (address.slice(0, 2) === '0x' && address.length === 42 &&\r\n            address.toLowerCase() === proof.address.toLowerCase()) {\r\n            return [2 /*return*/, { isValid: true, address: proof.address }];\r\n        }\r\n        else {\r\n            return [2 /*return*/, { isValid: false }];\r\n        }\r\n    });\r\n}); };\r\n// ValidateContractAccountProof verifies the account proof, testing if the\r\n// proof claims have been signed with a smart-contract based account by calling the EIP-1271\r\n// method of the remote contract. This method will return success/failure, the\r\n// account address as a string, and any errors. The wallet contract must be deployed in\r\n// order for this call to be successful. In order test an undeployed smart-wallet, you\r\n// will have to implement your own custom validator method.\r\nvar ValidateContractAccountProof = function (provider, chainId, proof) { return __awaiter(void 0, void 0, void 0, function () {\r\n    var messageDigest, walletCode, abi, contract, isValidSignature;\r\n    return __generator(this, function (_a) {\r\n        switch (_a.label) {\r\n            case 0:\r\n                if (!provider || provider === undefined) {\r\n                    return [2 /*return*/, { isValid: false }];\r\n                }\r\n                messageDigest = proof.messageDigest();\r\n                return [4 /*yield*/, provider.getCode(proof.address)];\r\n            case 1:\r\n                walletCode = _a.sent();\r\n                if (walletCode === '0x' || walletCode.length <= 2) {\r\n                    throw new Error('ValidateContractAccountProof failed. unable to fetch wallet contract code');\r\n                }\r\n                abi = ['function isValidSignature(bytes32, bytes) public view returns (bytes4)'];\r\n                contract = new ethers.Contract(proof.address, abi, provider);\r\n                return [4 /*yield*/, contract.isValidSignature(messageDigest, ethers.utils.arrayify(proof.signature))];\r\n            case 2:\r\n                isValidSignature = _a.sent();\r\n                if (isValidSignature === IsValidSignatureBytes32MagicValue) {\r\n                    return [2 /*return*/, { isValid: true, address: proof.address }];\r\n                }\r\n                else {\r\n                    return [2 /*return*/, { isValid: false }];\r\n                }\r\n        }\r\n    });\r\n}); };\r\n// IsValidSignatureBytes32 is the EIP-1271 magic value we test\r\nvar IsValidSignatureBytes32MagicValue = '0x1626ba7e';\n\nvar ETHAuthVersion = '1';\r\nvar ETHAuthPrefix = 'eth';\r\nvar ETHAuthEIP712Domain = {\r\n    name: 'ETHAuth',\r\n    version: ETHAuthVersion,\r\n};\r\nvar ETHAuth = /** @class */ (function () {\r\n    function ETHAuth() {\r\n        var _this = this;\r\n        var validators = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            validators[_i] = arguments[_i];\r\n        }\r\n        this.configJsonRpcProvider = function (ethereumJsonRpcURL) { return __awaiter(_this, void 0, void 0, function () {\r\n            var netVersion;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        this.provider = new ethers.providers.JsonRpcProvider(ethereumJsonRpcURL);\r\n                        return [4 /*yield*/, this.provider.send('net_version', [])];\r\n                    case 1:\r\n                        netVersion = _a.sent();\r\n                        this.chainId = parseInt(netVersion);\r\n                        if (!this.chainId || this.chainId === 0 || this.chainId === NaN) {\r\n                            throw new Error('ethauth: unable to get chainId');\r\n                        }\r\n                        this.ethereumJsonRpcURL = ethereumJsonRpcURL;\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        }); };\r\n        this.configValidators = function () {\r\n            var validators = [];\r\n            for (var _i = 0; _i < arguments.length; _i++) {\r\n                validators[_i] = arguments[_i];\r\n            }\r\n            if (validators.length == 0) {\r\n                throw new Error('validators list is empty');\r\n            }\r\n            _this.validators = validators;\r\n        };\r\n        this.encodeProof = function (proof, skipSignatureValidation) {\r\n            if (skipSignatureValidation === void 0) { skipSignatureValidation = false; }\r\n            return __awaiter(_this, void 0, void 0, function () {\r\n                var isValid, claimsJSON, proofString;\r\n                return __generator(this, function (_a) {\r\n                    switch (_a.label) {\r\n                        case 0:\r\n                            if (proof.address.length !== 42 || proof.address.slice(0, 2) !== '0x') {\r\n                                throw new Error('ethauth: invalid address');\r\n                            }\r\n                            if (proof.signature === '' || proof.signature.slice(0, 2) !== '0x') {\r\n                                throw new Error('ethauth: invalid signature');\r\n                            }\r\n                            if (proof.extra && proof.extra.slice(0, 2) !== '0x') {\r\n                                throw new Error('ethauth: invalid extra encoding, expecting hex data');\r\n                            }\r\n                            return [4 /*yield*/, this.validateProof(proof, skipSignatureValidation)];\r\n                        case 1:\r\n                            isValid = _a.sent();\r\n                            if (!isValid) {\r\n                                throw new Error(\"ethauth: proof is invalid\");\r\n                            }\r\n                            claimsJSON = JSON.stringify(proof.claims);\r\n                            proofString = ETHAuthPrefix + '.' +\r\n                                proof.address.toLowerCase() + '.' +\r\n                                Base64.encode(claimsJSON, true) + '.' +\r\n                                proof.signature;\r\n                            if (proof.extra && proof.extra.length > 0) {\r\n                                proofString += '.' + proof.extra;\r\n                            }\r\n                            return [2 /*return*/, proofString];\r\n                    }\r\n                });\r\n            });\r\n        };\r\n        this.decodeProof = function (proofString, skipSignatureValidation) {\r\n            if (skipSignatureValidation === void 0) { skipSignatureValidation = false; }\r\n            return __awaiter(_this, void 0, void 0, function () {\r\n                var parts, prefix, address, messageBase64, signature, extra, message, claims, proof, isValid;\r\n                return __generator(this, function (_a) {\r\n                    switch (_a.label) {\r\n                        case 0:\r\n                            parts = proofString.split('.');\r\n                            if (parts.length < 4 || parts.length > 5) {\r\n                                throw new Error('ethauth: invalid proof string');\r\n                            }\r\n                            prefix = parts[0], address = parts[1], messageBase64 = parts[2], signature = parts[3], extra = parts[4];\r\n                            // check prefix\r\n                            if (prefix !== ETHAuthPrefix) {\r\n                                throw new Error('ethauth: not an ethauth proof');\r\n                            }\r\n                            message = Base64.decode(messageBase64);\r\n                            claims = JSON.parse(message);\r\n                            proof = new Proof({ address: address, claims: claims, signature: signature, extra: extra });\r\n                            return [4 /*yield*/, this.validateProof(proof, skipSignatureValidation)];\r\n                        case 1:\r\n                            isValid = _a.sent();\r\n                            if (!isValid) {\r\n                                throw new Error(\"ethauth: proof is invalid\");\r\n                            }\r\n                            return [2 /*return*/, proof];\r\n                    }\r\n                });\r\n            });\r\n        };\r\n        this.validateProof = function (proof, skipSignatureValidation) {\r\n            if (skipSignatureValidation === void 0) { skipSignatureValidation = false; }\r\n            return __awaiter(_this, void 0, void 0, function () {\r\n                var isValidClaims, isValidSig;\r\n                return __generator(this, function (_a) {\r\n                    switch (_a.label) {\r\n                        case 0:\r\n                            isValidClaims = this.validateProofClaims(proof);\r\n                            if (isValidClaims.err) {\r\n                                throw new Error(\"ethauth: proof claims are invalid \".concat(isValidClaims.err));\r\n                            }\r\n                            if (!(skipSignatureValidation !== true)) return [3 /*break*/, 2];\r\n                            return [4 /*yield*/, this.validateProofSignature(proof)];\r\n                        case 1:\r\n                            isValidSig = _a.sent();\r\n                            if (isValidSig !== true) {\r\n                                throw new Error('ethauth: proof signature is invalid');\r\n                            }\r\n                            _a.label = 2;\r\n                        case 2: return [2 /*return*/, true];\r\n                    }\r\n                });\r\n            });\r\n        };\r\n        this.validateProofSignature = function (proof) { return __awaiter(_this, void 0, void 0, function () {\r\n            var retIsValid, i, validator, isValid, i;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        retIsValid = [];\r\n                        i = 0;\r\n                        _a.label = 1;\r\n                    case 1:\r\n                        if (!(i < this.validators.length)) return [3 /*break*/, 6];\r\n                        _a.label = 2;\r\n                    case 2:\r\n                        _a.trys.push([2, 4, , 5]);\r\n                        validator = this.validators[i];\r\n                        return [4 /*yield*/, validator(this.provider, this.chainId, proof)];\r\n                    case 3:\r\n                        isValid = (_a.sent()).isValid;\r\n                        if (isValid === true) {\r\n                            // preemptively return true if we've determined it to be valid\r\n                            return [2 /*return*/, true];\r\n                        }\r\n                        retIsValid.push(isValid);\r\n                        return [3 /*break*/, 5];\r\n                    case 4:\r\n                        _a.sent();\r\n                        retIsValid.push(false);\r\n                        return [3 /*break*/, 5];\r\n                    case 5:\r\n                        i++;\r\n                        return [3 /*break*/, 1];\r\n                    case 6:\r\n                        for (i = 0; i < retIsValid.length; i++) {\r\n                            if (retIsValid[i]) {\r\n                                return [2 /*return*/, true];\r\n                            }\r\n                        }\r\n                        return [2 /*return*/, false];\r\n                }\r\n            });\r\n        }); };\r\n        this.validateProofClaims = function (proof) {\r\n            return proof.validateClaims();\r\n        };\r\n        if (validators.length == 0) {\r\n            this.validators = [ValidateEOAProof, ValidateContractAccountProof];\r\n        }\r\n        else {\r\n            this.validators = validators;\r\n        }\r\n    }\r\n    return ETHAuth;\r\n}());\n\nexport { ETHAuth, ETHAuthEIP712Domain, ETHAuthPrefix, ETHAuthVersion, IsValidSignatureBytes32MagicValue, Proof, ValidateContractAccountProof, ValidateEOAProof, encodeTypedDataDigest, encodeTypedDataHash, validateClaims };\n","import { urlClean, logger } from '@0xsequence/utils';\nimport { ethers } from 'ethers';\nimport { JsonRpcProvider } from '@ethersproject/providers';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction isNetworkConfig(cand) {\n  return cand && cand.chainId !== undefined && cand.name !== undefined && cand.rpcUrl !== undefined && cand.relayer !== undefined;\n}\nconst getChainId = chainId => {\n  if (typeof chainId === 'number') {\n    return chainId;\n  }\n\n  if (chainId.chainId) {\n    return chainId.chainId;\n  }\n\n  return ethers.BigNumber.from(chainId).toNumber();\n};\nconst maybeChainId = chainId => {\n  if (!chainId) return undefined;\n  return getChainId(chainId);\n};\nconst getAuthNetwork = networks => {\n  return networks.find(network => network.isAuthChain);\n};\nconst isValidNetworkConfig = (networkConfig, raise = false, skipRelayerCheck = false) => {\n  if (!networkConfig) throw new Error(`invalid network config: empty config`);\n  const configs = [];\n\n  if (Array.isArray(networkConfig)) {\n    configs.push(...networkConfig);\n  } else {\n    configs.push(networkConfig);\n  }\n\n  if (configs.length === 0) {\n    if (raise) throw new Error(`invalid network config: empty config`);\n    return false;\n  } // Ensure distinct chainId configs\n\n\n  const chainIds = configs.map(c => c.chainId).sort();\n  const dupes = chainIds.filter((c, i) => chainIds.indexOf(c) !== i);\n\n  if (dupes.length > 0) {\n    if (raise) throw new Error(`invalid network config: duplicate chainIds ${dupes}`);\n    return false;\n  } // Downcase all network names\n\n\n  configs.forEach(c => c.name = c.name.toLowerCase()); // Ensure distinct network names\n\n  const names = configs.map(c => c.name).sort();\n  const nameDupes = names.filter((c, i) => names.indexOf(c) !== i);\n\n  if (nameDupes.length > 0) {\n    if (raise) throw new Error(`invalid network config: duplicate network names ${nameDupes}`);\n    return false;\n  } // Ensure rpcUrl or provider is specified\n  // Ensure relayerUrl or relayer is specified\n  // Ensure one default chain\n  // Ensure one auth chain\n\n\n  let defaultChain = false;\n  let authChain = false;\n\n  for (let i = 0; i < configs.length; i++) {\n    const c = configs[i];\n\n    if ((!c.rpcUrl || c.rpcUrl === '') && !c.provider) {\n      if (raise) throw new Error(`invalid network config for chainId ${c.chainId}: rpcUrl or provider must be provided`);\n      return false;\n    }\n\n    if (!skipRelayerCheck) {\n      if (!c.relayer) {\n        if (raise) throw new Error(`invalid network config for chainId ${c.chainId}: relayer must be provided`);\n        return false;\n      }\n    }\n\n    if (c.isDefaultChain) {\n      if (defaultChain) {\n        if (raise) throw new Error(`invalid network config for chainId ${c.chainId}: DefaultChain is already set by another config`);\n        return false;\n      }\n\n      defaultChain = true;\n    }\n\n    if (c.isAuthChain) {\n      if (authChain) {\n        if (raise) throw new Error(`invalid network config for chainId ${c.chainId}: AuthChain is already set by another config`);\n      }\n\n      authChain = true;\n    }\n  }\n\n  if (!defaultChain) {\n    if (raise) throw new Error(`invalid network config: DefaultChain must be set`);\n    return false;\n  }\n\n  if (!authChain) {\n    if (raise) throw new Error(`invalid network config: AuthChain must be set`);\n    return false;\n  }\n\n  return true;\n};\nconst ensureValidNetworks = (networks, skipRelayerCheck = false) => {\n  isValidNetworkConfig(networks, true, skipRelayerCheck);\n  return networks;\n};\nconst ensureUniqueNetworks = (networks, raise = true) => {\n  const chainIds = networks.map(c => c.chainId).sort();\n  const dupes = chainIds.filter((c, i) => chainIds.indexOf(c) !== i);\n\n  if (dupes.length > 0) {\n    if (raise) throw new Error(`invalid network config: duplicate chainIds ${dupes}`);\n    return false;\n  }\n\n  return true;\n};\nconst updateNetworkConfig = (src, dest) => {\n  if (!src || !dest) return;\n\n  if (!src.chainId && !src.name) {\n    throw new Error('failed to update network config: source config is missing chainId or name');\n  }\n\n  if (src.chainId !== dest.chainId && src.name !== dest.name) {\n    throw new Error('failed to update network config: one of chainId or name must match');\n  }\n\n  if (src.rpcUrl) {\n    dest.rpcUrl = src.rpcUrl;\n    dest.provider = undefined;\n  }\n\n  if (src.provider) {\n    dest.provider = src.provider;\n  }\n\n  if (src.relayer) {\n    dest.relayer = src.relayer;\n  }\n\n  if (src.ensAddress) {\n    dest.ensAddress = src.ensAddress;\n  } // NOTE: we do not set default or auth chain from here\n  // if (src.isDefaultChain) {\n  //   dest.isDefaultChain = src.isDefaultChain\n  // }\n  // if (src.isAuthChain) {\n  //   dest.isAuthChain = src.isAuthChain\n  // }\n\n};\nconst createNetworkConfig = (networks, defaultChainId, vars) => {\n  let config = [];\n\n  if (typeof networks === 'function' && vars) {\n    config = networks(vars);\n  } else {\n    config = networks;\n  }\n\n  if (defaultChainId) {\n    config.forEach(n => n.isDefaultChain = false);\n    const mainNetwork = config.filter(n => n.chainId === defaultChainId);\n\n    if (!mainNetwork || mainNetwork.length === 0) {\n      throw new Error(`defaultChainId ${defaultChainId} cannot be found in network list`);\n    } else {\n      mainNetwork[0].isDefaultChain = true;\n    }\n  }\n\n  return ensureValidNetworks(sortNetworks(config));\n};\nconst findNetworkConfig = (networks, chainId) => {\n  if (typeof chainId === 'string') {\n    if (chainId.startsWith('0x')) {\n      const id = ethers.BigNumber.from(chainId).toNumber();\n      return networks.find(n => n.chainId === id);\n    } else {\n      return networks.find(n => n.name === chainId);\n    }\n  } else if (typeof chainId === 'number') {\n    return networks.find(n => n.chainId === chainId);\n  } else if (chainId.chainId) {\n    return networks.find(n => n.chainId === chainId.chainId);\n  } else {\n    return undefined;\n  }\n};\nconst checkNetworkConfig = (network, chainId) => {\n  if (!network) return false;\n  if (network.name === chainId) return true;\n  if (network.chainId === chainId) return true;\n  return false;\n};\nconst networksIndex = networks => {\n  const index = {};\n\n  for (let i = 0; i < networks.length; i++) {\n    index[networks[i].name] = networks[i];\n  }\n\n  return index;\n}; // TODO: we should remove sortNetworks in the future but this is a breaking change for dapp integrations on older versions <-> wallet\n// sortNetworks orders the network config list by: defaultChain, authChain, ..rest by chainId ascending numbers\n\nconst sortNetworks = networks => {\n  if (!networks) {\n    return [];\n  }\n\n  const config = networks.sort((a, b) => {\n    if (a.chainId === b.chainId) return 0;\n    return a.chainId < b.chainId ? -1 : 1;\n  }); // DefaultChain goes first\n\n  const defaultConfigIdx = config.findIndex(c => c.isDefaultChain);\n  if (defaultConfigIdx > 0) config.splice(0, 0, config.splice(defaultConfigIdx, 1)[0]); // AuthChain goes second\n\n  const authConfigIdx = config.findIndex(c => c.isAuthChain && c.isDefaultChain !== true);\n  if (authConfigIdx > 0) config.splice(1, 0, config.splice(authConfigIdx, 1)[0]);\n  return config;\n};\n\nlet ChainId;\n\n(function (ChainId) {\n  ChainId[ChainId[\"MAINNET\"] = 1] = \"MAINNET\";\n  ChainId[ChainId[\"ROPSTEN\"] = 3] = \"ROPSTEN\";\n  ChainId[ChainId[\"RINKEBY\"] = 4] = \"RINKEBY\";\n  ChainId[ChainId[\"GOERLI\"] = 5] = \"GOERLI\";\n  ChainId[ChainId[\"KOVAN\"] = 42] = \"KOVAN\";\n  ChainId[ChainId[\"POLYGON\"] = 137] = \"POLYGON\";\n  ChainId[ChainId[\"POLYGON_MUMBAI\"] = 80001] = \"POLYGON_MUMBAI\";\n  ChainId[ChainId[\"BSC\"] = 56] = \"BSC\";\n  ChainId[ChainId[\"BSC_TESTNET\"] = 97] = \"BSC_TESTNET\";\n  ChainId[ChainId[\"OPTIMISM\"] = 10] = \"OPTIMISM\";\n  ChainId[ChainId[\"OPTIMISM_TESTNET\"] = 69] = \"OPTIMISM_TESTNET\";\n  ChainId[ChainId[\"ARBITRUM\"] = 42161] = \"ARBITRUM\";\n  ChainId[ChainId[\"ARBITRUM_TESTNET\"] = 421611] = \"ARBITRUM_TESTNET\";\n  ChainId[ChainId[\"AVALANCHE\"] = 43114] = \"AVALANCHE\";\n  ChainId[ChainId[\"AVALANCHE_TESTNET\"] = 43113] = \"AVALANCHE_TESTNET\";\n  ChainId[ChainId[\"FANTOM\"] = 250] = \"FANTOM\";\n  ChainId[ChainId[\"FANTOM_TESTNET\"] = 4002] = \"FANTOM_TESTNET\";\n  ChainId[ChainId[\"GNOSIS\"] = 100] = \"GNOSIS\";\n  ChainId[ChainId[\"AURORA\"] = 1313161554] = \"AURORA\";\n  ChainId[ChainId[\"AURORA_TESTNET\"] = 1313161556] = \"AURORA_TESTNET\";\n})(ChainId || (ChainId = {}));\n\nconst networks = {\n  [ChainId.MAINNET]: {\n    chainId: ChainId.MAINNET,\n    name: 'mainnet',\n    title: 'Ethereum',\n    blockExplorer: {\n      name: 'Etherscan',\n      rootUrl: 'https://etherscan.io/'\n    }\n  },\n  [ChainId.ROPSTEN]: {\n    chainId: ChainId.ROPSTEN,\n    name: 'ropsten',\n    title: 'Ropsten',\n    testnet: true,\n    blockExplorer: {\n      name: 'Etherscan (Ropsten)',\n      rootUrl: 'https://ropsten.etherscan.io/'\n    }\n  },\n  [ChainId.RINKEBY]: {\n    chainId: ChainId.RINKEBY,\n    name: 'rinkeby',\n    title: 'Rinkeby',\n    testnet: true,\n    blockExplorer: {\n      name: 'Etherscan (Rinkeby)',\n      rootUrl: 'https://rinkeby.etherscan.io/'\n    }\n  },\n  [ChainId.GOERLI]: {\n    chainId: ChainId.GOERLI,\n    name: 'goerli',\n    title: 'Goerli',\n    testnet: true,\n    blockExplorer: {\n      name: 'Etherscan (Goerli)',\n      rootUrl: 'https://goerli.etherscan.io/'\n    }\n  },\n  [ChainId.KOVAN]: {\n    chainId: ChainId.KOVAN,\n    name: 'kovan',\n    title: 'Kovan',\n    testnet: true,\n    blockExplorer: {\n      name: 'Etherscan (Kovan)',\n      rootUrl: 'https://kovan.etherscan.io/'\n    }\n  },\n  [ChainId.POLYGON]: {\n    chainId: ChainId.POLYGON,\n    name: 'polygon',\n    title: 'Polygon',\n    blockExplorer: {\n      name: 'Polygonscan',\n      rootUrl: 'https://polygonscan.com/'\n    }\n  },\n  [ChainId.POLYGON_MUMBAI]: {\n    chainId: ChainId.POLYGON_MUMBAI,\n    name: 'mumbai',\n    title: 'Polygon Mumbai',\n    testnet: true,\n    blockExplorer: {\n      name: 'Polygonscan (Mumbai)',\n      rootUrl: 'https://mumbai.polygonscan.com/'\n    }\n  },\n  [ChainId.BSC]: {\n    chainId: ChainId.BSC,\n    name: 'bsc',\n    title: 'BNB Smart Chain',\n    blockExplorer: {\n      name: 'BSCScan',\n      rootUrl: 'https://bscscan.com/'\n    }\n  },\n  [ChainId.BSC_TESTNET]: {\n    chainId: ChainId.BSC_TESTNET,\n    name: 'bsc-testnet',\n    title: 'BNB Smart Chain Testnet',\n    testnet: true,\n    blockExplorer: {\n      name: 'BSCScan (Testnet)',\n      rootUrl: 'https://testnet.bscscan.com/'\n    }\n  },\n  [ChainId.OPTIMISM]: {\n    chainId: ChainId.OPTIMISM,\n    name: 'optimism',\n    title: 'Optimism',\n    blockExplorer: {\n      name: 'Etherscan (Optimism)',\n      rootUrl: 'https://optimistic.etherscan.io/'\n    }\n  },\n  [ChainId.OPTIMISM_TESTNET]: {\n    chainId: ChainId.OPTIMISM_TESTNET,\n    name: 'optimism-testnet',\n    title: 'Optimistic Kovan',\n    testnet: true,\n    blockExplorer: {\n      name: 'Etherscan (Optimism Testnet)',\n      rootUrl: 'https://kovan-optimistic.etherscan.io/'\n    }\n  },\n  [ChainId.ARBITRUM]: {\n    chainId: ChainId.ARBITRUM,\n    name: 'arbitrum',\n    title: 'Arbitrum',\n    blockExplorer: {\n      name: 'Arbiscan',\n      rootUrl: 'https://arbiscan.io/'\n    }\n  },\n  [ChainId.ARBITRUM_TESTNET]: {\n    chainId: ChainId.ARBITRUM_TESTNET,\n    name: 'arbitrum-testnet',\n    title: 'Arbitrum Testnet',\n    testnet: true,\n    blockExplorer: {\n      name: 'Arbiscan (Testnet)',\n      rootUrl: 'https://testnet.arbiscan.io/'\n    }\n  },\n  [ChainId.AVALANCHE]: {\n    chainId: ChainId.AVALANCHE,\n    name: 'avalanche',\n    title: 'Avalanche',\n    blockExplorer: {\n      name: 'Snowtrace',\n      rootUrl: 'https://snowtrace.io/'\n    }\n  },\n  [ChainId.AVALANCHE_TESTNET]: {\n    chainId: ChainId.AVALANCHE_TESTNET,\n    name: 'avalanche-testnet',\n    title: 'Avalanche Testnet',\n    testnet: true,\n    blockExplorer: {\n      name: 'Snowtrace (Testnet)',\n      rootUrl: 'https://testnet.snowtrace.io/'\n    }\n  },\n  [ChainId.FANTOM]: {\n    chainId: ChainId.FANTOM,\n    name: 'fantom',\n    title: 'Fantom',\n    blockExplorer: {\n      name: 'FTMScan',\n      rootUrl: 'https://ftmscan.com/'\n    }\n  },\n  [ChainId.FANTOM_TESTNET]: {\n    chainId: ChainId.FANTOM_TESTNET,\n    name: 'fantom-testnet',\n    title: 'Fantom Testnet',\n    testnet: true,\n    blockExplorer: {\n      name: 'FTMScan (Testnet)',\n      rootUrl: 'https://testnet.ftmscan.com/'\n    }\n  },\n  [ChainId.GNOSIS]: {\n    chainId: ChainId.GNOSIS,\n    name: 'gnosis',\n    title: 'Gnosis Chain',\n    blockExplorer: {\n      name: 'Gnosis Chain Explorer',\n      rootUrl: 'https://blockscout.com/xdai/mainnet/'\n    }\n  },\n  [ChainId.AURORA]: {\n    chainId: ChainId.AURORA,\n    name: 'aurora',\n    title: 'Aurora',\n    blockExplorer: {\n      name: 'Aurora Explorer',\n      rootUrl: 'https://aurorascan.dev/'\n    }\n  },\n  [ChainId.AURORA_TESTNET]: {\n    chainId: ChainId.AURORA_TESTNET,\n    name: 'aurora-testnet',\n    title: 'Aurora Testnet',\n    blockExplorer: {\n      name: 'Aurora Explorer (Testnet)',\n      rootUrl: 'https://testnet.aurorascan.dev/'\n    }\n  }\n};\nconst mainnetNetworks = createNetworkConfig(vars => [_extends({}, networks[ChainId.MAINNET], {\n  ensAddress: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',\n  rpcUrl: urlClean(`${vars.baseRpcUrl}/mainnet`),\n  relayer: {\n    url: urlClean(`${vars.baseRelayerUrl}/mainnet`)\n  },\n  isDefaultChain: true\n}), _extends({}, networks[ChainId.POLYGON], {\n  rpcUrl: 'https://rpc-mainnet.matic.network',\n  relayer: {\n    url: urlClean(`${vars.baseRelayerUrl}/matic`)\n  },\n  isAuthChain: true\n})], 1, {\n  baseRpcUrl: 'https://nodes.sequence.app',\n  baseRelayerUrl: 'https://relayers.sequence.app'\n});\nconst testnetNetworks = createNetworkConfig(vars => [_extends({}, networks[ChainId.RINKEBY], {\n  ensAddress: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',\n  rpcUrl: urlClean(`${vars.baseRpcUrl}/rinkeby`),\n  relayer: {\n    url: urlClean(`${vars.baseRelayerUrl}/rinkeby`)\n  },\n  isDefaultChain: true\n}), _extends({}, networks[ChainId.GOERLI], {\n  ensAddress: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',\n  rpcUrl: urlClean(`${vars.baseRpcUrl}/goerli`),\n  relayer: {\n    url: urlClean(`${vars.baseRelayerUrl}/goerli`)\n  },\n  isAuthChain: true\n})], undefined, {\n  baseRpcUrl: 'https://nodes.sequence.app',\n  baseRelayerUrl: 'https://relayers.sequence.app'\n});\n\n// WalletContext is the module addresses deployed on a network, aka the context / environment\n// of the Sequence Smart Wallet system on Ethereum.\n// sequenceContext are the deployed addresses of modules available on public networks.\nconst sequenceContext = {\n  factory: '0xf9D09D634Fb818b05149329C1dcCFAeA53639d96',\n  mainModule: '0xd01F11855bCcb95f88D7A48492F66410d4637313',\n  mainModuleUpgradable: '0x7EFE6cE415956c5f80C6530cC6cc81b4808F6118',\n  guestModule: '0x02390F3E6E5FD1C6786CB78FD3027C117a9955A7',\n  sequenceUtils: '0xd130B43062D875a4B7aF3f8fc036Bc6e9D3E1B3E',\n  libs: {\n    requireFreshSigner: '0xE6B9B21C077F382333220a072e4c44280b873907'\n  }\n};\n\nconst JsonRpcVersion = '2.0';\n\nclass JsonRpcRouter {\n  constructor(middlewares, sender) {\n    this.sender = void 0;\n    this.handler = void 0;\n    this.sender = sender;\n\n    if (middlewares) {\n      this.setMiddleware(middlewares);\n    }\n  }\n\n  setMiddleware(middlewares) {\n    this.handler = createJsonRpcMiddlewareStack(middlewares, this.sender.sendAsync);\n  }\n\n  sendAsync(request, callback, chainId) {\n    try {\n      this.handler(request, callback, chainId);\n    } catch (err) {\n      callback(err, undefined);\n    }\n  } // createWeb3Provider(network?: Networkish): EthersWeb3Provider {\n  //   return new EthersWeb3Provider(this.sender, network)\n  // }\n\n\n}\nconst createJsonRpcMiddlewareStack = (middlewares, handler) => {\n  if (middlewares.length === 0) return handler;\n\n  const toMiddleware = v => {\n    if (v.sendAsyncMiddleware) {\n      return v.sendAsyncMiddleware;\n    } else {\n      return v;\n    }\n  };\n\n  let chain;\n  chain = toMiddleware(middlewares[middlewares.length - 1])(handler);\n\n  for (let i = middlewares.length - 2; i >= 0; i--) {\n    chain = toMiddleware(middlewares[i])(chain);\n  }\n\n  return chain;\n};\n\nfunction isJsonRpcProvider(cand) {\n  return cand !== undefined && cand.send !== undefined && cand.constructor.defaultUrl !== undefined && cand.detectNetwork !== undefined && cand.getSigner !== undefined && cand.perform !== undefined;\n}\nfunction isJsonRpcHandler(cand) {\n  return cand !== undefined && cand.sendAsync !== undefined;\n}\n\nlet _nextId = 0;\nclass JsonRpcSender {\n  constructor(provider, defaultChainId) {\n    this.send = void 0;\n    this.request = void 0;\n    this.defaultChainId = void 0;\n\n    this.sendAsync = (request, callback, chainId) => {\n      this.send(request.method, request.params, chainId || this.defaultChainId).then(r => {\n        callback(undefined, {\n          jsonrpc: '2.0',\n          id: request.id,\n          result: r\n        });\n      }).catch(e => {\n        callback(e, undefined);\n      });\n    };\n\n    this.defaultChainId = defaultChainId;\n\n    if (isJsonRpcProvider(provider)) {\n      // we can ignore defaultChainId for JsonRpcProviders as they are already chain-bound\n      this.send = provider.send.bind(provider);\n    } else if (isJsonRpcHandler(provider)) {\n      this.send = (method, params, chainId) => {\n        return new Promise((resolve, reject) => {\n          provider.sendAsync({\n            // TODO: really shouldn't have to set these here?\n            jsonrpc: JsonRpcVersion,\n            id: ++_nextId,\n            method,\n            params\n          }, (error, response) => {\n            if (error) {\n              reject(error);\n            } else if (response) {\n              resolve(response.result);\n            } else {\n              resolve(undefined);\n            }\n          }, chainId || this.defaultChainId);\n        });\n      };\n    } else {\n      this.send = provider;\n    }\n\n    this.request = (request, chainId) => {\n      return this.send(request.method, request.params, chainId);\n    };\n  }\n\n}\nclass JsonRpcExternalProvider {\n  constructor(provider) {\n    this.provider = provider;\n\n    this.sendAsync = (request, callback) => {\n      this.provider.send(request.method, request.params).then(r => {\n        callback(undefined, {\n          jsonrpc: '2.0',\n          id: request.id,\n          result: r\n        });\n      }).catch(e => {\n        callback(e, undefined);\n      });\n    };\n\n    this.send = this.sendAsync;\n  }\n\n}\n\nclass AllowProvider {\n  constructor(isAllowedFunc) {\n    this.sendAsyncMiddleware = void 0;\n    this.isAllowedFunc = void 0;\n\n    if (isAllowedFunc) {\n      this.isAllowedFunc = isAllowedFunc;\n    } else {\n      this.isAllowedFunc = request => true;\n    }\n\n    this.sendAsyncMiddleware = allowProviderMiddleware(this.isAllowedFunc);\n  }\n\n  setIsAllowedFunc(fn) {\n    this.isAllowedFunc = fn;\n    this.sendAsyncMiddleware = allowProviderMiddleware(this.isAllowedFunc);\n  }\n\n}\nconst allowProviderMiddleware = isAllowed => next => {\n  return (request, callback, chainId) => {\n    // ensure precondition is met or do not allow the request to continue\n    if (!isAllowed(request)) {\n      throw new Error('allowProvider middleware precondition is unmet.');\n    } // request is allowed. keep going..\n\n\n    next(request, callback, chainId);\n  };\n};\n\nclass CachedProvider {\n  constructor(defaultChainId) {\n    this.cachableJsonRpcMethods = ['net_version', 'eth_chainId', 'eth_accounts', 'sequence_getWalletContext', 'sequence_getNetworks'];\n    this.cache = void 0;\n    this.onUpdateCallback = void 0;\n    this.defaultChainId = void 0;\n\n    this.sendAsyncMiddleware = next => {\n      return (request, callback, chainId) => {\n        // Respond early with cached result\n        if (this.cachableJsonRpcMethods.includes(request.method)) {\n          const key = this.cacheKey(request.method, request.params, chainId || this.defaultChainId);\n          const result = this.getCacheValue(key);\n\n          if (result && result !== '') {\n            callback(undefined, {\n              jsonrpc: '2.0',\n              id: request.id,\n              result: result\n            });\n            return;\n          }\n        } // Continue down the handler chain\n\n\n        next(request, (error, response, chainId) => {\n          // Store result in cache and continue\n          if (this.cachableJsonRpcMethods.includes(request.method)) {\n            if (response && response.result) {\n              const key = this.cacheKey(request.method, request.params, chainId || this.defaultChainId);\n              this.setCacheValue(key, response.result);\n            }\n          } // Exec next handler\n\n\n          callback(error, response);\n        }, chainId || this.defaultChainId);\n      };\n    };\n\n    this.cacheKey = (method, params, chainId) => {\n      let key = '';\n\n      if (chainId) {\n        key = `${chainId}:${method}:`;\n      } else {\n        key = `:${method}:`;\n      }\n\n      if (!params || params.length === 0) {\n        return key + '[]';\n      }\n\n      return key + JSON.stringify(params);\n    };\n\n    this.getCache = () => this.cache;\n\n    this.setCache = cache => {\n      this.cache = cache;\n\n      if (this.onUpdateCallback) {\n        this.onUpdateCallback();\n      }\n    };\n\n    this.getCacheValue = key => {\n      return this.cache[key];\n    };\n\n    this.setCacheValue = (key, value) => {\n      this.cache[key] = value;\n\n      if (this.onUpdateCallback) {\n        this.onUpdateCallback(key, value);\n      }\n    };\n\n    this.clearCache = () => {\n      this.cache = {};\n    };\n\n    this.cache = {};\n    this.defaultChainId = defaultChainId;\n  }\n\n  onUpdate(callback) {\n    this.onUpdateCallback = callback;\n  }\n\n}\n\nclass EagerProvider {\n  constructor(props) {\n    this.props = void 0;\n\n    this.sendAsyncMiddleware = next => {\n      return (request, callback, chainId) => {\n        const {\n          id,\n          method\n        } = request;\n\n        switch (method) {\n          case 'net_version':\n            if (this.props.chainId) {\n              callback(undefined, {\n                jsonrpc: '2.0',\n                id: id,\n                result: `${this.props.chainId}`\n              });\n              return;\n            }\n\n            break;\n\n          case 'eth_chainId':\n            if (this.props.chainId) {\n              callback(undefined, {\n                jsonrpc: '2.0',\n                id: id,\n                result: ethers.utils.hexlify(this.props.chainId)\n              });\n              return;\n            }\n\n            break;\n\n          case 'eth_accounts':\n            if (this.props.accountAddress) {\n              callback(undefined, {\n                jsonrpc: '2.0',\n                id: id,\n                result: [ethers.utils.getAddress(this.props.accountAddress)]\n              });\n              return;\n            }\n\n            break;\n\n          case 'sequence_getWalletContext':\n            if (this.props.walletContext) {\n              callback(undefined, {\n                jsonrpc: '2.0',\n                id: id,\n                result: this.props.walletContext\n              });\n              return;\n            }\n\n            break;\n        }\n\n        next(request, callback, chainId);\n      };\n    };\n\n    this.props = props;\n  }\n\n}\n\nconst exceptionProviderMiddleware = next => {\n  return (request, callback, chainId) => {\n    next(request, (error, response) => {\n      if (!error && response && response.error) {\n        if (typeof response.error === 'string') {\n          throw new Error(response.error);\n        } else {\n          throw new Error(response.error.message);\n        }\n      }\n\n      callback(error, response);\n    }, chainId);\n  };\n};\n\nconst loggingProviderMiddleware = next => {\n  return (request, callback, chainId) => {\n    const chainIdLabel = chainId ? ` chainId:${chainId}` : '';\n    logger.info(`[provider request]${chainIdLabel} id:${request.id} method:${request.method} params:`, request.params);\n    next(request, (error, response) => {\n      if (error) {\n        logger.warn(`[provider response]${chainIdLabel} id:${request.id} method:${request.method} params:`, request.params, `error:`, error);\n      } else {\n        logger.info(`[provider response]${chainIdLabel} id:${request.id} method:${request.method} params:`, request.params, `response:`, response);\n      }\n\n      callback(error, response);\n    }, chainId);\n  };\n};\n\nconst networkProviderMiddleware = getChainId => next => {\n  return (request, callback, chainId) => {\n    const networkChainId = getChainId(request);\n    const {\n      id,\n      method\n    } = request;\n\n    switch (method) {\n      case 'net_version':\n        callback(undefined, {\n          jsonrpc: '2.0',\n          id: id,\n          result: `${networkChainId}`\n        });\n        return;\n\n      case 'eth_chainId':\n        callback(undefined, {\n          jsonrpc: '2.0',\n          id: id,\n          result: ethers.utils.hexlify(networkChainId)\n        });\n        return;\n    } // request is allowed. keep going..\n\n\n    next(request, callback, chainId);\n  };\n};\n\nconst SignerJsonRpcMethods = ['personal_sign', 'eth_sign', 'eth_signTypedData', 'eth_signTypedData_v4', 'eth_sendTransaction', 'eth_sendRawTransaction', 'sequence_getWalletContext', 'sequence_getWalletConfig', 'sequence_getWalletState', 'sequence_getNetworks', 'sequence_updateConfig', 'sequence_publishConfig', 'sequence_estimateGasLimits', 'sequence_gasRefundOptions', 'sequence_getNonce', 'sequence_relay', 'eth_decrypt', 'eth_getEncryptionPublicKey', 'wallet_addEthereumChain', 'wallet_switchEthereumChain', 'wallet_registerOnboarding', 'wallet_watchAsset', 'wallet_scanQRCode'];\nclass SigningProvider {\n  constructor(provider) {\n    this.provider = void 0;\n\n    this.sendAsyncMiddleware = next => {\n      return (request, callback, chainId) => {\n        // Forward signing requests to the signing provider\n        if (SignerJsonRpcMethods.includes(request.method)) {\n          this.provider.sendAsync(request, callback, chainId);\n          return;\n        } // Continue to next handler\n\n\n        next(request, callback, chainId);\n      };\n    };\n\n    this.provider = provider;\n  }\n\n}\n\nclass PublicProvider {\n  constructor(rpcUrl) {\n    this.privateJsonRpcMethods = ['net_version', 'eth_chainId', 'eth_accounts', ...SignerJsonRpcMethods];\n    this.provider = void 0;\n    this.rpcUrl = void 0;\n\n    this.sendAsyncMiddleware = next => {\n      return (request, callback) => {\n        // When provider is configured, send non-private methods to our local public provider\n        if (this.provider && !this.privateJsonRpcMethods.includes(request.method)) {\n          this.provider.send(request.method, request.params).then(r => {\n            callback(undefined, {\n              jsonrpc: '2.0',\n              id: request.id,\n              result: r\n            });\n          }).catch(e => callback(e));\n          return;\n        } // Continue to next handler\n\n\n        logger.debug('[public-provider] sending request to signer window', request.method);\n        next(request, callback);\n      };\n    };\n\n    if (rpcUrl) {\n      this.setRpcUrl(rpcUrl);\n    }\n  }\n\n  getRpcUrl() {\n    return this.rpcUrl;\n  }\n\n  setRpcUrl(rpcUrl) {\n    if (!rpcUrl || rpcUrl === '') {\n      this.rpcUrl = undefined;\n      this.provider = undefined;\n    } else {\n      this.rpcUrl = rpcUrl;\n      this.provider = new JsonRpcProvider(rpcUrl);\n    }\n  }\n\n}\n\nexport { AllowProvider, CachedProvider, ChainId, EagerProvider, JsonRpcExternalProvider, JsonRpcRouter, JsonRpcSender, JsonRpcVersion, PublicProvider, SigningProvider, allowProviderMiddleware, checkNetworkConfig, createJsonRpcMiddlewareStack, createNetworkConfig, ensureUniqueNetworks, ensureValidNetworks, exceptionProviderMiddleware, findNetworkConfig, getAuthNetwork, getChainId, isJsonRpcHandler, isJsonRpcProvider, isNetworkConfig, isValidNetworkConfig, loggingProviderMiddleware, mainnetNetworks, maybeChainId, networkProviderMiddleware, networks, networksIndex, sequenceContext, sortNetworks, testnetNetworks, updateNetworkConfig };\n","import { BigNumber, ethers } from 'ethers';\nimport { walletContracts } from '@0xsequence/abi';\nimport { getRandomInt, promisify } from '@0xsequence/utils';\nimport { sequenceContext, JsonRpcVersion } from '@0xsequence/network';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nlet JsonRpcMethod;\n\n(function (JsonRpcMethod) {\n  JsonRpcMethod[\"ethCall\"] = \"eth_call\";\n  JsonRpcMethod[\"ethGetBalance\"] = \"eth_getBalance\";\n  JsonRpcMethod[\"ethGetCode\"] = \"eth_getCode\";\n})(JsonRpcMethod || (JsonRpcMethod = {}));\n\nasync function safeSolve(promise, def) {\n  try {\n    return await promise;\n  } catch (e) {\n    const d = def instanceof Function ? def(e) : def;\n    return d;\n  }\n}\nfunction partition(array, callback) {\n  return array.reduce(function (result, element, i) {\n    callback(element, i) ? result[0].push(element) : result[1].push(element);\n    return result;\n  }, [[], []]);\n}\nfunction parseBlockTag(cand) {\n  if (cand === undefined) return 'latest';\n\n  switch (cand) {\n    case 'earliest':\n    case 'latest':\n    case 'pending':\n      return cand;\n  }\n\n  return BigNumber.from(cand);\n}\nfunction eqBlockTag(a, b) {\n  if (a === b) return true;\n\n  if (BigNumber.isBigNumber(a)) {\n    if (BigNumber.isBigNumber(b)) return a.eq(b);\n    return false;\n  }\n\n  if (BigNumber.isBigNumber(b)) return false;\n  return a === b;\n}\n\nconst DefaultMulticallOptions = {\n  batchSize: 50,\n  timeWindow: 50,\n  contract: sequenceContext.sequenceUtils,\n  verbose: false\n};\nclass Multicall {\n  constructor(options) {\n    var _this = this;\n\n    this.batchableJsonRpcMethods = [JsonRpcMethod.ethCall, JsonRpcMethod.ethGetCode, JsonRpcMethod.ethGetBalance];\n    this.multicallInterface = new ethers.utils.Interface(walletContracts.sequenceUtils.abi);\n    this.options = void 0;\n    this.timeout = void 0;\n    this.queue = [];\n\n    this.scheduleExecution = () => {\n      if (this.queue.length > 0) {\n        if (this.timeout) clearTimeout(this.timeout);\n        this.timeout = setTimeout(this.run, this.options.timeWindow);\n      }\n    };\n\n    this.handle = (next, request, callback) => {\n      // Schedule for batching and return\n      if (this.batchableJsonRpcMethods.find(m => m === request.method)) {\n        this.queue.push({\n          request: request,\n          callback: callback,\n          next: next\n        });\n        if (this.options.verbose) console.log('Scheduling call', request.method);\n        this.scheduleExecution();\n        return;\n      }\n\n      if (this.options.verbose) console.log('Forwarded call', request.method); // Move to next handler\n\n      return next(request, callback);\n    };\n\n    this.run = async function () {\n      /* eslint-disable no-var */\n      if (_this.options.verbose) console.log('Processing multicall'); // Read items from queue\n\n      const limit = Math.min(_this.options.batchSize, _this.queue.length);\n      if (limit === 0) return; // Skip multicall on single item\n\n      if (limit === 1) {\n        _this.forward(_this.queue[0]);\n\n        _this.queue = [];\n        if (_this.options.verbose) console.log('Skip multicall, single item');\n        return;\n      }\n\n      if (_this.options.verbose) console.log('Resolving', limit); // Get batch from queue\n\n      var items = _this.queue.slice(0, limit); // Update queue\n\n\n      _this.queue = limit === _this.queue.length ? [] : _this.queue.slice(limit);\n      if (_this.options.verbose) console.log('Updated queue', _this.queue.length);\n\n      if (_this.queue.length !== 0) {\n        _this.scheduleExecution();\n      } // Get next candidate\n\n\n      const next = items[0].next;\n      let blockTag; // Partition incompatible calls\n\n      var [items, discartItems] = partition(items, item => {\n        try {\n          // Mixed next callbacks\n          if (item.next !== next) return false;\n\n          switch (item.request.method) {\n            case JsonRpcMethod.ethCall:\n              // Unsupported eth_call parameters\n              if (item.request.params[0].from || item.request.params[0].gasPrice || item.request.params[0].value) {\n                return false;\n              }\n\n            case JsonRpcMethod.ethGetBalance:\n            case JsonRpcMethod.ethGetCode:\n              // Mixed blockTags\n              const itemBlockTag = parseBlockTag(item.request.params[1]);\n              if (blockTag === undefined) blockTag = itemBlockTag;\n              if (!eqBlockTag(itemBlockTag, blockTag)) return false;\n          }\n\n          return true;\n        } catch (_unused) {\n          return false;\n        }\n      }); // Forward discarted items\n      // end execution if no items remain\n\n      if (discartItems.length !== 0) {\n        if (_this.options.verbose) console.log('Forwarding incompatible calls', discartItems.length);\n\n        _this.forward(discartItems);\n\n        if (items.length === 0) return;\n      } // Aggregate all calls\n\n\n      let callParams = items.map(v => {\n        try {\n          switch (v.request.method) {\n            case JsonRpcMethod.ethCall:\n              return {\n                delegateCall: false,\n                revertOnError: false,\n                target: v.request.params[0].to,\n                data: v.request.params[0].data,\n                gasLimit: v.request.params[0].gas ? v.request.params[0].gas : 0,\n                value: 0\n              };\n\n            case JsonRpcMethod.ethGetCode:\n              return {\n                delegateCall: false,\n                revertOnError: false,\n                target: _this.options.contract,\n                gasLimit: 0,\n                value: 0,\n                data: _this.multicallInterface.encodeFunctionData(_this.multicallInterface.getFunction('callCode'), [v.request.params[0]])\n              };\n\n            case JsonRpcMethod.ethGetBalance:\n              return {\n                delegateCall: false,\n                revertOnError: false,\n                target: _this.options.contract,\n                gasLimit: 0,\n                value: 0,\n                data: _this.multicallInterface.encodeFunctionData(_this.multicallInterface.getFunction('callBalanceOf'), [v.request.params[0]])\n              };\n\n            default:\n              return null;\n          }\n        } catch (_unused2) {\n          return null;\n        }\n      }); // Filter calls with enconding errors and forward items\n\n      var [items, discartItems] = partition(items, (_, i) => callParams[i] !== undefined);\n      callParams = callParams.filter(c => c);\n\n      if (discartItems.length !== 0) {\n        if (_this.options.verbose) console.log('Forwarding calls on error', discartItems.length);\n\n        _this.forward(discartItems);\n\n        if (items.length === 0) return;\n      } // Encode multicall\n\n\n      let encodedCall;\n\n      try {\n        encodedCall = _this.multicallInterface.encodeFunctionData(_this.multicallInterface.getFunction('multiCall'), [callParams]);\n      } catch (_unused3) {\n        _this.forward(items);\n\n        return;\n      } // Forward single multicall rpc call\n\n\n      const reqId = getRandomInt(); // TODO: fix types below..\n\n      const res = await safeSolve( // @ts-ignore\n      promisify(next)({\n        id: reqId,\n        jsonrpc: JsonRpcVersion,\n        method: JsonRpcMethod.ethCall,\n        params: [{\n          to: _this.options.contract,\n          value: 0,\n          data: encodedCall\n        }, BigNumber.isBigNumber(blockTag) ? blockTag.toNumber() : blockTag] // @ts-ignore\n\n      }), e => ({\n        jsonrpc: JsonRpcVersion,\n        id: reqId,\n        result: undefined,\n        error: e\n      })); // Error calling multicall\n      // Forward all calls to middleware\n      // @ts-ignore\n\n      if (res.error) {\n        return _this.forward(items);\n      } // Decode result from multicall\n\n\n      let decoded;\n\n      try {\n        // @ts-ignore\n        decoded = _this.multicallInterface.decodeFunctionResult(_this.multicallInterface.getFunction('multiCall'), res.result);\n      } catch (_unused4) {\n        _this.forward(items);\n\n        return;\n      } // Send results for each request\n      // errors fallback through the middleware\n\n\n      if (_this.options.verbose) console.log('Got response for', items.length);\n      items.forEach((item, index) => {\n        if (!decoded[0][index]) {\n          _this.forward(item);\n        } else {\n          switch (item.request.method) {\n            case JsonRpcMethod.ethCall:\n              item.callback(undefined, {\n                jsonrpc: item.request.jsonrpc,\n                id: item.request.id,\n                result: decoded[1][index]\n              });\n              break;\n\n            case JsonRpcMethod.ethGetCode:\n              item.callback(undefined, {\n                jsonrpc: item.request.jsonrpc,\n                id: item.request.id,\n                result: ethers.utils.defaultAbiCoder.decode(['bytes'], decoded[1][index])[0]\n              });\n              break;\n\n            case JsonRpcMethod.ethGetBalance:\n              item.callback(undefined, {\n                jsonrpc: item.request.jsonrpc,\n                id: item.request.id,\n                result: ethers.utils.defaultAbiCoder.decode(['uint256'], decoded[1][index])[0]\n              });\n              break;\n          }\n        }\n      });\n    };\n\n    this.options = options ? _extends({}, Multicall.DefaultOptions, options) : Multicall.DefaultOptions;\n    if (this.options.batchSize <= 0) throw new Error(`Invalid batch size of ${this.options.batchSize}`);\n  }\n\n  forward(entries) {\n    if (Array.isArray(entries)) {\n      entries.forEach(e => e.next(e.request, e.callback));\n    } else {\n      entries.next(entries.request, entries.callback);\n    }\n  }\n\n  static isMulticall(cand) {\n    return cand && cand.handle !== undefined && cand.conf !== undefined && Multicall.isMulticallOptions(cand.options);\n  }\n\n  static isMulticallOptions(cand) {\n    return cand !== undefined && cand.batchSize !== undefined && cand.timeWindow !== undefined && cand.contract !== undefined;\n  }\n\n}\nMulticall.DefaultOptions = _extends({}, DefaultMulticallOptions);\n\nconst ProxyMethods = ['getNetwork', 'getBlockNumber', 'getGasPrice', 'getTransactionCount', 'getStorageAt', 'sendTransaction', 'estimateGas', 'getBlock', 'getTransaction', 'getTransactionReceipt', 'getLogs', 'emit', 'litenerCount', 'addListener', 'removeListener', 'waitForTransaction', 'detectNetwork', 'getBlockWithTransactions'];\nclass MulticallProvider extends ethers.providers.BaseProvider {\n  constructor(provider, multicall) {\n    var _this;\n\n    super(provider.getNetwork());\n    _this = this;\n    this.provider = provider;\n    this.multicall = void 0;\n    this.listenerCount = this.provider.listenerCount;\n\n    this.getResolver = async function (name) {\n      const provider = _this.provider;\n\n      if (provider.getResolver) {\n        const ogResolver = await provider.getResolver(await name);\n        if (!ogResolver) return null;\n        return new ethers.providers.Resolver(_this, ogResolver.address, ogResolver.name);\n      }\n\n      return provider.getResolver(await name);\n    };\n\n    this.next = async function (req, callback) {\n      try {\n        switch (req.method) {\n          case JsonRpcMethod.ethCall:\n            _this.callback(req, callback, await _this.provider.call(req.params[0], req.params[1]));\n\n            break;\n\n          case JsonRpcMethod.ethGetCode:\n            _this.callback(req, callback, await _this.provider.getCode(req.params[0], req.params[1]));\n\n            break;\n\n          case JsonRpcMethod.ethGetBalance:\n            _this.callback(req, callback, await _this.provider.getBalance(req.params[0], req.params[1]));\n\n            break;\n        }\n      } catch (e) {\n        _this.callback(req, callback, undefined, e);\n      }\n    };\n\n    this.multicall = Multicall.isMulticall(multicall) ? multicall : new Multicall(multicall);\n    ProxyMethods.forEach(m => {\n      if (provider[m] !== undefined) {\n\n        this[m] = (...args) => provider[m](...args);\n      }\n    });\n  }\n\n  callback(req, callback, resp, err) {\n    callback(err, {\n      jsonrpc: JsonRpcVersion,\n      id: req.id,\n      result: resp,\n      error: err\n    });\n  }\n\n  async call(transaction, blockTag) {\n    return this.rpcCall(JsonRpcMethod.ethCall, transaction, blockTag);\n  }\n\n  async getCode(addressOrName, blockTag) {\n    return this.rpcCall(JsonRpcMethod.ethGetCode, addressOrName, blockTag);\n  }\n\n  async getBalance(addressOrName, blockTag) {\n    return this.rpcCall(JsonRpcMethod.ethGetBalance, addressOrName, blockTag);\n  }\n\n  async rpcCall(method, ...params) {\n    const reqId = getRandomInt();\n    const resp = await promisify(this.multicall.handle)(this.next, {\n      jsonrpc: JsonRpcVersion,\n      id: reqId,\n      method: method,\n      params: params\n    });\n    return resp.result;\n  }\n\n}\n\nclass MulticallExternalProvider {\n  constructor(provider, multicall) {\n    this.provider = provider;\n    this.multicall = void 0;\n    this.multicall = Multicall.isMulticall(multicall) ? multicall : new Multicall(multicall);\n\n    if (provider.send) {\n      const next = async function next(req, callback) {\n        provider.send(req, callback);\n      };\n\n      this.send = (request, callback) => {\n        this.multicall.handle(next, request, callback);\n      };\n    }\n\n    if (provider.sendAsync) {\n      const next = async function next(req, callback) {\n        provider.sendAsync(req, callback);\n      };\n\n      this.sendAsync = (request, callback) => {\n        this.multicall.handle(next, request, callback);\n      };\n    }\n  }\n\n  get isMetaMask() {\n    return this.provider.isMetaMask;\n  }\n\n  get isStatus() {\n    return this.provider.isStatus;\n  }\n\n}\n\nconst multicallMiddleware = multicall => next => {\n  const lib = Multicall.isMulticall(multicall) ? multicall : new Multicall(multicall);\n  return (request, callback) => {\n    return lib.handle(next, request, callback);\n  };\n};\n\nvar index = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  ProxyMethods: ProxyMethods,\n  MulticallProvider: MulticallProvider,\n  MulticallExternalProvider: MulticallExternalProvider,\n  multicallMiddleware: multicallMiddleware\n});\n\nexport { Multicall, index as providers };\n","import { Signer, ethers, Contract } from 'ethers';\nimport { walletContracts } from '@0xsequence/abi';\nimport { logger } from '@0xsequence/utils';\nimport * as multicall from '@0xsequence/multicall';\n\n/* tslint:disable */\n\n/**\n    Minimal upgradeable proxy implementation, delegates all calls to the address\n    defined by the storage slot matching the wallet address.\n\n    Inspired by EIP-1167 Implementation (https://eips.ethereum.org/EIPS/eip-1167)\n\n    deployed code:\n\n        0x00    0x36         0x36      CALLDATASIZE      cds\n        0x01    0x3d         0x3d      RETURNDATASIZE    0 cds\n        0x02    0x3d         0x3d      RETURNDATASIZE    0 0 cds\n        0x03    0x37         0x37      CALLDATACOPY\n        0x04    0x3d         0x3d      RETURNDATASIZE    0\n        0x05    0x3d         0x3d      RETURNDATASIZE    0 0\n        0x06    0x3d         0x3d      RETURNDATASIZE    0 0 0\n        0x07    0x36         0x36      CALLDATASIZE      cds 0 0 0\n        0x08    0x3d         0x3d      RETURNDATASIZE    0 cds 0 0 0\n        0x09    0x30         0x30      ADDRESS           addr 0 cds 0 0 0\n        0x0A    0x54         0x54      SLOAD             imp 0 cds 0 0 0\n        0x0B    0x5a         0x5a      GAS               gas imp 0 cds 0 0 0\n        0x0C    0xf4         0xf4      DELEGATECALL      suc 0\n        0x0D    0x3d         0x3d      RETURNDATASIZE    rds suc 0\n        0x0E    0x82         0x82      DUP3              0 rds suc 0\n        0x0F    0x80         0x80      DUP1              0 0 rds suc 0\n        0x10    0x3e         0x3e      RETURNDATACOPY    suc 0\n        0x11    0x90         0x90      SWAP1             0 suc\n        0x12    0x3d         0x3d      RETURNDATASIZE    rds 0 suc\n        0x13    0x91         0x91      SWAP2             suc 0 rds\n        0x14    0x60 0x18    0x6018    PUSH1             0x18 suc 0 rds\n    /-- 0x16    0x57         0x57      JUMPI             0 rds\n    |   0x17    0xfd         0xfd      REVERT\n    \\-> 0x18    0x5b         0x5b      JUMPDEST          0 rds\n        0x19    0xf3         0xf3      RETURN\n\n    flat deployed code: 0x363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3\n\n    deploy function:\n\n        0x00    0x60 0x3a    0x603a    PUSH1             0x3a\n        0x02    0x60 0x0e    0x600e    PUSH1             0x0e 0x3a\n        0x04    0x3d         0x3d      RETURNDATASIZE    0 0x0e 0x3a\n        0x05    0x39         0x39      CODECOPY\n        0x06    0x60 0x1a    0x601a    PUSH1             0x1a\n        0x08    0x80         0x80      DUP1              0x1a 0x1a\n        0x09    0x51         0x51      MLOAD             imp 0x1a\n        0x0A    0x30         0x30      ADDRESS           addr imp 0x1a\n        0x0B    0x55         0x55      SSTORE            0x1a\n        0x0C    0x3d         0x3d      RETURNDATASIZE    0 0x1a\n        0x0D    0xf3         0xf3      RETURN\n        [...deployed code]\n\n    flat deploy function: 0x603a600e3d39601a805130553df3363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3\n*/\nconst WalletContractBytecode = '0x603a600e3d39601a805130553df3363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3';\n\nconst maxCachedConfigs = 10;\nconst listKey = '@sequence.config.imageHashes';\n\nconst configKey = imageHash => `@sequence.config.${imageHash}`;\n\nlet storage;\n\ntry {\n  storage = localStorage;\n} catch (_unused) {\n  const map = new Map();\n  storage = {\n    getItem: key => {\n      var _map$get;\n\n      return (_map$get = map.get(key)) != null ? _map$get : null;\n    },\n    setItem: (key, value) => map.set(key, value),\n    removeItem: key => map.delete(key)\n  };\n}\n\nfunction getCachedConfig(imageHash) {\n  var _storage$getItem;\n\n  const config = JSON.parse((_storage$getItem = storage.getItem(configKey(imageHash))) != null ? _storage$getItem : 'null');\n\n  if (config) {\n    pushImageHash(imageHash);\n    return config;\n  } else {\n    return;\n  }\n}\nfunction cacheConfig(imageHash, config) {\n  storage.setItem(configKey(imageHash), JSON.stringify(config));\n  pushImageHash(imageHash);\n}\n\nfunction pushImageHash(imageHash) {\n  var _storage$getItem2;\n\n  let imageHashes = JSON.parse((_storage$getItem2 = storage.getItem(listKey)) != null ? _storage$getItem2 : '[]');\n  imageHashes = imageHashes.filter(hash => hash !== imageHash);\n  imageHashes.push(imageHash);\n\n  while (imageHashes.length > maxCachedConfigs) {\n    storage.removeItem(configKey(imageHashes.shift()));\n  }\n\n  storage.setItem(listKey, JSON.stringify(imageHashes));\n}\n\n// and control the wallet\n\n// TODO: createWalletConfig and genConfig are very similar, lets update + remove one\nconst createWalletConfig = async (threshold, signers) => {\n  const config = {\n    threshold,\n    signers: []\n  };\n  signers.forEach(async s => {\n    config.signers.push({\n      weight: s.weight,\n      address: Signer.isSigner(s.signer) ? await s.signer.getAddress() : s.signer\n    });\n  });\n\n  if (!isUsableConfig(config)) {\n    throw new Error('wallet config is not usable');\n  }\n\n  return config;\n}; // isUsableConfig checks if a the sum of the owners in the configuration meets the necessary threshold to sign a transaction\n// a wallet that has a non-usable configuration is not able to perform any transactions, and can be considered as destroyed\n\nconst isUsableConfig = config => {\n  const sum = config.signers.reduce((p, c) => ethers.BigNumber.from(c.weight).add(p), ethers.constants.Zero);\n  return sum.gte(ethers.BigNumber.from(config.threshold));\n};\nconst isValidConfigSigners = (config, signers) => {\n  if (signers.length === 0) return true;\n  const a = config.signers.map(s => ethers.utils.getAddress(s.address));\n  const b = signers.map(s => ethers.utils.getAddress(s));\n  let valid = true;\n  b.forEach(s => {\n    if (!a.includes(s)) valid = false;\n  });\n  return valid;\n};\nconst addressOf = (salt, context, ignoreAddress = false) => {\n  if (typeof salt === 'string') {\n    const codeHash = ethers.utils.keccak256(ethers.utils.solidityPack(['bytes', 'bytes32'], [WalletContractBytecode, ethers.utils.hexZeroPad(context.mainModule, 32)]));\n    const hash = ethers.utils.keccak256(ethers.utils.solidityPack(['bytes1', 'address', 'bytes32', 'bytes32'], ['0xff', context.factory, salt, codeHash]));\n    return ethers.utils.getAddress(ethers.utils.hexDataSlice(hash, 12));\n  }\n\n  if (salt.address && !ignoreAddress) return salt.address;\n  return addressOf(imageHash(salt), context);\n};\nconst imageHash = config => {\n  config = sortConfig(config);\n  const imageHash = config.signers.reduce((imageHash, signer) => ethers.utils.keccak256(ethers.utils.defaultAbiCoder.encode(['bytes32', 'uint8', 'address'], [imageHash, signer.weight, signer.address])), ethers.utils.solidityPack(['uint256'], [config.threshold]));\n  cacheConfig(imageHash, config);\n  return imageHash;\n}; // sortConfig normalizes the list of signer addreses in a WalletConfig\n\nconst sortConfig = config => {\n  config.signers.sort((a, b) => compareAddr(a.address, b.address)); // normalize\n\n  config.signers.forEach(s => s.address = ethers.utils.getAddress(s.address));\n  if (config.address) config.address = ethers.utils.getAddress(config.address); // ensure no duplicate signers in the config\n\n  const signers = config.signers.map(s => s.address);\n  const signerDupes = signers.filter((c, i) => signers.indexOf(c) !== i);\n\n  if (signerDupes.length > 0) {\n    throw new Error('invalid wallet config: duplicate signer addresses detected in the config, ${signerDupes}');\n  }\n\n  return config;\n};\nconst isConfigEqual = (a, b) => {\n  return imageHash(a) === imageHash(b);\n};\nconst compareAddr = (a, b) => {\n  const bigA = ethers.BigNumber.from(a);\n  const bigB = ethers.BigNumber.from(b);\n\n  if (bigA.lt(bigB)) {\n    return -1;\n  } else if (bigA.eq(bigB)) {\n    return 0;\n  } else {\n    return 1;\n  }\n};\nfunction editConfig(config, args) {\n  const normSigner = s => ({\n    weight: ethers.BigNumber.from(s.weight).toNumber(),\n    address: ethers.utils.getAddress(s.address)\n  });\n\n  const normSrcSigners = config.signers.map(normSigner);\n  const normSetSigners = args.set ? args.set.map(normSigner) : [];\n  const normDelAddress = args.del ? args.del.map(a => ethers.utils.getAddress(a.address)) : [];\n  const normSetAddress = normSetSigners.map(s => s.address);\n  const newSigners = normSrcSigners.filter(s => normDelAddress.indexOf(s.address) === -1 && normSetAddress.indexOf(s.address) === -1).concat(...normSetSigners);\n  return sortConfig({\n    address: config.address,\n    threshold: args.threshold ? ethers.BigNumber.from(args.threshold).toNumber() : config.threshold,\n    signers: newSigners\n  });\n} // TODO: very similar to createWalletConfig, but doesn't allow an AbstractSigner object\n// TODO: lets also check isUsableConfig before returning it\n\nfunction genConfig(threshold, signers) {\n  return sortConfig({\n    threshold: ethers.BigNumber.from(threshold).toNumber(),\n    signers: signers.map(s => ({\n      weight: ethers.BigNumber.from(s.weight).toNumber(),\n      address: ethers.utils.getAddress(s.address)\n    }))\n  });\n}\n\nclass ConfigFinder {\n  constructor() {\n    this.findCurrentConfig = void 0;\n    this.findLastWalletOfInitialSigner = void 0;\n  }\n\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nclass SequenceUtilsFinder {\n  constructor(authProvider) {\n    var _this = this;\n\n    this.authProvider = authProvider;\n\n    this.findCurrentConfig = async function (args) {\n      const {\n        provider,\n        context,\n        ignoreIndex,\n        requireIndex,\n        skipCache\n      } = args;\n      const address = ethers.utils.getAddress(args.address);\n      logger.info(`[findCurrentConfig] address:${address}, ignoreIndex:${ignoreIndex}, requireIndex:${requireIndex}`);\n      if (requireIndex && ignoreIndex) throw Error(`findCurrentConfig: can't ignore index and require index`);\n      const chainIdPromise = provider.getNetwork();\n      const knownConfigs = args.knownConfigs ? args.knownConfigs : []; // Get imageHash of wallet\n\n      const {\n        imageHash,\n        config\n      } = await _this.findCurrentImageHash(context, provider, address, knownConfigs, skipCache);\n      if (imageHash === undefined) return {\n        config: undefined\n      }; // Get config for that imageHash\n\n      const found = await _this.findConfigForImageHash(context, imageHash, config ? [config, ...knownConfigs] : knownConfigs, skipCache);\n      const chainId = (await chainIdPromise).chainId;\n      return {\n        config: found ? _extends({}, found, {\n          chainId,\n          address\n        }) : undefined\n      };\n    };\n\n    this.findLastWalletOfInitialSigner = async function (args) {\n      const {\n        signer,\n        context,\n        ignoreIndex,\n        requireIndex\n      } = args;\n      logger.info(`[findLastWalletOfInitialSigner] signer:${signer}`);\n      if (requireIndex && ignoreIndex) throw Error(`findCurrentConfig: can't ignore index and require index`);\n      const authContract = new Contract(context.sequenceUtils, walletContracts.sequenceUtils.abi, _this.authProvider);\n      const logBlockHeight = ignoreIndex ? 0 : (await authContract.lastSignerUpdate(signer)).toNumber();\n      if (requireIndex && logBlockHeight === 0) return {\n        wallet: undefined\n      };\n      const filter = authContract.filters.RequiredSigner(null, signer);\n      const lastLog = await _this.findLatestLog(_this.authProvider, _extends({}, filter, {\n        fromBlock: logBlockHeight,\n        toBlock: logBlockHeight !== 0 ? logBlockHeight : 'latest'\n      }));\n\n      if (lastLog === undefined) {\n        logger.warn('publishConfig: wallet config last log not found');\n        return {\n          wallet: undefined\n        };\n      }\n\n      const event = authContract.interface.decodeEventLog('RequiredSigner', lastLog.data, lastLog.topics);\n      return {\n        wallet: event._wallet\n      };\n    };\n\n    this.findConfigForImageHash = async function (context, image, knownConfigs = [], skipCache = false) {\n      // Lookup config in known configurations\n      const found = knownConfigs.find(kc => imageHash(kc) === image);\n      if (found) return found; // Lookup config in cached configurations\n\n      if (!skipCache) {\n        const cached = getCachedConfig(image);\n\n        if (cached) {\n          return cached;\n        }\n      }\n\n      logger.info(`[findConfigForImageHash] image:${image}`); // Load index for last imageHash update\n\n      const authContract = new Contract(context.sequenceUtils, walletContracts.sequenceUtils.abi, _this.authProvider);\n      const imageHashHeight = (await authContract.lastImageHashUpdate(image)).toNumber(); // Get requireConfig with imageHash info\n\n      const filter = authContract.filters.RequiredConfig(undefined, image);\n      const lastLog = await _this.findLatestLog(_this.authProvider, _extends({}, filter, {\n        fromBlock: imageHashHeight,\n        toBlock: imageHashHeight !== 0 ? imageHashHeight : 'latest'\n      })); // If there is no log, and no knownConfig...\n      // the config is not found\n\n      if (lastLog === undefined) return undefined;\n      const event = authContract.interface.decodeEventLog('RequiredConfig', lastLog.data, lastLog.topics);\n      const signers = ethers.utils.defaultAbiCoder.decode([`tuple(\n        uint256 weight,\n        address signer\n      )[]`], event._signers)[0];\n      const config = {\n        threshold: ethers.BigNumber.from(event._threshold).toNumber(),\n        signers: signers.map(s => ({\n          address: s.signer,\n          weight: ethers.BigNumber.from(s.weight).toNumber()\n        }))\n      }; // Cache this config\n\n      imageHash(config);\n      return config;\n    };\n\n    this.findCurrentImageHash = async function (context, provider, address, knownConfigs = [], skipCache) {\n      logger.info(`[findCurrentImageHash] address:${address}`);\n      const walletContract = new Contract(address, walletContracts.mainModuleUpgradable.abi, provider);\n      const currentImageHash = await walletContract.functions.imageHash.call([]).catch(() => []); // Wallet is not counterfactual and has a defined imageHash\n\n      if (currentImageHash[0] !== undefined) {\n        return {\n          imageHash: currentImageHash[0],\n          config: skipCache ? undefined : getCachedConfig(currentImageHash[0])\n        };\n      } // Wallet is in counter-factual mode\n      // Lookup config in known configurations\n\n\n      const normalizedAddress = ethers.utils.getAddress(address);\n      const found = knownConfigs.find(kc => addressOf(kc, context, true) === normalizedAddress);\n      if (found) return {\n        imageHash: imageHash(found),\n        config: found\n      }; // Call wallet index\n\n      const authContract = new Contract(context.sequenceUtils, walletContracts.sequenceUtils.abi, _this.authProvider);\n      const knownImageHash = await authContract.knownImageHashes(address);\n\n      if (knownImageHash !== ethers.constants.HashZero) {\n        if (addressOf(knownImageHash, context) !== address) throw Error('findCurrentImageHash: inconsistent RequireUtils results');\n        return {\n          imageHash: knownImageHash\n        };\n      } // Get known image hash from raw logs, as last resort\n\n\n      const filter = authContract.filters.RequiredConfig(address);\n      const log = await _this.findFirstLog(_this.authProvider, filter);\n\n      if (log !== undefined) {\n        const event = authContract.interface.decodeEventLog('RequiredConfig', log.data, log.topics);\n        const signers = ethers.utils.defaultAbiCoder.decode([`tuple(\n          uint256 weight,\n          address signer\n        )[]`], event._signers)[0];\n        const config = {\n          threshold: ethers.BigNumber.from(event._threshold).toNumber(),\n          signers: signers.map(s => ({\n            address: s.signer,\n            weight: ethers.BigNumber.from(s.weight).toNumber()\n          }))\n        };\n        const gotImageHash = imageHash(config);\n\n        if (addressOf(gotImageHash, context) === address) {\n          return {\n            imageHash: gotImageHash,\n            config\n          };\n        }\n      } // Counter-factual imageHash not found\n\n\n      return {};\n    };\n\n    this.findLatestLog = async function (provider, filter) {\n      const toBlock = filter.toBlock === 'latest' ? await provider.getBlockNumber() : filter.toBlock;\n      const fromBlock = filter.fromBlock;\n\n      if (fromBlock === 0) {\n        logger.warn(`findLatestLog: expensive getLogs query fromBlock 0 toBlock ${toBlock}`);\n      }\n\n      try {\n        const logs = await provider.getLogs(_extends({}, filter, {\n          toBlock: toBlock\n        }));\n        return logs.length === 0 ? undefined : logs[logs.length - 1];\n      } catch (e) {\n        // TODO Don't assume all errors are bad\n        const pivot = Math.floor((toBlock - fromBlock) / 2 + fromBlock);\n        const nhalf = await _this.findLatestLog(provider, _extends({}, filter, {\n          fromBlock: pivot,\n          toBlock: toBlock\n        }));\n        if (nhalf !== undefined) return nhalf;\n        return _this.findLatestLog(provider, _extends({}, filter, {\n          fromBlock: fromBlock,\n          toBlock: pivot\n        }));\n      }\n    };\n\n    this.findFirstLog = async function (provider, filter) {\n      const toBlock = filter.toBlock === 'latest' || !filter.toBlock ? await provider.getBlockNumber() : filter.toBlock;\n      const fromBlock = filter.fromBlock ? filter.fromBlock : 0;\n\n      if (fromBlock === 0) {\n        logger.warn(`findFirstLog: expensive getLogs query fromBlock 0 toBlock ${toBlock}`);\n      }\n\n      try {\n        const logs = await provider.getLogs(_extends({}, filter, {\n          fromBlock,\n          toBlock\n        }));\n        return logs.length === 0 ? undefined : logs[0];\n      } catch (e) {\n        // TODO Don't assume all errors are bad\n        const pivot = Math.floor((toBlock - fromBlock) / 2 + fromBlock);\n        const nhalf = await _this.findFirstLog(provider, _extends({}, filter, {\n          fromBlock,\n          toBlock: pivot\n        }));\n        if (nhalf !== undefined) return nhalf;\n        return _this.findFirstLog(provider, _extends({}, filter, {\n          fromBlock: pivot,\n          toBlock\n        }));\n      }\n    };\n  }\n\n}\n\nfunction isDecodedAddress(cand) {\n  const c = cand;\n  return c.address !== undefined && !isDecodedSigner(cand);\n}\nfunction isDecodedSigner(cand) {\n  return isDecodedEOASigner(cand) || isDecodedEOASplitSigner(cand) || isDecodedFullSigner(cand);\n}\nfunction isDecodedEOASigner(cand) {\n  const c = cand;\n  return c.signature !== undefined && c.address === undefined;\n}\nfunction isDecodedEOASplitSigner(cand) {\n  const c = cand;\n  return c.r !== undefined && c.s !== undefined && c.v !== undefined && c.t !== undefined;\n}\nfunction isDecodedFullSigner(cand) {\n  const c = cand;\n  return c.address !== undefined && c.signature !== undefined;\n}\nlet SignatureType;\n\n(function (SignatureType) {\n  SignatureType[SignatureType[\"EOA\"] = 0] = \"EOA\";\n  SignatureType[SignatureType[\"Address\"] = 1] = \"Address\";\n  SignatureType[SignatureType[\"Full\"] = 2] = \"Full\";\n})(SignatureType || (SignatureType = {}));\n\nconst decodeSignature = signature => {\n  if (typeof signature !== 'string') return signature;\n  const auxsig = signature.replace('0x', '');\n  const threshold = ethers.BigNumber.from(`0x${auxsig.slice(0, 4)}`).toNumber();\n  const signers = [];\n\n  for (let rindex = 4; rindex < auxsig.length;) {\n    const signatureType = ethers.BigNumber.from(auxsig.slice(rindex, rindex + 2)).toNumber();\n    rindex += 2;\n    const weight = ethers.BigNumber.from(`0x${auxsig.slice(rindex, rindex + 2)}`).toNumber();\n    rindex += 2;\n\n    switch (signatureType) {\n      case SignatureType.Address:\n        const addr = ethers.utils.getAddress(auxsig.slice(rindex, rindex + 40));\n        rindex += 40;\n        signers.push({\n          weight: weight,\n          address: addr\n        });\n        break;\n\n      case SignatureType.EOA:\n        const sig = ethers.utils.arrayify(`0x${auxsig.slice(rindex, rindex + 132)}`);\n        rindex += 132;\n        const split = ethers.utils.splitSignature(sig.slice(0, 65));\n        const r = split.r;\n        const s = split.s;\n        const v = split.v;\n        const t = ethers.BigNumber.from(sig[sig.length - 1]).toNumber();\n        signers.push({\n          weight: weight,\n          signature: sig,\n          r: r,\n          s: s,\n          v: v,\n          t: t\n        });\n        break;\n\n      case SignatureType.Full:\n        const address = ethers.utils.getAddress(auxsig.slice(rindex, rindex + 40));\n        rindex += 40;\n        const size = ethers.BigNumber.from(`0x${auxsig.slice(rindex, rindex + 4)}`).mul(2).toNumber();\n        rindex += 4;\n\n        const _signature = ethers.utils.arrayify(`0x${auxsig.slice(rindex, rindex + size)}`);\n\n        rindex += size;\n        signers.push({\n          weight: weight,\n          address: address,\n          signature: _signature\n        });\n        break;\n\n      default:\n        throw Error('Signature type not supported');\n    }\n  }\n\n  return {\n    threshold: threshold,\n    signers: signers\n  };\n};\nconst SIG_TYPE_EIP712 = 1;\nconst SIG_TYPE_ETH_SIGN = 2;\nconst SIG_TYPE_WALLET_BYTES32 = 3;\nconst splitDecodedEOASigner = sig => {\n  const signature = ethers.utils.arrayify(sig.signature);\n  const split = ethers.utils.splitSignature(signature.slice(0, 65));\n  const t = ethers.BigNumber.from(signature[signature.length - 1]).toNumber();\n  return _extends({}, sig, split, {\n    t: t\n  });\n};\nconst recoverEOASigner = (digest, sig) => {\n  const signature = isDecodedEOASplitSigner(sig) ? sig : splitDecodedEOASigner(sig);\n\n  switch (signature.t) {\n    case SIG_TYPE_EIP712:\n      return ethers.utils.recoverAddress(digest, {\n        r: signature.r,\n        s: signature.s,\n        v: signature.v\n      });\n\n    case SIG_TYPE_ETH_SIGN:\n      const subDigest = ethers.utils.keccak256(ethers.utils.solidityPack(['string', 'bytes32'], ['\\x19Ethereum Signed Message:\\n32', digest]));\n      return ethers.utils.recoverAddress(subDigest, {\n        r: signature.r,\n        s: signature.s,\n        v: signature.v\n      });\n\n    default:\n      throw new Error('Unknown signature');\n  }\n};\nconst joinSignatures = (...signatures) => {\n  const parts = signatures.map(s => typeof s === 'string' ? decodeSignature(s) : s);\n  return parts.reduce((p, c) => joinTwoSignatures(p, c));\n};\nconst joinTwoSignatures = (a, b) => {\n  return {\n    threshold: a.threshold,\n    signers: a.signers.map((s, i) => isDecodedAddress(s) ? b.signers[i] : s)\n  };\n};\nconst encodeSignature = sig => {\n  if (typeof sig === 'string') return encodeSignature(decodeSignature(sig));\n  const accountBytes = sig.signers.map(s => {\n    if (isDecodedAddress(s)) {\n      return ethers.utils.solidityPack(['uint8', 'uint8', 'address'], [SignatureType.Address, s.weight, s.address]);\n    }\n\n    if (isDecodedEOASplitSigner(s)) {\n      return ethers.utils.solidityPack(['uint8', 'uint8', 'bytes32', 'bytes32', 'uint8', 'uint8'], [SignatureType.EOA, s.weight, s.r, s.s, s.v, s.t]);\n    }\n\n    if (isDecodedFullSigner(s)) {\n      const signatureSize = ethers.utils.arrayify(s.signature).length;\n      return ethers.utils.solidityPack(['uint8', 'uint8', 'address', 'uint16', 'bytes'], [SignatureType.Full, s.weight, s.address, signatureSize, s.signature]);\n    }\n\n    if (isDecodedEOASigner(s)) {\n      return ethers.utils.solidityPack(['uint8', 'uint8', 'bytes'], [SignatureType.EOA, s.weight, s.signature]);\n    }\n\n    throw Error('Unkwnown signature part type');\n  });\n  return ethers.utils.solidityPack(['uint16', ...Array(accountBytes.length).fill('bytes')], [sig.threshold, ...accountBytes]);\n};\nfunction signerOf(part, digest) {\n  if (isDecodedAddress(part)) {\n    return part.address;\n  }\n\n  if (isDecodedFullSigner(part)) {\n    return part.address;\n  }\n\n  if (isDecodedEOASplitSigner(part) || isDecodedEOASigner(part)) {\n    return recoverEOASigner(digest, part);\n  }\n\n  throw Error('Unkwnown signature part type');\n}\nfunction mutateSignature(sig, config, digest) {\n  const allSigners = sig.signers.map(s => signerOf(s, digest));\n  return {\n    threshold: config.threshold,\n    signers: config.signers.map(s => {\n      const found = allSigners.indexOf(s.address);\n\n      if (found !== -1) {\n        const part = sig.signers[found];\n        return _extends({}, part, {\n          weight: s.weight\n        });\n      }\n\n      return {\n        weight: s.weight,\n        address: s.address\n      };\n    })\n  };\n}\nasync function buildStubSignature(provider, config) {\n  const multicallProvider = new multicall.providers.MulticallProvider(provider); // Pre-load if signers are EOAs or not\n\n  const signers = await Promise.all(config.signers.map(async (s, i) => {\n    return _extends({}, s, {\n      index: i,\n      isEOA: ethers.utils.arrayify(await multicallProvider.getCode(s.address)).length === 0\n    });\n  })); // Sort signers by weight\n  // and prepare them for selection\n\n  let sortedSigners = signers.sort((a, b) => a.weight - b.weight); // Keep track of the total signing power\n\n  let totalWeight = 0; // First pick non-eoa signers\n\n  sortedSigners = sortedSigners.map(s => {\n    if (totalWeight >= config.threshold || s.isEOA) return s;\n    totalWeight += s.weight;\n    return _extends({}, s, {\n      willSign: true\n    });\n  }); // If we still haven't reached threshold\n  // start picking non-EOA signers\n\n  if (totalWeight < config.threshold) {\n    sortedSigners = sortedSigners.map(s => {\n      if (s.willSign || totalWeight >= config.threshold) return s;\n      totalWeight += s.weight;\n      return _extends({}, s, {\n        willSign: true\n      });\n    });\n  } // Stub signature part\n  // pre-determined signature, tailored for worse-case scenario in gas costs\n\n\n  const stubSig = ethers.utils.arrayify(\"0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a01b02\"); // Re-sort signers by original index\n\n  const finalSigners = sortedSigners.sort((a, b) => a.index - b.index); // Map final signers to signature parts\n\n  return {\n    threshold: config.threshold,\n    signers: finalSigners.map(s => {\n      // If wallet shouldn't sign\n      // just return address part\n      if (!s.willSign) {\n        return {\n          address: s.address,\n          weight: s.weight\n        };\n      } // If wallet is EOA return signature\n      // part is with stubSign\n\n\n      if (s.isEOA) {\n        return {\n          weight: s.weight,\n          signature: stubSig\n        };\n      } // If wallet is a contract\n      // build a stub nested signature\n\n\n      return {\n        weight: s.weight,\n        address: s.address,\n        signature: encodeSignature({\n          threshold: 1,\n          signers: [{\n            address: ethers.Wallet.createRandom().address,\n            weight: 1\n          }, {\n            weight: 1,\n            signature: stubSig\n          }]\n        }) + ethers.utils.hexlify(SIG_TYPE_WALLET_BYTES32).substring(2)\n      };\n    })\n  };\n}\n\nexport { ConfigFinder, SequenceUtilsFinder, SignatureType, WalletContractBytecode, addressOf, buildStubSignature, compareAddr, createWalletConfig, decodeSignature, editConfig, encodeSignature, genConfig, imageHash, isConfigEqual, isDecodedAddress, isDecodedEOASigner, isDecodedEOASplitSigner, isDecodedFullSigner, isDecodedSigner, isUsableConfig, isValidConfigSigners, joinSignatures, joinTwoSignatures, mutateSignature, recoverEOASigner, signerOf, sortConfig, splitDecodedEOASigner };\n","import fetch from 'cross-fetch';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\n/* eslint-disable */\n// sequence-indexer v0.4.0 6071879702f8258e8912ca95cf2d9c1459ca991d\n// --\n// This file has been generated by https://github.com/webrpc/webrpc using gen/typescript\n// Do not edit by hand. Update your webrpc schema and re-generate.\n// WebRPC description and code-gen version\nconst WebRPCVersion = \"v1\"; // Schema version of your RIDL schema\n\nconst WebRPCSchemaVersion = \"v0.4.0\"; // Schema hash generated from your RIDL schema\n\nconst WebRPCSchemaHash = \"6071879702f8258e8912ca95cf2d9c1459ca991d\"; //\n// Types\n//\n\nlet ContractType;\n\n(function (ContractType) {\n  ContractType[\"UNKNOWN\"] = \"UNKNOWN\";\n  ContractType[\"ERC20\"] = \"ERC20\";\n  ContractType[\"ERC721\"] = \"ERC721\";\n  ContractType[\"ERC1155\"] = \"ERC1155\";\n  ContractType[\"SEQUENCE_WALLET\"] = \"SEQUENCE_WALLET\";\n  ContractType[\"ERC20_BRIDGE\"] = \"ERC20_BRIDGE\";\n  ContractType[\"ERC721_BRIDGE\"] = \"ERC721_BRIDGE\";\n  ContractType[\"ERC1155_BRIDGE\"] = \"ERC1155_BRIDGE\";\n})(ContractType || (ContractType = {}));\n\nlet EventLogType;\n\n(function (EventLogType) {\n  EventLogType[\"UNKNOWN\"] = \"UNKNOWN\";\n  EventLogType[\"BLOCK_ADDED\"] = \"BLOCK_ADDED\";\n  EventLogType[\"BLOCK_REMOVED\"] = \"BLOCK_REMOVED\";\n})(EventLogType || (EventLogType = {}));\n\nlet EventLogDataType;\n\n(function (EventLogDataType) {\n  EventLogDataType[\"UNKNOWN\"] = \"UNKNOWN\";\n  EventLogDataType[\"TOKEN_TRANSFER\"] = \"TOKEN_TRANSFER\";\n  EventLogDataType[\"SEQUENCE_TXN\"] = \"SEQUENCE_TXN\";\n})(EventLogDataType || (EventLogDataType = {}));\n\nlet TxnTransferType;\n\n(function (TxnTransferType) {\n  TxnTransferType[\"UNKNOWN\"] = \"UNKNOWN\";\n  TxnTransferType[\"SEND\"] = \"SEND\";\n  TxnTransferType[\"RECEIVE\"] = \"RECEIVE\";\n})(TxnTransferType || (TxnTransferType = {}));\n\nlet SortOrder;\n\n(function (SortOrder) {\n  SortOrder[\"DESC\"] = \"DESC\";\n  SortOrder[\"ASC\"] = \"ASC\";\n})(SortOrder || (SortOrder = {}));\n\n//\n// Client\n//\nclass Indexer {\n  constructor(hostname, fetch) {\n    this.hostname = void 0;\n    this.fetch = void 0;\n    this.path = '/rpc/Indexer/';\n\n    this.ping = headers => {\n      return this.fetch(this.url('Ping'), createHTTPRequest({}, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: _data.status\n          };\n        });\n      });\n    };\n\n    this.version = headers => {\n      return this.fetch(this.url('Version'), createHTTPRequest({}, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            version: _data.version\n          };\n        });\n      });\n    };\n\n    this.runtimeStatus = headers => {\n      return this.fetch(this.url('RuntimeStatus'), createHTTPRequest({}, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: _data.status\n          };\n        });\n      });\n    };\n\n    this.getChainID = headers => {\n      return this.fetch(this.url('GetChainID'), createHTTPRequest({}, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            chainID: _data.chainID\n          };\n        });\n      });\n    };\n\n    this.getEtherBalance = (args, headers) => {\n      return this.fetch(this.url('GetEtherBalance'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            balance: _data.balance\n          };\n        });\n      });\n    };\n\n    this.getTokenBalances = (args, headers) => {\n      return this.fetch(this.url('GetTokenBalances'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            page: _data.page,\n            balances: _data.balances\n          };\n        });\n      });\n    };\n\n    this.getTokenSupplies = (args, headers) => {\n      return this.fetch(this.url('GetTokenSupplies'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            page: _data.page,\n            contractType: _data.contractType,\n            tokenIDs: _data.tokenIDs\n          };\n        });\n      });\n    };\n\n    this.getTokenSuppliesMap = (args, headers) => {\n      return this.fetch(this.url('GetTokenSuppliesMap'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            supplies: _data.supplies\n          };\n        });\n      });\n    };\n\n    this.getBalanceUpdates = (args, headers) => {\n      return this.fetch(this.url('GetBalanceUpdates'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            page: _data.page,\n            balances: _data.balances\n          };\n        });\n      });\n    };\n\n    this.getTransactionHistory = (args, headers) => {\n      return this.fetch(this.url('GetTransactionHistory'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            page: _data.page,\n            transactions: _data.transactions\n          };\n        });\n      });\n    };\n\n    this.syncBalance = (args, headers) => {\n      return this.fetch(this.url('SyncBalance'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {};\n        });\n      });\n    };\n\n    this.hostname = hostname;\n    this.fetch = fetch;\n  }\n\n  url(name) {\n    return this.hostname + this.path + name;\n  }\n\n}\n\nconst createHTTPRequest = (body = {}, headers = {}) => {\n  return {\n    method: 'POST',\n    headers: _extends({}, headers, {\n      'Content-Type': 'application/json'\n    }),\n    body: JSON.stringify(body || {})\n  };\n};\n\nconst buildResponse = res => {\n  return res.text().then(text => {\n    let data;\n\n    try {\n      data = JSON.parse(text);\n    } catch (err) {\n      throw {\n        code: 'unknown',\n        msg: `expecting JSON, got: ${text}`,\n        status: res.status\n      };\n    }\n\n    if (!res.ok) {\n      throw data; // webrpc error response\n    }\n\n    return data;\n  });\n};\n\nlet SequenceIndexerServices;\n\n(function (SequenceIndexerServices) {\n  SequenceIndexerServices[\"MAINNET\"] = \"https://mainnet-indexer.sequence.app\";\n  SequenceIndexerServices[\"POLYGON\"] = \"https://polygon-indexer.sequence.app\";\n  SequenceIndexerServices[\"RINKEBY\"] = \"https://rinkeby-indexer.sequence.app\";\n  SequenceIndexerServices[\"POLYGON_MUMBAI\"] = \"https://mumbai-indexer.sequence.app\";\n})(SequenceIndexerServices || (SequenceIndexerServices = {}));\n\nclass SequenceIndexerClient extends Indexer {\n  constructor(hostname, jwtAuth) {\n    super(hostname.endsWith('/') ? hostname.slice(0, -1) : hostname, fetch);\n    this.jwtAuth = jwtAuth;\n\n    this._fetch = (input, init) => {\n      // automatically include jwt auth header to requests\n      // if its been set on the api client\n      const headers = {};\n\n      if (this.jwtAuth && this.jwtAuth.length > 0) {\n        headers['Authorization'] = `BEARER ${this.jwtAuth}`;\n      } // before the request is made\n\n\n      init.headers = _extends({}, init.headers, headers);\n      return fetch(input, init);\n    };\n\n    this.fetch = this._fetch;\n  }\n\n}\n\nexport { ContractType, EventLogDataType, EventLogType, Indexer, SequenceIndexerClient, SequenceIndexerServices, SortOrder, TxnTransferType, WebRPCSchemaHash, WebRPCSchemaVersion, WebRPCVersion };\n","import fetch from 'cross-fetch';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\n/* eslint-disable */\n// sequence-metadata v0.4.0 3f6b0f4aa1a7b58488e9399c277fc17995d74f5a\n// --\n// This file has been generated by https://github.com/webrpc/webrpc using gen/typescript\n// Do not edit by hand. Update your webrpc schema and re-generate.\n// WebRPC description and code-gen version\nconst WebRPCVersion = \"v1\"; // Schema version of your RIDL schema\n\nconst WebRPCSchemaVersion = \"v0.4.0\"; // Schema hash generated from your RIDL schema\n\nconst WebRPCSchemaHash = \"3f6b0f4aa1a7b58488e9399c277fc17995d74f5a\"; //\n// Types\n//\n\nlet ContractType;\n\n(function (ContractType) {\n  ContractType[\"UNKNOWN\"] = \"UNKNOWN\";\n  ContractType[\"ERC20\"] = \"ERC20\";\n  ContractType[\"ERC721\"] = \"ERC721\";\n  ContractType[\"ERC1155\"] = \"ERC1155\";\n})(ContractType || (ContractType = {}));\n\nlet SwapType;\n\n(function (SwapType) {\n  SwapType[\"UNKNOWN\"] = \"UNKNOWN\";\n  SwapType[\"BUY\"] = \"BUY\";\n  SwapType[\"SELL\"] = \"SELL\";\n})(SwapType || (SwapType = {}));\n\nlet SortOrder;\n\n(function (SortOrder) {\n  SortOrder[\"DESC\"] = \"DESC\";\n  SortOrder[\"ASC\"] = \"ASC\";\n})(SortOrder || (SortOrder = {}));\n\n//\n// Client\n//\nclass Metadata {\n  constructor(hostname, fetch) {\n    this.hostname = void 0;\n    this.fetch = void 0;\n    this.path = '/rpc/Metadata/';\n\n    this.ping = headers => {\n      return this.fetch(this.url('Ping'), createHTTPRequest({}, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: _data.status\n          };\n        });\n      });\n    };\n\n    this.version = headers => {\n      return this.fetch(this.url('Version'), createHTTPRequest({}, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            version: _data.version\n          };\n        });\n      });\n    };\n\n    this.runtimeStatus = headers => {\n      return this.fetch(this.url('RuntimeStatus'), createHTTPRequest({}, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: _data.status\n          };\n        });\n      });\n    };\n\n    this.getTokenMetadata = (args, headers) => {\n      return this.fetch(this.url('GetTokenMetadata'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            tokenMetadata: _data.tokenMetadata\n          };\n        });\n      });\n    };\n\n    this.getTokenMetadataBatch = (args, headers) => {\n      return this.fetch(this.url('GetTokenMetadataBatch'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            contractTokenMetadata: _data.contractTokenMetadata\n          };\n        });\n      });\n    };\n\n    this.searchTokenMetadata = (args, headers) => {\n      return this.fetch(this.url('SearchTokenMetadata'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            page: _data.page,\n            tokenMetadata: _data.tokenMetadata\n          };\n        });\n      });\n    };\n\n    this.searchTokenIDs = (args, headers) => {\n      return this.fetch(this.url('SearchTokenIDs'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            page: _data.page,\n            tokenIds: _data.tokenIds\n          };\n        });\n      });\n    };\n\n    this.getContractInfo = (args, headers) => {\n      return this.fetch(this.url('GetContractInfo'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            contractInfo: _data.contractInfo\n          };\n        });\n      });\n    };\n\n    this.getContractInfoBatch = (args, headers) => {\n      return this.fetch(this.url('GetContractInfoBatch'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            contractInfoMap: _data.contractInfoMap\n          };\n        });\n      });\n    };\n\n    this.searchContractInfo = (args, headers) => {\n      return this.fetch(this.url('SearchContractInfo'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            contractInfoList: _data.contractInfoList\n          };\n        });\n      });\n    };\n\n    this.searchContractInfoBatch = (args, headers) => {\n      return this.fetch(this.url('SearchContractInfoBatch'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            contractInfoByChain: _data.contractInfoByChain\n          };\n        });\n      });\n    };\n\n    this.getNiftyswapTokenQuantity = (args, headers) => {\n      return this.fetch(this.url('GetNiftyswapTokenQuantity'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            quantity: _data.quantity\n          };\n        });\n      });\n    };\n\n    this.getNiftyswapUnitPrices = (args, headers) => {\n      return this.fetch(this.url('GetNiftyswapUnitPrices'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            prices: _data.prices\n          };\n        });\n      });\n    };\n\n    this.hostname = hostname;\n    this.fetch = fetch;\n  }\n\n  url(name) {\n    return this.hostname + this.path + name;\n  }\n\n}\n\nconst createHTTPRequest = (body = {}, headers = {}) => {\n  return {\n    method: 'POST',\n    headers: _extends({}, headers, {\n      'Content-Type': 'application/json'\n    }),\n    body: JSON.stringify(body || {})\n  };\n};\n\nconst buildResponse = res => {\n  return res.text().then(text => {\n    let data;\n\n    try {\n      data = JSON.parse(text);\n    } catch (err) {\n      throw {\n        code: 'unknown',\n        msg: `expecting JSON, got: ${text}`,\n        status: res.status\n      };\n    }\n\n    if (!res.ok) {\n      throw data; // webrpc error response\n    }\n\n    return data;\n  });\n};\n\nclass SequenceMetadataClient extends Metadata {\n  constructor(hostname = 'https://metadata.sequence.app') {\n    super(hostname.endsWith('/') ? hostname.slice(0, -1) : hostname, fetch);\n  }\n\n}\n\nexport { ContractType, Metadata, SequenceMetadataClient, SortOrder, SwapType, WebRPCSchemaHash, WebRPCSchemaVersion, WebRPCVersion };\n","import { ethers } from 'ethers';\nimport { Interface } from '@ethersproject/abi';\nimport { walletContracts } from '@0xsequence/abi';\nimport { subDigestOf } from '@0xsequence/utils';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nconst MetaTransactionsType = `tuple(\n  bool delegateCall,\n  bool revertOnError,\n  uint256 gasLimit,\n  address target,\n  uint256 value,\n  bytes data\n)[]`;\nfunction packMetaTransactionsData(...txs) {\n  const nonce = readSequenceNonce(...txs);\n  if (nonce === undefined) throw new Error('Encoding transactions without defined nonce');\n  return packMetaTransactionsNonceData(nonce, ...txs);\n}\nfunction packMetaTransactionsNonceData(nonce, ...txs) {\n  return ethers.utils.defaultAbiCoder.encode(['uint256', MetaTransactionsType], [nonce, sequenceTxAbiEncode(txs)]);\n}\nfunction digestOfTransactions(...txs) {\n  const nonce = readSequenceNonce(...txs);\n  if (nonce === undefined) throw new Error('Computing hash for transactions without defined nonce');\n  return digestOfTransactionsNonce(nonce, ...txs);\n}\nfunction digestOfTransactionsNonce(nonce, ...txs) {\n  return ethers.utils.keccak256(packMetaTransactionsNonceData(nonce, ...txs));\n}\nfunction computeMetaTxnHash(address, chainId, ...txs) {\n  return subDigestOf(address, chainId, digestOfTransactions(...txs)).replace(/^0x/, '');\n}\nasync function toSequenceTransactions(wallet, txs, revertOnError = false, gasLimit = ethers.constants.Zero) {\n  // Bundles all transactions, including the auxiliary ones\n  const allTxs = flattenAuxTransactions(txs); // Uses the lowest nonce found on TransactionRequest\n  // if there are no nonces, it leaves an undefined nonce\n\n  const nonces = (await Promise.all(txs.map(t => t.nonce))).filter(n => n !== undefined).map(n => ethers.BigNumber.from(n));\n  const nonce = nonces.length !== 0 ? nonces.reduce((p, c) => p.lt(c) ? p : c) : undefined; // Maps all transactions into SequenceTransactions\n\n  return Promise.all(allTxs.map(tx => toSequenceTransaction(wallet, tx, revertOnError, gasLimit, nonce)));\n}\nfunction flattenAuxTransactions(txs) {\n  if (!Array.isArray(txs)) return flattenAuxTransactions([txs]);\n  return txs.reduce(function (p, c) {\n    if (Array.isArray(c)) {\n      return p.concat(flattenAuxTransactions(c));\n    }\n\n    if (c.auxiliary) {\n      return p.concat([c, ...flattenAuxTransactions(c.auxiliary)]);\n    }\n\n    return p.concat(c);\n  }, []);\n}\nasync function toSequenceTransaction(wallet, tx, revertOnError = false, gasLimit = ethers.constants.Zero, nonce) {\n  if (isSequenceTransaction(tx)) {\n    return tx;\n  }\n\n  const txGas = tx.gasLimit === undefined ? tx.gas : tx.gasLimit;\n\n  if (tx.to) {\n    return {\n      delegateCall: false,\n      revertOnError: revertOnError,\n      gasLimit: txGas ? await txGas : gasLimit,\n      to: await tx.to,\n      value: tx.value ? await tx.value : 0,\n      data: await tx.data,\n      nonce: nonce ? nonce : await tx.nonce\n    };\n  } else {\n    const walletInterface = new Interface(walletContracts.mainModule.abi);\n    const data = walletInterface.encodeFunctionData(walletInterface.getFunction('createContract'), [tx.data]);\n    const address = typeof wallet === 'string' ? wallet : wallet.getAddress();\n    return {\n      delegateCall: false,\n      revertOnError: revertOnError,\n      gasLimit: txGas ? await txGas : gasLimit,\n      to: await address,\n      value: tx.value ? await tx.value : 0,\n      data: data,\n      nonce: nonce ? nonce : await tx.nonce\n    };\n  }\n}\nfunction isAsyncSendable(target) {\n  return target.send || target.sendAsync;\n}\nfunction isSequenceTransaction(tx) {\n  return tx.delegateCall !== undefined || tx.revertOnError !== undefined;\n}\nfunction hasSequenceTransactions(txs) {\n  return txs.find(t => isSequenceTransaction(t)) !== undefined;\n}\nfunction readSequenceNonce(...txs) {\n  const sample = txs.find(t => t.nonce !== undefined);\n\n  if (!sample) {\n    return undefined;\n  }\n\n  const sampleNonce = ethers.BigNumber.from(sample.nonce);\n\n  if (txs.find(t => t.nonce !== undefined && !ethers.BigNumber.from(t.nonce).eq(sampleNonce))) {\n    throw new Error('Mixed nonces on Sequence transactions');\n  }\n\n  return sample ? sample.nonce : undefined;\n}\nfunction sequenceTxAbiEncode(txs) {\n  return txs.map(t => {\n    var _t$to;\n\n    return {\n      delegateCall: t.delegateCall === true,\n      revertOnError: t.revertOnError === true,\n      gasLimit: t.gasLimit !== undefined ? t.gasLimit : ethers.constants.Zero,\n      target: (_t$to = t.to) != null ? _t$to : ethers.constants.AddressZero,\n      value: t.value !== undefined ? t.value : ethers.constants.Zero,\n      data: t.data !== undefined ? t.data : []\n    };\n  });\n}\nfunction appendNonce(txs, nonce) {\n  return txs.map(t => _extends({}, t, {\n    nonce\n  }));\n}\nfunction makeExpirable(context, txs, expiration) {\n  const sequenceUtils = new Interface(walletContracts.sequenceUtils.abi);\n\n  if (!context || !context.sequenceUtils) {\n    throw new Error('Undefined sequenceUtils');\n  }\n\n  return [{\n    delegateCall: false,\n    revertOnError: true,\n    gasLimit: 0,\n    to: context.sequenceUtils,\n    value: 0,\n    data: sequenceUtils.encodeFunctionData(sequenceUtils.getFunction('requireNonExpired'), [expiration])\n  }, ...txs];\n}\nfunction makeAfterNonce(context, txs, dep) {\n  const sequenceUtils = new Interface(walletContracts.sequenceUtils.abi);\n\n  if (!context || !context.sequenceUtils) {\n    throw new Error('Undefined sequenceUtils');\n  }\n\n  return [{\n    delegateCall: false,\n    revertOnError: true,\n    gasLimit: 0,\n    to: context.sequenceUtils,\n    value: 0,\n    data: sequenceUtils.encodeFunctionData(sequenceUtils.getFunction('requireMinNonce'), [dep.address, dep.space ? encodeNonce(dep.space, dep.nonce) : dep.nonce])\n  }, ...txs];\n}\nfunction encodeNonce(space, nonce) {\n  const bspace = ethers.BigNumber.from(space);\n  const bnonce = ethers.BigNumber.from(nonce);\n  const shl = ethers.constants.Two.pow(ethers.BigNumber.from(96));\n\n  if (!bnonce.div(shl).eq(ethers.constants.Zero)) {\n    throw new Error('Space already encoded');\n  }\n\n  return bnonce.add(bspace.mul(shl));\n}\nfunction decodeNonce(nonce) {\n  const bnonce = ethers.BigNumber.from(nonce);\n  const shr = ethers.constants.Two.pow(ethers.BigNumber.from(96));\n  return [bnonce.div(shr), bnonce.mod(shr)];\n}\nfunction isSignedTransactions(cand) {\n  return cand !== undefined && cand.chainId !== undefined && cand.config !== undefined && cand.context !== undefined && cand.signature !== undefined && cand.transactions !== undefined && Array.isArray(cand.transactions) && cand.transactions.reduce((p, c) => p && isSequenceTransaction(c), true);\n}\nasync function fromTransactionish(context, wallet, transaction) {\n  let stx = [];\n\n  if (Array.isArray(transaction)) {\n    if (hasSequenceTransactions(transaction)) {\n      stx = transaction;\n    } else {\n      stx = await toSequenceTransactions(wallet, transaction);\n    }\n  } else if (isSequenceTransaction(transaction)) {\n    stx = [transaction];\n  } else {\n    stx = await toSequenceTransactions(wallet, [transaction]);\n  } // If transaction is marked as expirable\n  // append expirable require\n\n\n  if (transaction.expiration) {\n    stx = makeExpirable(context, stx, transaction.expiration);\n  } // If transaction depends on another nonce\n  // append after nonce requirement\n\n\n  if (transaction.afterNonce) {\n    const after = transaction.afterNonce;\n    stx = makeAfterNonce(context, stx, after.address ? {\n      address: after.address,\n      nonce: after.nonce,\n      space: after.space\n    } : {\n      address: wallet,\n      nonce: after\n    });\n  }\n\n  return stx;\n}\n\nexport { MetaTransactionsType, appendNonce, computeMetaTxnHash, decodeNonce, digestOfTransactions, digestOfTransactionsNonce, encodeNonce, flattenAuxTransactions, fromTransactionish, hasSequenceTransactions, isAsyncSendable, isSequenceTransaction, isSignedTransactions, makeAfterNonce, makeExpirable, packMetaTransactionsData, packMetaTransactionsNonceData, readSequenceNonce, sequenceTxAbiEncode, toSequenceTransaction, toSequenceTransactions };\n","import { ethers, providers, Signer } from 'ethers';\nimport { walletContracts } from '@0xsequence/abi';\nimport { sequenceTxAbiEncode, readSequenceNonce, encodeNonce, computeMetaTxnHash, MetaTransactionsType, appendNonce, decodeNonce } from '@0xsequence/transactions';\nimport { isBigNumberish, logger } from '@0xsequence/utils';\nimport { Provider } from '@ethersproject/providers';\nimport { imageHash, addressOf, encodeSignature, buildStubSignature } from '@0xsequence/config';\nimport { Interface } from 'ethers/lib/utils';\nimport fetchPonyfill from 'fetch-ponyfill';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction isBaseRelayerOptions(obj) {\n  return obj.bundleCreation !== undefined && typeof obj.bundleCreation === 'boolean' || obj.creationGasLimit !== undefined && isBigNumberish(obj.creationGasLimit) || obj.provider !== undefined && (providers.Provider.isProvider(obj.provider) || typeof obj.provider === 'string');\n}\nconst BaseRelayerDefaults = {\n  bundleCreation: true,\n  creationGasLimit: ethers.constants.Two.pow(17)\n};\nclass BaseRelayer {\n  constructor(options) {\n    this.provider = void 0;\n    this.bundleCreation = void 0;\n    this.creationGasLimit = void 0;\n\n    const opts = _extends({}, BaseRelayerDefaults, options);\n\n    this.bundleCreation = opts.bundleCreation;\n    this.provider = opts.provider;\n    this.creationGasLimit = ethers.BigNumber.from(opts.creationGasLimit);\n  }\n\n  async isWalletDeployed(walletAddress) {\n    if (!this.provider) throw new Error('Bundled creation provider not found');\n    return (await this.provider.getCode(walletAddress)) !== '0x';\n  }\n\n  prepareWalletDeploy(config, context) {\n    const factoryInterface = new Interface(walletContracts.factory.abi);\n    return {\n      to: context.factory,\n      data: factoryInterface.encodeFunctionData(factoryInterface.getFunction('deploy'), [context.mainModule, imageHash(config)])\n    };\n  }\n\n  async prependWalletDeploy(signedTransactions) {\n    const {\n      config,\n      context,\n      transactions,\n      nonce,\n      signature\n    } = signedTransactions;\n    const walletAddress = addressOf(config, context);\n    const walletInterface = new Interface(walletContracts.mainModule.abi);\n\n    const encodedSignature = async function () {\n      const sig = await signature;\n      if (typeof sig === 'string') return sig;\n      return encodeSignature(sig);\n    }();\n\n    if (this.bundleCreation && !(await this.isWalletDeployed(walletAddress))) {\n      return {\n        to: context.guestModule,\n        execute: {\n          transactions: [_extends({}, this.prepareWalletDeploy(config, context), {\n            delegateCall: false,\n            revertOnError: false,\n            gasLimit: this.creationGasLimit,\n            value: ethers.constants.Zero\n          }), {\n            delegateCall: false,\n            revertOnError: true,\n            gasLimit: ethers.constants.Zero,\n            to: walletAddress,\n            value: ethers.constants.Zero,\n            data: walletInterface.encodeFunctionData(walletInterface.getFunction('execute'), [sequenceTxAbiEncode(transactions), nonce, await encodedSignature])\n          }],\n          nonce: ethers.constants.Zero,\n          signature: '0x'\n        }\n      };\n    } else {\n      return {\n        to: walletAddress,\n        execute: {\n          transactions,\n          nonce: ethers.BigNumber.from(nonce),\n          signature: await encodedSignature\n        }\n      };\n    }\n  }\n\n  async prepareTransactions(config, context, signature, ...transactions) {\n    //, gasLimit?: ethers.BigNumberish }> {\n    const nonce = readSequenceNonce(...transactions);\n\n    if (!nonce) {\n      throw new Error('Unable to prepare transactions without a defined nonce');\n    }\n\n    const {\n      to,\n      execute\n    } = await this.prependWalletDeploy({\n      config,\n      context,\n      transactions,\n      nonce,\n      signature\n    });\n    const walletInterface = new Interface(walletContracts.mainModule.abi);\n    return {\n      to,\n      data: walletInterface.encodeFunctionData(walletInterface.getFunction('execute'), [sequenceTxAbiEncode(execute.transactions), execute.nonce, execute.signature])\n    };\n  }\n\n}\n\nconst DEFAULT_GAS_LIMIT = ethers.BigNumber.from(800000);\nconst ProviderRelayerDefaults = {\n  waitPollRate: 1000,\n  deltaBlocksLog: 12,\n  fromBlockLog: -1024\n};\nfunction isProviderRelayerOptions(obj) {\n  return obj.provider !== undefined && Provider.isProvider(obj.provider);\n}\nclass ProviderRelayer extends BaseRelayer {\n  constructor(options) {\n    super(options);\n    this.provider = void 0;\n    this.waitPollRate = void 0;\n    this.deltaBlocksLog = void 0;\n    this.fromBlockLog = void 0;\n\n    const opts = _extends({}, ProviderRelayerDefaults, options);\n\n    this.provider = opts.provider;\n    this.waitPollRate = opts.waitPollRate;\n    this.deltaBlocksLog = opts.deltaBlocksLog;\n    this.fromBlockLog = opts.fromBlockLog;\n  }\n\n  async simulate(wallet, ...transactions) {\n    var _this = this;\n\n    return (await Promise.all(transactions.map(async function (tx) {\n      // Respect gasLimit request of the transaction (as long as its not 0)\n      if (tx.gasLimit && !ethers.BigNumber.from(tx.gasLimit || 0).eq(ethers.constants.Zero)) {\n        return tx.gasLimit;\n      } // Fee can't be estimated locally for delegateCalls\n\n\n      if (tx.delegateCall) {\n        return DEFAULT_GAS_LIMIT;\n      } // Fee can't be estimated for self-called if wallet hasn't been deployed\n\n\n      if (tx.to === wallet && !(await _this.isWalletDeployed(wallet))) {\n        return DEFAULT_GAS_LIMIT;\n      }\n\n      if (!_this.provider) {\n        throw new Error('signer.provider is not set, but is required');\n      } // TODO: If the wallet address has been deployed, gas limits can be\n      // estimated with more accurately by using self-calls with the batch transactions one by one\n\n\n      return _this.provider.estimateGas({\n        from: wallet,\n        to: tx.to,\n        data: tx.data,\n        value: tx.value\n      });\n    }))).map(gasLimit => ({\n      executed: true,\n      succeeded: true,\n      gasLimit: ethers.BigNumber.from(gasLimit).toNumber(),\n      gasUsed: ethers.BigNumber.from(gasLimit).toNumber()\n    }));\n  }\n\n  async estimateGasLimits(config, context, ...transactions) {\n    const walletAddr = addressOf(config, context);\n    const results = await this.simulate(walletAddr, ...transactions);\n    return transactions.map((t, i) => _extends({}, t, {\n      gasLimit: results[i].gasLimit\n    }));\n  }\n\n  async getNonce(config, context, space, blockTag) {\n    if (!this.provider) {\n      throw new Error('provider is not set');\n    }\n\n    const addr = addressOf(config, context);\n\n    if ((await this.provider.getCode(addr)) === '0x') {\n      return 0;\n    }\n\n    if (space === undefined) {\n      space = 0;\n    }\n\n    const module = new ethers.Contract(addr, walletContracts.mainModule.abi, this.provider);\n    const nonce = await module.readNonce(space, {\n      blockTag: blockTag\n    });\n    return encodeNonce(space, nonce);\n  }\n\n  async wait(metaTxnId, timeout) {\n    if (typeof metaTxnId !== 'string') {\n      logger.info(\"computing id\", metaTxnId.config, metaTxnId.context, metaTxnId.chainId, ...metaTxnId.transactions);\n      return this.wait(computeMetaTxnHash(addressOf(metaTxnId.config, metaTxnId.context), metaTxnId.chainId, ...metaTxnId.transactions), timeout);\n    } // Transactions can only get executed on nonce change\n    // get all nonce changes and look for metaTxnIds in between logs\n\n\n    const timeoutTime = new Date().getTime() + timeout;\n    let lastBlock = this.fromBlockLog;\n\n    if (lastBlock < 0) {\n      const block = await this.provider.getBlockNumber();\n      lastBlock = block + lastBlock;\n    }\n\n    const normalMetaTxnId = metaTxnId.replace('0x', '');\n\n    while (new Date().getTime() < timeoutTime) {\n      const block = await this.provider.getBlockNumber();\n      const logs = await this.provider.getLogs({\n        fromBlock: Math.max(0, lastBlock - this.deltaBlocksLog),\n        toBlock: block,\n        // Nonce change event topic\n        topics: ['0x1f180c27086c7a39ea2a7b25239d1ab92348f07ca7bb59d1438fcf527568f881']\n      });\n      lastBlock = block; // Get receipts of all transactions\n\n      const txs = await Promise.all(logs.map(l => this.provider.getTransactionReceipt(l.transactionHash))); // Find a transaction with a TxExecuted log\n\n      const found = txs.find(tx => tx.logs.find(l => l.topics.length === 0 && l.data.replace('0x', '') === normalMetaTxnId || l.topics.length === 1 && // TxFailed event topic\n      l.topics[0] === \"0x3dbd1590ea96dd3253a91f24e64e3a502e1225d602a5731357bc12643070ccd7\" && l.data.length >= 64 && l.data.replace('0x', '').startsWith(normalMetaTxnId))); // If found return that\n\n      if (found) {\n        return _extends({\n          receipt: found\n        }, await this.provider.getTransaction(found.transactionHash));\n      } // Otherwise wait and try again\n\n\n      await new Promise(r => setTimeout(r, this.waitPollRate));\n    }\n\n    throw new Error(`Timeout waiting for transaction receipt ${metaTxnId}`);\n  }\n\n}\n\nfunction isLocalRelayerOptions(obj) {\n  return obj.signer !== undefined && Signer.isSigner(obj.signer);\n}\nclass LocalRelayer extends ProviderRelayer {\n  constructor(options) {\n    super(Signer.isSigner(options) ? {\n      provider: options.provider\n    } : _extends({}, options, {\n      provider: options.signer.provider\n    }));\n    this.signer = void 0;\n    this.txnOptions = void 0;\n    this.signer = Signer.isSigner(options) ? options : options.signer;\n    if (!this.signer.provider) throw new Error(\"Signer must have a provider\");\n  }\n\n  async deployWallet(config, context) {\n    // NOTE: on hardhat some tests fail on HookCallerMock when not passing gasLimit directly as below,\n    // and using eth_gasEstimate. Perhaps review HookCallerMock.sol and fix it to avoid what looks\n    // like an infinite loop?\n    const walletDeployTxn = this.prepareWalletDeploy(config, context); // NOTE: for hardhat to pass, we have to set the gasLimit directly, as its unable to estimate\n\n    return this.signer.sendTransaction(_extends({}, walletDeployTxn, {\n      gasLimit: ethers.constants.Two.pow(17)\n    }));\n  }\n\n  async getFeeOptions(_config, _context, ..._transactions) {\n    return {\n      options: []\n    };\n  }\n\n  async gasRefundOptions(config, context, ...transactions) {\n    const {\n      options\n    } = await this.getFeeOptions(config, context, ...transactions);\n    return options;\n  }\n\n  setTransactionOptions(transactionRequest) {\n    this.txnOptions = transactionRequest;\n  }\n\n  async relay(signedTxs, quote) {\n    if (quote !== undefined) {\n      logger.warn(`LocalRelayer doesn't accept fee quotes`);\n    }\n\n    if (!signedTxs.context.guestModule || signedTxs.context.guestModule.length !== 42) {\n      throw new Error('LocalRelayer requires the context.guestModule address');\n    }\n\n    const {\n      to,\n      execute\n    } = await this.prependWalletDeploy(signedTxs);\n    const walletInterface = new ethers.utils.Interface(walletContracts.mainModule.abi);\n    const data = walletInterface.encodeFunctionData(walletInterface.getFunction('execute'), [sequenceTxAbiEncode(execute.transactions), execute.nonce, execute.signature]); // TODO: think about computing gas limit individually, summing together and passing across\n    // NOTE: we expect that all txns have set their gasLimit ahead of time through proper estimation\n    // const gasLimit = signedTxs.transactions.reduce((sum, tx) => sum.add(tx.gasLimit), ethers.BigNumber.from(0))\n    // txRequest.gasLimit = gasLimit\n\n    return this.signer.sendTransaction(_extends({\n      to,\n      data\n    }, this.txnOptions));\n  }\n\n}\n\n/* eslint-disable */\n// sequence-relayer v0.4.0 4dca0b91c1531d1166ae2f7ebd8af571b0c0e43b\n// --\n// This file has been generated by https://github.com/webrpc/webrpc using gen/typescript\n// Do not edit by hand. Update your webrpc schema and re-generate.\n// WebRPC description and code-gen version\nconst WebRPCVersion = 'v1'; // Schema version of your RIDL schema\n\nconst WebRPCSchemaVersion = 'v0.4.0'; // Schema hash generated from your RIDL schema\n\nconst WebRPCSchemaHash = '4dca0b91c1531d1166ae2f7ebd8af571b0c0e43b'; //\n// Types\n//\n\nlet ETHTxnStatus;\n\n(function (ETHTxnStatus) {\n  ETHTxnStatus[\"UNKNOWN\"] = \"UNKNOWN\";\n  ETHTxnStatus[\"DROPPED\"] = \"DROPPED\";\n  ETHTxnStatus[\"QUEUED\"] = \"QUEUED\";\n  ETHTxnStatus[\"SENT\"] = \"SENT\";\n  ETHTxnStatus[\"SUCCEEDED\"] = \"SUCCEEDED\";\n  ETHTxnStatus[\"PARTIALLY_FAILED\"] = \"PARTIALLY_FAILED\";\n  ETHTxnStatus[\"FAILED\"] = \"FAILED\";\n})(ETHTxnStatus || (ETHTxnStatus = {}));\n\nlet TransferType;\n\n(function (TransferType) {\n  TransferType[\"SEND\"] = \"SEND\";\n  TransferType[\"RECEIVE\"] = \"RECEIVE\";\n  TransferType[\"BRIDGE_DEPOSIT\"] = \"BRIDGE_DEPOSIT\";\n  TransferType[\"BRIDGE_WITHDRAW\"] = \"BRIDGE_WITHDRAW\";\n  TransferType[\"BURN\"] = \"BURN\";\n  TransferType[\"UNKNOWN\"] = \"UNKNOWN\";\n})(TransferType || (TransferType = {}));\n\nlet FeeTokenType;\n\n(function (FeeTokenType) {\n  FeeTokenType[\"UNKNOWN\"] = \"UNKNOWN\";\n  FeeTokenType[\"ERC20_TOKEN\"] = \"ERC20_TOKEN\";\n  FeeTokenType[\"ERC1155_TOKEN\"] = \"ERC1155_TOKEN\";\n})(FeeTokenType || (FeeTokenType = {}));\n\nlet SortOrder;\n\n(function (SortOrder) {\n  SortOrder[\"DESC\"] = \"DESC\";\n  SortOrder[\"ASC\"] = \"ASC\";\n})(SortOrder || (SortOrder = {}));\n\n//\n// Client\n//\nclass Relayer {\n  constructor(hostname, fetch) {\n    this.hostname = void 0;\n    this.fetch = void 0;\n    this.path = '/rpc/Relayer/';\n\n    this.ping = headers => {\n      return this.fetch(this.url('Ping'), createHTTPRequest({}, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: _data.status\n          };\n        });\n      });\n    };\n\n    this.version = headers => {\n      return this.fetch(this.url('Version'), createHTTPRequest({}, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            version: _data.version\n          };\n        });\n      });\n    };\n\n    this.runtimeStatus = headers => {\n      return this.fetch(this.url('RuntimeStatus'), createHTTPRequest({}, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: _data.status\n          };\n        });\n      });\n    };\n\n    this.getSequenceContext = headers => {\n      return this.fetch(this.url('GetSequenceContext'), createHTTPRequest({}, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            data: _data.data\n          };\n        });\n      });\n    };\n\n    this.getChainID = headers => {\n      return this.fetch(this.url('GetChainID'), createHTTPRequest({}, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            chainID: _data.chainID\n          };\n        });\n      });\n    };\n\n    this.sendMetaTxn = (args, headers) => {\n      return this.fetch(this.url('SendMetaTxn'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            status: _data.status,\n            txnHash: _data.txnHash\n          };\n        });\n      });\n    };\n\n    this.getMetaTxnNonce = (args, headers) => {\n      return this.fetch(this.url('GetMetaTxnNonce'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            nonce: _data.nonce\n          };\n        });\n      });\n    };\n\n    this.getMetaTxnReceipt = (args, headers) => {\n      return this.fetch(this.url('GetMetaTxnReceipt'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            receipt: _data.receipt\n          };\n        });\n      });\n    };\n\n    this.simulate = (args, headers) => {\n      return this.fetch(this.url('Simulate'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            results: _data.results\n          };\n        });\n      });\n    };\n\n    this.updateMetaTxnGasLimits = (args, headers) => {\n      return this.fetch(this.url('UpdateMetaTxnGasLimits'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            payload: _data.payload\n          };\n        });\n      });\n    };\n\n    this.feeTokens = headers => {\n      return this.fetch(this.url('FeeTokens'), createHTTPRequest({}, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            isFeeRequired: _data.isFeeRequired,\n            tokens: _data.tokens\n          };\n        });\n      });\n    };\n\n    this.feeOptions = (args, headers) => {\n      return this.fetch(this.url('FeeOptions'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            options: _data.options,\n            quote: _data.quote\n          };\n        });\n      });\n    };\n\n    this.getMetaTxnNetworkFeeOptions = (args, headers) => {\n      return this.fetch(this.url('GetMetaTxnNetworkFeeOptions'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            options: _data.options\n          };\n        });\n      });\n    };\n\n    this.sentTransactions = (args, headers) => {\n      return this.fetch(this.url('SentTransactions'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            page: _data.page,\n            transactions: _data.transactions\n          };\n        });\n      });\n    };\n\n    this.pendingTransactions = (args, headers) => {\n      return this.fetch(this.url('PendingTransactions'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            page: _data.page,\n            transactions: _data.transactions\n          };\n        });\n      });\n    };\n\n    this.hostname = hostname;\n    this.fetch = fetch;\n  }\n\n  url(name) {\n    return this.hostname + this.path + name;\n  }\n\n}\n\nconst createHTTPRequest = (body = {}, headers = {}) => {\n  return {\n    method: 'POST',\n    headers: _extends({}, headers, {\n      'Content-Type': 'application/json'\n    }),\n    body: JSON.stringify(body || {})\n  };\n};\n\nconst buildResponse = res => {\n  return res.text().then(text => {\n    let data;\n\n    try {\n      data = JSON.parse(text);\n    } catch (err) {\n      throw {\n        code: 'unknown',\n        msg: `expecting JSON, got: ${text}`,\n        status: res.status\n      };\n    }\n\n    if (!res.ok) {\n      throw data; // webrpc error response\n    }\n\n    return data;\n  });\n};\n\nvar relayer_gen = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  WebRPCVersion: WebRPCVersion,\n  WebRPCSchemaVersion: WebRPCSchemaVersion,\n  WebRPCSchemaHash: WebRPCSchemaHash,\n  get ETHTxnStatus () { return ETHTxnStatus; },\n  get TransferType () { return TransferType; },\n  get FeeTokenType () { return FeeTokenType; },\n  get SortOrder () { return SortOrder; },\n  Relayer: Relayer\n});\n\nconst FAILED_STATUSES = [ETHTxnStatus.FAILED, ETHTxnStatus.PARTIALLY_FAILED, ETHTxnStatus.DROPPED];\nfunction isRpcRelayerOptions(obj) {\n  return obj.url !== undefined && typeof obj.url === 'string';\n}\nclass RpcRelayer extends BaseRelayer {\n  constructor(options) {\n    super(options);\n    this.service = void 0;\n    this.service = new Relayer(options.url, fetchPonyfill().fetch);\n  }\n\n  async waitReceipt(metaTxnHash, wait = 1000) {\n    if (typeof metaTxnHash !== 'string') {\n      logger.info('computing id', metaTxnHash.config, metaTxnHash.context, metaTxnHash.chainId, ...metaTxnHash.transactions);\n      return this.waitReceipt(computeMetaTxnHash(addressOf(metaTxnHash.config, metaTxnHash.context), metaTxnHash.chainId, ...metaTxnHash.transactions));\n    }\n\n    logger.info(`[rpc-relayer/waitReceipt] waiting for ${metaTxnHash}`);\n    let result = await this.service.getMetaTxnReceipt({\n      metaTxID: metaTxnHash\n    }); // TODO: remove check for 'UNKNOWN' status when 'QUEUED' status is supported\n    // TODO: fix backend to not return literal 'null' txnReceipt\n\n    while (!result.receipt || !result.receipt.txnReceipt || result.receipt.txnReceipt === 'null' || result.receipt.status === 'UNKNOWN' || result.receipt.status === 'QUEUED' || result.receipt.status === 'SENT') {\n      await new Promise(r => setTimeout(r, wait));\n      result = await this.service.getMetaTxnReceipt({\n        metaTxID: metaTxnHash\n      });\n    }\n\n    return result;\n  }\n\n  async simulate(wallet, ...transactions) {\n    const coder = ethers.utils.defaultAbiCoder;\n    const encoded = coder.encode([MetaTransactionsType], [sequenceTxAbiEncode(transactions)]);\n    return (await this.service.simulate({\n      wallet,\n      transactions: encoded\n    })).results;\n  }\n\n  async estimateGasLimits(config, context, ...transactions) {\n    logger.info(`[rpc-relayer/estimateGasLimits] estimate gas limits request ${JSON.stringify(transactions)}`);\n\n    if (transactions.length == 0) {\n      return [];\n    }\n\n    const addr = addressOf(config, context);\n    const prevNonce = readSequenceNonce(...transactions); // Set temporal nonce to simulate meta-txn\n\n    if (prevNonce === undefined) {\n      transactions = appendNonce(transactions, await this.getNonce(config, context));\n    }\n\n    const coder = ethers.utils.defaultAbiCoder;\n    const encoded = coder.encode([MetaTransactionsType], [sequenceTxAbiEncode(transactions)]);\n    const res = await this.service.updateMetaTxnGasLimits({\n      walletAddress: addr,\n      walletConfig: {\n        address: addr,\n        signers: config.signers,\n        threshold: config.threshold,\n        chainId: config.chainId\n      },\n      payload: encoded\n    });\n    const decoded = coder.decode([MetaTransactionsType], res.payload)[0];\n    const modTxns = transactions.map((t, i) => _extends({}, t, {\n      gasLimit: decoded[i].gasLimit\n    }));\n    logger.info(`[rpc-relayer/estimateGasLimits] got transactions with gas limits ${JSON.stringify(modTxns)}`); // Remove placeholder nonce if previously defined\n\n    return prevNonce === undefined ? modTxns : appendNonce(modTxns, prevNonce);\n  }\n\n  async getFeeOptions(config, context, ...transactions) {\n    // NOTE/TODO: for a given `service` the feeTokens will not change between execution, so we should memoize this value\n    // for a short-period of time, perhaps for 1 day or in memory. Perhaps one day we can make this happen automatically\n    // with http cache response for this endpoint and service-worker.. lots of approaches\n    const feeTokens = await this.service.feeTokens();\n\n    if (feeTokens.isFeeRequired) {\n      const symbols = feeTokens.tokens.map(token => token.symbol).join(', ');\n      logger.info(`[rpc-relayer/getFeeOptions] relayer fees are required, accepted tokens are ${symbols}`);\n      const wallet = addressOf(config, context);\n      let nonce = readSequenceNonce(...transactions);\n\n      if (nonce === undefined) {\n        nonce = await this.getNonce(config, context);\n      }\n\n      if (!this.provider) {\n        logger.warn(`[rpc-relayer/getFeeOptions] provider not set, needed for stub signature`);\n        throw new Error('provider is not set');\n      }\n\n      const {\n        to,\n        execute\n      } = await this.prependWalletDeploy({\n        config,\n        context,\n        transactions,\n        nonce,\n        signature: buildStubSignature(this.provider, config)\n      });\n      const walletInterface = new ethers.utils.Interface(walletContracts.mainModule.abi);\n      const data = walletInterface.encodeFunctionData(walletInterface.getFunction('execute'), [sequenceTxAbiEncode(execute.transactions), execute.nonce, execute.signature]);\n      const {\n        options,\n        quote\n      } = await this.service.feeOptions({\n        wallet,\n        to,\n        data\n      });\n      logger.info(`[rpc-relayer/getFeeOptions] got refund options ${JSON.stringify(options)}`);\n      return {\n        options,\n        quote: {\n          _tag: 'FeeQuote',\n          _quote: quote\n        }\n      };\n    } else {\n      logger.info(`[rpc-relayer/getFeeOptions] relayer fees are not required`);\n      return {\n        options: []\n      };\n    }\n  }\n\n  async gasRefundOptions(config, context, ...transactions) {\n    const {\n      options\n    } = await this.getFeeOptions(config, context, ...transactions);\n    return options;\n  }\n\n  async getNonce(config, context, space) {\n    const addr = addressOf(config, context);\n    logger.info(`[rpc-relayer/getNonce] get nonce for wallet ${addr} space: ${space}`);\n    const encodedNonce = space !== undefined ? ethers.BigNumber.from(space).toHexString() : undefined;\n    const resp = await this.service.getMetaTxnNonce({\n      walletContractAddress: addr,\n      space: encodedNonce\n    });\n    const nonce = ethers.BigNumber.from(resp.nonce);\n    const [decodedSpace, decodedNonce] = decodeNonce(nonce);\n    logger.info(`[rpc-relayer/getNonce] got next nonce for wallet ${addr} ${decodedNonce} space: ${decodedSpace}`);\n    return nonce;\n  }\n\n  async relay(signedTxs, quote) {\n    logger.info(`[rpc-relayer/relay] relaying signed meta-transactions ${JSON.stringify(signedTxs)} with quote ${JSON.stringify(quote)}`);\n    let typecheckedQuote;\n\n    if (quote !== undefined) {\n      if (typeof quote._quote === 'string') {\n        typecheckedQuote = quote._quote;\n      } else {\n        logger.warn('[rpc-relayer/relay] ignoring invalid fee quote');\n      }\n    }\n\n    if (!this.provider) {\n      logger.warn(`[rpc-relayer/relay] provider not set, failed relay`);\n      throw new Error('provider is not set');\n    }\n\n    const {\n      to: contract,\n      execute\n    } = await this.prependWalletDeploy(signedTxs);\n    const walletAddress = addressOf(signedTxs.config, signedTxs.context);\n    const walletInterface = new ethers.utils.Interface(walletContracts.mainModule.abi);\n    const input = walletInterface.encodeFunctionData(walletInterface.getFunction('execute'), [sequenceTxAbiEncode(execute.transactions), execute.nonce, execute.signature]);\n    const metaTxn = await this.service.sendMetaTxn({\n      call: {\n        walletAddress,\n        contract,\n        input\n      },\n      quote: typecheckedQuote\n    });\n    logger.info(`[rpc-relayer/relay] got relay result ${JSON.stringify(metaTxn)}`);\n    return this.wait(metaTxn.txnHash);\n  }\n\n  async wait(metaTxnHash, wait = 1000) {\n    var _this = this;\n\n    const {\n      receipt\n    } = await this.waitReceipt(metaTxnHash, wait);\n\n    if (!receipt.txnReceipt || FAILED_STATUSES.includes(receipt.status)) {\n      throw new MetaTransactionResponseException(receipt);\n    }\n\n    const txReceipt = JSON.parse(receipt.txnReceipt);\n    return {\n      blockHash: txReceipt.blockHash,\n      blockNumber: ethers.BigNumber.from(txReceipt.blockNumber).toNumber(),\n      confirmations: 1,\n      from: typeof metaTxnHash === 'string' ? undefined : addressOf(metaTxnHash.config, metaTxnHash.context),\n      hash: txReceipt.transactionHash,\n      raw: receipt.txnReceipt,\n      receipt: txReceipt,\n      // extended type which is Sequence-specific. Contains the decoded metaTxReceipt\n      wait: async function (confirmations) {\n        return _this.provider.waitForTransaction(txReceipt.transactionHash, confirmations);\n      }\n    };\n  }\n\n}\n\nclass MetaTransactionResponseException {\n  constructor(receipt) {\n    this.receipt = receipt;\n  }\n\n}\n\nfunction isRelayer(cand) {\n  return typeof cand === 'object' && typeof cand.simulate === 'function' && typeof cand.estimateGasLimits === 'function' && typeof cand.getFeeOptions === 'function' && typeof cand.gasRefundOptions === 'function' && typeof cand.getNonce === 'function' && typeof cand.relay === 'function' && typeof cand.wait === 'function';\n}\n\nexport { BaseRelayer, BaseRelayerDefaults, LocalRelayer, ProviderRelayer, ProviderRelayerDefaults, RpcRelayer, relayer_gen as RpcRelayerProto, isBaseRelayerOptions, isLocalRelayerOptions, isProviderRelayerOptions, isRelayer, isRpcRelayerOptions, relayer_gen as proto };\n","import { Signer as Signer$1, ethers, BigNumber, Contract } from 'ethers';\nimport { decodeNonce, computeMetaTxnHash, fromTransactionish, readSequenceNonce, appendNonce, digestOfTransactionsNonce, sequenceTxAbiEncode } from '@0xsequence/transactions';\nimport { isUsableConfig, sortConfig, addressOf, imageHash, isDecodedSigner, encodeSignature, joinSignatures, compareAddr, decodeSignature, isDecodedFullSigner, recoverEOASigner, SequenceUtilsFinder, isConfigEqual, isDecodedEOASigner, isDecodedAddress } from '@0xsequence/config';\nimport { ChainId, sequenceContext, isJsonRpcProvider, JsonRpcSender, getChainId, mainnetNetworks, ensureValidNetworks, sortNetworks } from '@0xsequence/network';\nimport { Provider, JsonRpcProvider } from '@ethersproject/providers';\nimport { Interface } from '@ethersproject/abi';\nimport { walletContracts } from '@0xsequence/abi';\nimport { encodeTypedDataDigest, subDigestOf, packMessageData } from '@0xsequence/utils';\nimport fetchPonyfill from 'fetch-ponyfill';\nimport { GuarddService } from '@0xsequence/guard';\nimport { resolveProperties } from '@ethersproject/properties';\nimport { isRelayer, isRpcRelayerOptions, RpcRelayer } from '@0xsequence/relayer';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nclass Signer extends Signer$1 {\n  static isSequenceSigner(cand) {\n    return isSequenceSigner(cand);\n  }\n\n}\nfunction isSequenceSigner(signer) {\n  const cand = signer;\n  return cand && cand.updateConfig !== undefined && cand.publishConfig !== undefined && cand.getWalletContext !== undefined && cand.getWalletConfig !== undefined;\n} // TODO: move to error.ts, along with others..\n\nclass InvalidSigner extends Error {}\nclass NotEnoughSigners extends Error {}\n\nclass RemoteSigner extends Signer$1 {\n  signMessage(message, chainId) {\n    return this.signMessageWithData(message);\n  }\n\n  sendTransaction(_) {\n    throw new Error('sendTransaction method is not supported in RemoteSigner');\n  }\n\n  signTransaction(_) {\n    throw new Error('signTransaction method is not supported in RemoteSigner');\n  }\n\n  connect(_) {\n    throw new Error('connect method is not supported in RemoteSigner');\n  }\n\n  static signMessageWithData(signer, message, data, chainId) {\n    if (this.isRemoteSigner(signer)) {\n      return signer.signMessageWithData(message, data, chainId);\n    }\n\n    return signer.signMessage(message);\n  }\n\n  static isRemoteSigner(signer) {\n    return signer.signMessageWithData !== undefined;\n  }\n\n}\n\nclass GuardRemoteSigner extends RemoteSigner {\n  constructor(address, hostname, isSequence = false, defaultChainId = ChainId.MAINNET) {\n    super();\n    this.isSequence = isSequence;\n    this.defaultChainId = defaultChainId;\n    this._guardd = void 0;\n    this._address = void 0;\n    this._guardd = new GuarddService(hostname, fetchPonyfill().fetch);\n    this._address = address;\n  }\n\n  async signMessageWithData(message, auxData, chainId) {\n    const request = {\n      msg: ethers.utils.hexlify(message),\n      auxData: ethers.utils.hexlify(auxData ? auxData : []),\n      chainId: chainId ? BigNumber.from(chainId).toNumber() : this.defaultChainId\n    };\n    const res = await this._guardd.sign({\n      request: request\n    }); // TODO: The guardd service doesn't include the EIP2126 signature type on it's reponse\n    // maybe it should be more explicit and include it? the EIP2126 is only required for non-sequence signatures\n\n    return this.isSequence ? res.sig : res.sig + '02';\n  }\n\n  async getAddress() {\n    return this._address;\n  }\n\n}\n\nclass LocalRemoteSigner extends RemoteSigner {\n  constructor(signer) {\n    super();\n    this._signer = void 0;\n    this._signer = signer;\n  }\n\n  signMessageWithData(message, _) {\n    return this._signer.signMessage(message);\n  }\n\n  getAddress() {\n    return this._signer.getAddress();\n  }\n\n}\n\nasync function resolveArrayProperties(object) {\n  if (Array.isArray(object)) {\n    // T must include array type\n    return Promise.all(object.map(o => resolveProperties(o)));\n  }\n\n  return resolveProperties(object);\n}\nasync function findLatestLog(provider, filter) {\n  const toBlock = filter.toBlock === 'latest' ? await provider.getBlockNumber() : filter.toBlock;\n  const fromBlock = filter.fromBlock;\n\n  try {\n    const logs = await provider.getLogs(_extends({}, filter, {\n      toBlock: toBlock\n    }));\n    return logs.length === 0 ? undefined : logs[logs.length - 1];\n  } catch (e) {\n    // TODO Don't assume all errors are bad\n    const pivot = Math.floor((toBlock - fromBlock) / 2 + fromBlock);\n    const nhalf = await findLatestLog(provider, _extends({}, filter, {\n      fromBlock: pivot,\n      toBlock: toBlock\n    }));\n    if (nhalf !== undefined) return nhalf;\n    return findLatestLog(provider, _extends({}, filter, {\n      fromBlock: fromBlock,\n      toBlock: pivot\n    }));\n  }\n}\n\n//\n// Wallet allows managing the account/wallet sub-keys, wallet address, signing\n// messages, signing transactions and updating/deploying the wallet config on a specific chain.\n//\n// Wallet instances represent a wallet at a particular config-state, in someways, the Wallet\n// instance is immutable, and if you update the config, then you'll need to call useConfig()\n// to instantiate a new Wallet instance with the updated config.\n\nclass Wallet extends Signer {\n  // provider is an Ethereum Json RPC provider that is connected to a particular network (aka chain)\n  // and access to the signer for signing transactions.\n  // sender is a minimal Json RPC sender interface. It's here for convenience for other web3\n  // interfaces to use.\n  // relayer dispatches transactions to an Ethereum node directly\n  // or through a remote transaction Web Service.\n  // chainId is the node network id, used for memoization\n  constructor(options, ...signers) {\n    super();\n    this.context = void 0;\n    this.config = void 0;\n    this._signers = void 0;\n    this.provider = void 0;\n    this.sender = void 0;\n    this.relayer = void 0;\n    this.chainId = void 0;\n    const {\n      config,\n      context,\n      strict\n    } = options;\n\n    if (context) {\n      this.context = _extends({}, context);\n    } else {\n      // default context is to use @0xsequence/network deployed context\n      this.context = _extends({}, sequenceContext);\n    }\n\n    if (strict === true) {\n      this.context.nonStrict = undefined;\n    } else if (strict === false) {\n      this.context.nonStrict = true;\n    }\n\n    if (!this.context.nonStrict && !isUsableConfig(config)) {\n      throw new Error('wallet config is not usable (strict mode)');\n    }\n\n    this.config = sortConfig(config);\n    this._signers = signers.map(s => Signer$1.isSigner(s) ? s : new ethers.Wallet(s)); // cache wallet config for future imageHash lookups\n\n    this.imageHash;\n  } // useConfig creates a new Wallet instance with the provided config, and uses the current provider\n  // and relayer. It's common to initialize a counter-factual / undeployed wallet by initializing\n  // it with the Wallet's init config, then calling useConfig() with the most-up-to-date config,\n  // ie. new Wallet({ config: initConfig }).useConfig(latestConfig).useSigners(signers)\n\n\n  useConfig(config, strict) {\n    return new Wallet({\n      config,\n      context: this.context,\n      strict\n    }, ...this._signers).setProvider(this.provider).setRelayer(this.relayer);\n  }\n\n  useSigners(...signers) {\n    return new Wallet({\n      config: this.config,\n      context: this.context\n    }, ...signers).setProvider(this.provider).setRelayer(this.relayer);\n  } // connect is a short-hand to create an Account instance and set the provider and relayer.\n  //\n  // The connect method is defined on the AbstractSigner as connect(Provider): AbstractSigner\n\n\n  connect(provider, relayer) {\n    if (isJsonRpcProvider(provider)) {\n      return new Wallet({\n        config: this.config,\n        context: this.context\n      }, ...this._signers).setProvider(provider).setRelayer(relayer);\n    } else {\n      throw new Error('Wallet provider argument is expected to be a JsonRpcProvider');\n    }\n  } // setProvider assigns a json-rpc provider to this wallet instance\n\n\n  setProvider(provider) {\n    if (provider === undefined) return this;\n\n    if (Provider.isProvider(provider)) {\n      this.provider = provider;\n      this.sender = new JsonRpcSender(provider);\n    } else {\n      const jsonProvider = new JsonRpcProvider(provider);\n      this.provider = jsonProvider;\n      this.sender = new JsonRpcSender(jsonProvider);\n    }\n\n    this.chainId = undefined; // reset chainId value\n\n    return this;\n  } // setRelayer assigns a Sequence transaction relayer to this wallet instance\n\n\n  setRelayer(relayer) {\n    if (relayer === undefined) return this;\n    this.relayer = relayer;\n    return this;\n  }\n\n  async getProvider(chainId) {\n    if (chainId) await this.getChainIdNumber(chainId);\n    return this.provider;\n  }\n\n  async getRelayer(chainId) {\n    if (chainId) await this.getChainIdNumber(chainId);\n    return this.relayer;\n  }\n\n  async getWalletContext() {\n    return this.context;\n  }\n\n  async getWalletConfig(chainId) {\n    chainId = await this.getChainIdNumber(chainId);\n\n    const config = _extends({}, this.config, {\n      chainId\n    });\n\n    return [config];\n  }\n\n  async getWalletState(_) {\n    const [address, chainId, isDeployed] = await Promise.all([this.getAddress(), this.getChainId(), this.isDeployed()]);\n    const state = {\n      context: this.context,\n      config: this.config,\n      address: address,\n      chainId: chainId,\n      deployed: isDeployed,\n      imageHash: this.imageHash,\n      lastImageHash: isDeployed ? await fetchImageHash(this) : undefined\n    }; // TODO: set published boolean by checking if we have the latest logs\n    // that compute to the same hash as in lastImageHash\n\n    return [state];\n  } // connected reports if json-rpc provider has been connected\n\n\n  get connected() {\n    return this.sender !== undefined;\n  } // address returns the address of the wallet account address\n\n\n  get address() {\n    return addressOf(this.config, this.context);\n  } // imageHash is the unique hash of the WalletConfig\n\n\n  get imageHash() {\n    return imageHash(this.config);\n  } // getAddress returns the address of the wallet account address\n  //\n  // The getAddress method is defined on the AbstractSigner\n\n\n  async getAddress() {\n    return this.address;\n  } // getSigners returns the list of public account addresses to the currently connected\n  // signer objects for this wallet. Note: for a complete list of configured signers\n  // on the wallet, query getWalletConfig()\n\n\n  async getSigners() {\n    if (!this._signers || this._signers.length === 0) {\n      return [];\n    }\n\n    return Promise.all(this._signers.map(s => s.getAddress().then(s => ethers.utils.getAddress(s))));\n  } // chainId returns the network connected to this wallet instance\n\n\n  async getChainId() {\n    if (this.chainId) return this.chainId;\n\n    if (!this.provider) {\n      throw new Error('provider is not set, first connect a provider');\n    }\n\n    this.chainId = (await this.provider.getNetwork()).chainId;\n    return this.chainId;\n  }\n\n  async getNetworks() {\n    const chainId = await this.getChainId();\n    return [{\n      chainId: chainId,\n      name: '',\n      rpcUrl: ''\n    }];\n  } // getNonce returns the transaction nonce for this wallet, via the relayer\n\n\n  async getNonce(blockTag, space) {\n    return this.relayer.getNonce(this.config, this.context, space, blockTag);\n  } // getTransactionCount returns the number of transactions (aka nonce)\n  //\n  // getTransactionCount method is defined on the AbstractSigner\n\n\n  async getTransactionCount(blockTag) {\n    const encodedNonce = await this.getNonce(blockTag, 0);\n    const [_, decodedNonce] = decodeNonce(encodedNonce);\n    return ethers.BigNumber.from(decodedNonce).toNumber();\n  } // sendTransaction will dispatch the transaction to the relayer for submission to the network.\n\n\n  async sendTransaction(transaction, chainId, allSigners, quote, callback) {\n    const signedTxs = await this.signTransactions(transaction, chainId, allSigners);\n\n    if (callback) {\n      const address = addressOf(signedTxs.config, signedTxs.context);\n      const metaTxnHash = computeMetaTxnHash(address, signedTxs.chainId, ...signedTxs.transactions);\n      callback(signedTxs, metaTxnHash);\n    }\n\n    return this.relayer.relay(signedTxs, quote);\n  } // sendTransactionBatch is a sugar for better readability, but is the same as sendTransaction\n\n\n  async sendTransactionBatch(transactions, chainId, allSigners = true, quote, callback) {\n    return this.sendTransaction(transactions, chainId, allSigners, quote, callback);\n  } // signTransactions will sign a Sequence transaction with the wallet signers\n  //\n  // NOTE: the txs argument of type Transactionish can accept one or many transactions.\n\n\n  async signTransactions(txs, chainId, allSigners) {\n    const signChainId = await this.getChainIdNumber(chainId);\n    const transaction = await resolveArrayProperties(txs);\n\n    if (!this.provider) {\n      throw new Error('missing provider');\n    }\n\n    if (!this.relayer) {\n      throw new Error('missing relayer');\n    } // Convert Transactionish into Sequence transactions\n\n\n    let stx = await fromTransactionish(this.context, this.address, transaction); // If a transaction has 0 gasLimit and not revertOnError\n    // compute all new gas limits\n\n    if (stx.find(a => !a.revertOnError && ethers.BigNumber.from(a.gasLimit || 0).eq(ethers.constants.Zero))) {\n      stx = await this.relayer.estimateGasLimits(this.config, this.context, ...stx);\n    } // If provided nonce append it to all other transactions\n    // otherwise get next nonce for this wallet\n\n\n    const providedNonce = readSequenceNonce(...stx);\n    const nonce = providedNonce ? providedNonce : await this.getNonce();\n    stx = appendNonce(stx, nonce); // Get transactions digest\n\n    const digest = digestOfTransactionsNonce(nonce, ...stx); // Bundle with signature\n\n    return {\n      digest: digest,\n      chainId: signChainId,\n      context: this.context,\n      config: this.config,\n      transactions: stx,\n      nonce,\n      signature: await this.sign(digest, true, chainId, allSigners)\n    };\n  }\n\n  async sendSignedTransactions(signedTxs, chainId, quote) {\n    if (!this.relayer) {\n      throw new Error('relayer is not set, first connect a relayer');\n    }\n\n    await this.getChainIdNumber(chainId);\n    return this.relayer.relay(signedTxs, quote);\n  } // signMessage will sign a message for a particular chainId with the wallet signers\n  //\n  // NOTE: signMessage(message: Bytes | string): Promise<string> is defined on AbstractSigner\n\n\n  async signMessage(message, chainId, allSigners, isDigest = false) {\n    const data = typeof message === 'string' && !message.startsWith('0x') ? ethers.utils.toUtf8Bytes(message) : message;\n    return this.sign(data, isDigest, chainId, allSigners);\n  }\n\n  async signTypedData(domain, types, message, chainId, allSigners) {\n    const signChainId = await this.getChainIdNumber(chainId);\n    const domainChainId = domain.chainId ? BigNumber.from(domain.chainId).toNumber() : undefined;\n\n    if (domainChainId && domainChainId !== signChainId) {\n      throw new Error(`signTypedData: domain.chainId (${domain.chainId}) is expected to be ${signChainId}`);\n    }\n\n    const hash = encodeTypedDataDigest({\n      domain,\n      types,\n      message\n    });\n    return this.sign(hash, true, signChainId, allSigners);\n  }\n\n  async _signTypedData(domain, types, message, chainId, allSigners) {\n    return this.signTypedData(domain, types, message, chainId, allSigners);\n  }\n\n  async subDigest(digest, chainId) {\n    const solvedChainId = await this.getChainIdNumber(chainId);\n    return ethers.utils.arrayify(subDigestOf(this.address, solvedChainId, digest));\n  } // sign is a helper method to sign a payload with the wallet signers\n\n\n  async sign(msg, isDigest = true, chainId, allSigners) {\n    var _this = this;\n\n    const signChainId = await this.getChainIdNumber(chainId);\n    const digest = isDigest ? msg : ethers.utils.keccak256(msg); // Generate sub-digest\n\n    const subDigest = await this.subDigest(digest, chainId); // Sign sub-digest using a set of signers and some optional data\n\n    const signWith = async function signWith(signers, auxData) {\n      const signersAddr = await Promise.all(signers.map(s => s.getAddress()));\n      const parts = await Promise.all(_this.config.signers.map(async function (s) {\n        try {\n          const signer = signers[signersAddr.indexOf(s.address)]; // Is not a signer, return config entry as-is\n\n          if (!signer) {\n            return s;\n          } // Is another Sequence wallet as signer, sign and append '03' (ERC1271 type)\n\n\n          if (isSequenceSigner(signer)) {\n            if (signer === _this) throw Error(\"Can't sign transactions for self\");\n            const signature = (await signer.signMessage(subDigest, signChainId, allSigners, true)) + '03';\n            return _extends({}, s, {\n              signature: signature\n            });\n          } // Is remote signer, call and deduce signature type\n\n\n          if (RemoteSigner.isRemoteSigner(signer)) {\n            const signature = await signer.signMessageWithData(subDigest, auxData, signChainId);\n\n            try {\n              // Check if signature can be recovered as EOA signature\n              const isEOASignature = recoverEOASigner(subDigest, {\n                weight: s.weight,\n                signature: signature\n              }) === s.address;\n\n              if (isEOASignature) {\n                // Exclude address on EOA signatures\n                return {\n                  weight: s.weight,\n                  signature: signature\n                };\n              }\n            } catch (_unused) {} // Prepare signature for full encoding\n\n\n            return _extends({}, s, {\n              signature: signature\n            });\n          } // Is EOA signer\n\n\n          return {\n            weight: s.weight,\n            signature: (await signer.signMessage(subDigest)) + '02'\n          };\n        } catch (err) {\n          if (allSigners) {\n            throw err;\n          } else {\n            console.warn(`Skipped signer ${s.address}`);\n            return s;\n          }\n        }\n      }));\n      return {\n        threshold: _this.config.threshold,\n        signers: parts\n      };\n    }; // Sign message first using localSigners\n\n\n    const localSigners = this._signers.filter(s => !RemoteSigner.isRemoteSigner(s));\n\n    const localSignature = await signWith(localSigners, this.packMsgAndSig(digest, [], signChainId)); // Skip remote signers if we already meet threshold\n\n    const totalWeight = localSignature.signers.filter(isDecodedSigner).reduce((totalWeight, signer) => totalWeight + signer.weight, 0);\n\n    if (totalWeight >= this.config.threshold) {\n      return encodeSignature(localSignature);\n    } // include local signatures for remote signers\n\n\n    const remoteSigners = this._signers.filter(s => RemoteSigner.isRemoteSigner(s));\n\n    const remoteSignature = await signWith(remoteSigners, this.packMsgAndSig(digest, encodeSignature(localSignature), signChainId)); // Aggregate both local and remote signatures\n\n    return encodeSignature(joinSignatures(localSignature, remoteSignature));\n  } // signWeight will return the total weight of all signers available based on the config\n\n\n  async signWeight() {\n    const signers = await this.getSigners();\n    return signers.reduce((p, s) => {\n      const sconfig = this.config.signers.find(c => c.address === s);\n      if (!sconfig) return p;\n      return p.add(sconfig.weight);\n    }, ethers.constants.Zero);\n  }\n\n  async isDeployed(chainId) {\n    await this.getChainIdNumber(chainId);\n    const walletCode = await this.provider.getCode(this.address);\n    return !!walletCode && walletCode !== '0x';\n  } // updateConfig will build an updated config transaction and send it to the Ethereum\n  // network via the relayer. Note, the updated wallet config is stored as an image hash,\n  // unlike `publishConfig` which will store the entire WalletConfig object in logs.\n\n\n  async updateConfig(config, nonce, publish = false, indexed, quote, callback) {\n    if (!config) config = this.config;\n    const [txs, n] = await Promise.all([this.buildUpdateConfigTransaction(config, publish, indexed), nonce != null ? nonce : this.getNonce()]);\n    return [_extends({\n      address: this.address\n    }, config), await this.sendTransaction(appendNonce(txs, n), undefined, undefined, quote, callback)];\n  } // publishConfig will publish the current wallet config to the network via the relayer.\n  // Publishing the config will also store the entire object of signers.\n\n\n  async publishConfig(indexed, nonce, requireFreshSigners = [], quote, callback) {\n    return this.sendTransaction(this.config.address ? this.buildPublishConfigTransaction(this.config, indexed, nonce) : await this.buildPublishSignersTransaction(indexed, nonce, requireFreshSigners), undefined, undefined, quote, callback);\n  } // buildUpdateConfigTransaction creates a transaction to update the imageHash of the wallet's config\n  // on chain. Note, the transaction is not sent to the network by this method.\n  //\n  // The `publish` argument when true will also store the contents of the WalletConfig to a chain's logs.\n\n\n  async buildUpdateConfigTransaction(config, publish = false, indexed) {\n    var _this2 = this;\n\n    if (!this.context.nonStrict && !isUsableConfig(config)) throw new Error('wallet config is not usable (strict mode)');\n    const isUpgradable = await async function () {\n      try {\n        const implementation = await _this2.provider.getStorageAt(_this2.address, ethers.utils.defaultAbiCoder.encode(['address'], [_this2.address]));\n        return compareAddr(implementation, _this2.context.mainModuleUpgradable) === 0;\n      } catch (_unused2) {\n        return false;\n      }\n    }();\n    const walletInterface = new Interface(walletContracts.mainModule.abi); // empirically, this seems to work for the tests:\n    // const gasLimit = 100000 + 1800 * config.signers.length\n    //\n    // but we're going to play it safe with this instead:\n\n    const gasLimit = 2 * (100000 + 1800 * config.signers.length);\n    const preTransaction = isUpgradable ? [] : [{\n      delegateCall: false,\n      revertOnError: true,\n      gasLimit: ethers.constants.Zero,\n      to: this.address,\n      value: ethers.constants.Zero,\n      data: walletInterface.encodeFunctionData(walletInterface.getFunction('updateImplementation'), [this.context.mainModuleUpgradable])\n    }];\n    const mainModuleInterface = new Interface(walletContracts.mainModuleUpgradable.abi);\n    const transaction = {\n      delegateCall: false,\n      revertOnError: true,\n      gasLimit: ethers.constants.Zero,\n      to: this.address,\n      value: ethers.constants.Zero,\n      data: mainModuleInterface.encodeFunctionData(mainModuleInterface.getFunction('updateImageHash'), [imageHash(config)])\n    };\n    const postTransaction = publish ? await this.buildPublishConfigTransaction(config, indexed) : [];\n    const transactions = [...preTransaction, transaction, ...postTransaction]; // If update config reguires a single transaction\n    // skip nested selfExecute bundle\n\n    if (transactions.length === 1) {\n      return transactions;\n    }\n\n    return [{\n      delegateCall: false,\n      revertOnError: false,\n      gasLimit: gasLimit,\n      to: this.address,\n      value: ethers.constants.Zero,\n      data: walletInterface.encodeFunctionData(walletInterface.getFunction('selfExecute'), [sequenceTxAbiEncode(transactions)])\n    }];\n  }\n\n  buildPublishConfigTransaction(config, indexed = true, nonce) {\n    const sequenceUtilsInterface = new Interface(walletContracts.sequenceUtils.abi);\n    return [{\n      delegateCall: false,\n      revertOnError: true,\n      gasLimit: ethers.constants.Zero,\n      to: this.context.sequenceUtils,\n      value: ethers.constants.Zero,\n      nonce: nonce,\n      data: sequenceUtilsInterface.encodeFunctionData(sequenceUtilsInterface.getFunction('publishConfig'), [this.address, config.threshold, sortConfig(config).signers.map(s => ({\n        weight: s.weight,\n        signer: s.address\n      })), indexed])\n    }];\n  }\n\n  async buildPublishSignersTransaction(indexed = true, nonce, requireFreshSigners = []) {\n    var _this$context$libs;\n\n    const sequenceUtilsInterface = new Interface(walletContracts.sequenceUtils.abi);\n    const requireFreshSignersInterface = new Interface(walletContracts.requireFreshSigner.abi);\n    const message = ethers.utils.randomBytes(32);\n    const signature = await this.signMessage(message, this.chainId, false); // TODO: This is only required because RequireUtils doesn't support dynamic signatures\n    // remove this filtering of dynamic once a new version of RequireUtils is deployed\n\n    const decodedSignature = decodeSignature(signature);\n    const filteredSignature = encodeSignature({\n      threshold: decodedSignature.threshold,\n      signers: decodedSignature.signers.map((s, i) => {\n        if (isDecodedFullSigner(s)) {\n          const a = this.config.signers[i];\n          return {\n            weight: a.weight,\n            address: a.address\n          };\n        }\n\n        return s;\n      })\n    });\n    const contextRequireFreshSigner = (_this$context$libs = this.context.libs) == null ? void 0 : _this$context$libs.requireFreshSigner;\n\n    if (requireFreshSigners.length > 0 && contextRequireFreshSigner === undefined) {\n      throw Error('requireFreshSigners missing library');\n    }\n\n    return [...requireFreshSigners.map(signer => ({\n      delegateCall: false,\n      revertOnError: true,\n      gasLimit: ethers.constants.Zero,\n      to: contextRequireFreshSigner,\n      value: ethers.constants.Zero,\n      nonce: nonce,\n      data: requireFreshSignersInterface.encodeFunctionData(requireFreshSignersInterface.getFunction('requireFreshSigner'), [signer])\n    })), {\n      delegateCall: false,\n      revertOnError: true,\n      gasLimit: ethers.constants.Zero,\n      to: this.context.sequenceUtils,\n      value: ethers.constants.Zero,\n      nonce: nonce,\n      data: sequenceUtilsInterface.encodeFunctionData(sequenceUtilsInterface.getFunction('publishInitialSigners'), [this.address, ethers.utils.keccak256(message), this.config.signers.length, filteredSignature, indexed])\n    }];\n  } // getChainIdFromArgument will return the chainId of the argument, as well as ensure\n  // we're not providing an invalid chainId that isn't connected to this wallet.\n\n\n  async getChainIdNumber(chainId) {\n    if (!chainId) {\n      // it's valid for chainId argument to be undefined, in which case\n      // we will use the connected value\n      return await this.getChainId();\n    }\n\n    const id = getChainId(chainId);\n\n    if (this.context.nonStrict) {\n      // in non-strict mode, just return the chainId from argument\n      return id;\n    }\n\n    const connectedChainId = await this.getChainId();\n\n    if (connectedChainId !== id) {\n      throw new Error(`the specified chainId ${id} does not match the wallet's connected chainId ${connectedChainId}`);\n    }\n\n    return connectedChainId;\n  } // packMsgAndSig is used by RemoteSigners to include details as a string blob of data.\n\n\n  packMsgAndSig(msg, sig, chainId) {\n    return ethers.utils.defaultAbiCoder.encode(['address', 'uint256', 'bytes', 'bytes'], [this.address, chainId, msg, sig]);\n  }\n\n  signTransaction(_) {\n    throw new Error('signTransaction method is not supported in Wallet, please use signTransactions(...)');\n  } // singleOwner will create a Wallet instance with a single signer (ie. from a single EOA account)\n\n\n  static async singleOwner(owner, context) {\n    const signer = Signer$1.isSigner(owner) ? owner : new ethers.Wallet(owner);\n    const config = {\n      threshold: 1,\n      signers: [{\n        weight: 1,\n        address: ethers.utils.getAddress(await signer.getAddress())\n      }]\n    };\n    return new Wallet({\n      config,\n      context\n    }, signer);\n  }\n\n  async hasEnoughSigners(chainId) {\n    if (chainId) await this.getChainIdNumber(chainId);\n    return (await this.signWeight()).gte(this.config.threshold);\n  }\n\n}\n\n// Account is an interface to a multi-network smart contract wallet.\nclass Account extends Signer {\n  // provider points at the main chain for compatability with the Signer.\n  // Use getProvider(chainId) to get the provider for the respective network.\n  // memoized value\n  constructor(options, ...signers) {\n    super();\n    this.options = void 0;\n    this._wallets = void 0;\n    this._signers = void 0;\n    this.provider = void 0;\n    this._chainId = void 0;\n    this.options = options;\n    this._signers = signers; // Use deployed wallet context by default if not provided\n\n    if (!options.context) this.options.context = _extends({}, sequenceContext); // Network config, defaults will be used if none are provided\n\n    if (this.options.networks) {\n      this.setNetworks(this.options.networks);\n    } else {\n      this.setNetworks([...mainnetNetworks]);\n    }\n  }\n\n  useSigners(...signers) {\n    this._signers = signers;\n\n    this._wallets.forEach(w => {\n      w.wallet = w.wallet.useSigners(...signers);\n    });\n\n    return this;\n  }\n\n  async getWalletContext() {\n    return this.options.context;\n  }\n\n  getConfigFinder() {\n    if (this.options.configFinder) return this.options.configFinder;\n    return new SequenceUtilsFinder(this.authWallet().wallet.provider);\n  } // getWalletConfig builds a list of WalletConfigs across all networks.\n  // This is useful to shows all keys/devices connected to a wallet across networks.\n\n\n  async getWalletConfig(chainId) {\n    let wallets = [];\n\n    if (chainId) {\n      const v = this.getWalletByNetwork(chainId);\n\n      if (v) {\n        wallets.push(v);\n      }\n    } else {\n      wallets = this._wallets;\n    }\n\n    return (await Promise.all(wallets.map(w => w.wallet.getWalletConfig()))).flat();\n  }\n\n  async getWalletState(chainId) {\n    let wallets = [];\n\n    if (chainId) {\n      const v = this.getWalletByNetwork(chainId);\n\n      if (v) {\n        wallets.push(v);\n      }\n    } else {\n      wallets = this._wallets;\n    }\n\n    const configsPromise = Promise.all(wallets.map(w => this.getConfigFinder().findCurrentConfig({\n      address: w.wallet.address,\n      provider: w.wallet.provider,\n      context: w.wallet.context,\n      knownConfigs: [w.wallet.config]\n    })));\n    const states = (await Promise.all(wallets.map(w => w.wallet.getWalletState()))).flat(); // fetch the current config for the AuthChain, as it will be available\n\n    const idx = states.findIndex(s => s.chainId === this.getAuthChainId());\n\n    if (idx >= 0) {\n      states[idx].config = await this.currentConfig(wallets[idx].wallet);\n    }\n\n    const configs = await configsPromise;\n    return states.map((s, i) => {\n      var _configs$i;\n\n      return _extends({}, s, {\n        config: (_configs$i = configs[i]) == null ? void 0 : _configs$i.config\n      });\n    });\n  } // address getter\n\n\n  get address() {\n    return this._wallets[0].wallet.address;\n  } // getAddress returns the address of the wallet -- note the account address is the same\n  // across all wallets on all different networks\n\n\n  getAddress() {\n    return this._wallets[0].wallet.getAddress();\n  } // getSigners returns the multi-sig signers with permission to control the wallet\n\n\n  async getSigners() {\n    return this._wallets[0].wallet.getSigners();\n  }\n\n  async getProvider(chainId) {\n    var _this$mainWallet, _this$_wallets$find;\n\n    if (!chainId) return (_this$mainWallet = this.mainWallet()) == null ? void 0 : _this$mainWallet.wallet.getProvider();\n    return (_this$_wallets$find = this._wallets.find(w => w.network.chainId === chainId)) == null ? void 0 : _this$_wallets$find.wallet.getProvider();\n  }\n\n  async getRelayer(chainId) {\n    var _this$mainWallet2, _this$_wallets$find2;\n\n    if (!chainId) return (_this$mainWallet2 = this.mainWallet()) == null ? void 0 : _this$mainWallet2.wallet.getRelayer();\n    return (_this$_wallets$find2 = this._wallets.find(w => w.network.chainId === chainId)) == null ? void 0 : _this$_wallets$find2.wallet.getRelayer();\n  }\n\n  async getNetworks() {\n    return this.options.networks;\n  } // NOTE: this is copied over on top of ethers, and is memoized\n\n\n  async getChainId() {\n    if (this._chainId) return this._chainId;\n    const network = await this.provider.getNetwork();\n    this._chainId = network.chainId;\n    return this._chainId;\n  }\n\n  getAuthChainId() {\n    try {\n      return this.options.networks.find(network => network.isAuthChain).chainId;\n    } catch (_unused) {\n      throw new Error('no auth network');\n    }\n  }\n\n  async signMessage(message, target, allSigners = true, isDigest = false) {\n    var _this = this;\n\n    let {\n      wallet\n    } = await async function () {\n      // eslint-disable-line\n      if (!target) {\n        return _this.mainWallet();\n      }\n\n      if (target.address) {\n        const chainId = await target.getChainId();\n        return _this.getWalletByNetwork(chainId);\n      }\n\n      return _this.getWalletByNetwork(target);\n    }(); // Fetch the latest config of the wallet.\n    //\n    // We skip this step if wallet is authWallet. The assumption is that authWallet\n    // will already have the latest config, but lets confirm that.\n    // TODO: instead, memoize the currentConfig, as below will break\n    // if we skip\n    // if (!network.isAuthChain) {\n\n    let thisConfig = await this.currentConfig(wallet);\n    thisConfig = thisConfig ? thisConfig : this._wallets[0].wallet.config;\n    wallet = wallet.useConfig(thisConfig); // }\n    // See if wallet and available signers set has enough signer power,\n    // but if allSigners is false, we allow partial signing\n\n    const weight = await wallet.signWeight();\n\n    if (weight.lt(wallet.config.threshold) && allSigners !== false) {\n      throw new NotEnoughSigners(`Sign message - wallet combined weight ${weight.toString()} below required ${wallet.config.threshold.toString()}`);\n    }\n\n    return wallet.signMessage(message, undefined, allSigners, isDigest);\n  } // TODO: should allSigners default to false here..?\n\n\n  async signAuthMessage(message, allSigners = true, isDigest = false) {\n    var _this$authWallet;\n\n    return this.signMessage(message, (_this$authWallet = this.authWallet()) == null ? void 0 : _this$authWallet.wallet, allSigners, isDigest);\n  }\n\n  async signTypedData(domain, types, message, chainId, allSigners = true) {\n    const wallet = chainId ? this.getWalletByNetwork(chainId).wallet : this.mainWallet().wallet;\n    const digest = encodeTypedDataDigest({\n      domain,\n      types,\n      message\n    });\n    return this.signMessage(digest, wallet, allSigners, true);\n  }\n\n  async _signTypedData(domain, types, message, chainId, allSigners = true) {\n    return this.signTypedData(domain, types, message, chainId, allSigners);\n  }\n\n  async hasEnoughSigners(chainId) {\n    const wallet = chainId ? this.getWalletByNetwork(chainId).wallet : this.mainWallet().wallet;\n    const thisConfig = await this.currentConfig(wallet);\n    return wallet.useConfig(thisConfig).hasEnoughSigners();\n  }\n\n  async getFeeOptions(transaction, chainId, allSigners = true) {\n    const wallet = chainId ? this.getWalletByNetwork(chainId).wallet : this.mainWallet().wallet;\n    const context = this.options.context;\n\n    if (!context) {\n      throw new Error(`missing wallet context`);\n    } // TODO: can we avoid calling `this.currentConfig(wallet)` everytime here.. this is an expensive\n    // operations and we shouldn't be doing it so liberally. What is the minimum information we require here..?\n    // and what is the config used for, and how can we optimize..?\n    // TODO: prependConfigUpdate also looks like its calling currentConfig() again, so we're doubling this.\n    // A few thoughts.. first off, we must add some kind of memoization for this, but with great care, because\n    // the config might change. This make me think we need some king of \"ConfigSource\" class, or \"ConfigXXX\" (name?),\n    // which we can ask to give us a wallet config. This config would also be used when we update/change a config,\n    // such that it can memoize, but also since its the sole interface, it will also properly expire or update the config\n    // in cache as necessary. Further to this, I think we need to only get config details for what is required, and try\n    // to optimize by using imageHashes of the config everywhere, as this is a much more inexpensive value to fetch.\n\n\n    const [config, updatedTransaction] = await Promise.all([this.currentConfig(wallet), this.prependConfigUpdate(transaction, chainId, allSigners, true)]);\n\n    if (!config) {\n      throw new Error(`missing current config for chain ${chainId}`);\n    }\n\n    const finalTransactions = await fromTransactionish(context, this.address, updatedTransaction);\n    return wallet.relayer.getFeeOptions(config, context, ...finalTransactions);\n  }\n\n  async sendTransaction(dtransactionish, chainId, allSigners = true, quote, callback) {\n    const signedTxs = await this.signTransactions(dtransactionish, chainId, allSigners);\n\n    if (callback) {\n      const address = addressOf(signedTxs.config, signedTxs.context);\n      const metaTxnHash = computeMetaTxnHash(address, signedTxs.chainId, ...signedTxs.transactions);\n      callback(signedTxs, metaTxnHash);\n    }\n\n    const wallet = chainId ? this.getWalletByNetwork(chainId).wallet : this.mainWallet().wallet;\n    return wallet.sendSignedTransactions(signedTxs, chainId, quote);\n  }\n\n  async sendTransactionBatch(transactions, chainId, allSigners = true, quote, callback) {\n    return this.sendTransaction(transactions, chainId, allSigners, quote, callback);\n  }\n\n  async signTransactions(dtransactionish, chainId, allSigners) {\n    const wallet = chainId ? this.getWalletByNetwork(chainId).wallet : this.mainWallet().wallet;\n    let currentConfig = await this.currentConfig(wallet);\n\n    if (!currentConfig) {\n      currentConfig = await this.currentConfig();\n\n      if (!currentConfig) {\n        throw new Error('missing auth chain config');\n      }\n    }\n\n    const transactions = await this.prependConfigUpdate(dtransactionish, chainId, allSigners);\n    return wallet.useConfig(currentConfig).signTransactions(transactions);\n  }\n\n  async prependConfigUpdate(dtransactionish, chainId, allSigners, skipThresholdCheck) {\n    const transaction = await resolveArrayProperties(dtransactionish);\n    const wallet = chainId ? this.getWalletByNetwork(chainId).wallet : this.mainWallet().wallet; // TODO: Skip this step if wallet is authWallet\n\n    const [thisConfig, lastConfig] = await Promise.all([this.currentConfig(wallet), this.currentConfig()]); // We have to skip the threshold check during fee estimation because we\n    // might not have the necessary signers until the wallet actually signs the\n    // transactions.\n    //\n    // By design, the Torus login key only exists in memory in Sequence wallet\n    // and cannot generally be assumed to be available. However the Torus login\n    // key might be required in order to transact on other non-auth chains,\n    // because the wallet config might not recognize the current session's\n    // signing key. In these cases, the Torus key is retrieved when the user\n    // confirms the transaction, which happens after fee estimation. So the\n    // wallet might not meet the threshold during fee estimation despite\n    // meeting it at confirmation time.\n\n    if (!skipThresholdCheck) {\n      // See if wallet has enough signer power\n      const weight = await wallet.useConfig(thisConfig).signWeight();\n\n      if (weight.lt(thisConfig.threshold) && allSigners) {\n        throw new NotEnoughSigners(`wallet combined weight ${weight.toString()} below required threshold ${thisConfig.threshold.toString()}`);\n      }\n    } // If the wallet is updated, just sign as-is\n\n\n    if ((await wallet.isDeployed()) && isConfigEqual(lastConfig, thisConfig)) {\n      return transaction;\n    } // Bundle with configuration update\n\n\n    const transactionParts = (() => {\n      if (Array.isArray(transaction)) {\n        return transaction;\n      } else {\n        return [transaction];\n      }\n    })();\n\n    return [...(await wallet.buildUpdateConfigTransaction(lastConfig, false)), ...transactionParts];\n  }\n\n  async sendSignedTransactions(signedTxs, chainId, quote) {\n    const wallet = chainId ? this.getWalletByNetwork(chainId).wallet : this.mainWallet().wallet;\n    return wallet.sendSignedTransactions(signedTxs, undefined, quote);\n  } // updateConfig will build an updated config transaction, update the imageHash on-chain and also publish\n  // the wallet config to the authChain. Other chains are lazy-updated on-demand as batched transactions.\n\n\n  async updateConfig(newConfig, index, quote, callback) {\n    const authWallet = this.authWallet().wallet;\n\n    if (!newConfig) {\n      newConfig = authWallet.config;\n    } else {\n      // ensure its normalized\n      newConfig = sortConfig(newConfig);\n    } // The config is the default config, see if the wallet has been deployed\n\n\n    if (isConfigEqual(authWallet.config, newConfig)) {\n      if (!(await this.isDeployed())) {\n        // Deploy the wallet and publish initial configuration\n        return await authWallet.updateConfig(newConfig, undefined, true, index, quote, callback);\n      }\n    } // Get latest config, update only if neccesary\n\n\n    const lastConfig = await this.currentConfig();\n\n    if (isConfigEqual(lastConfig, newConfig)) {\n      return [_extends({}, lastConfig, {\n        address: this.address\n      }), undefined];\n    } // Update to new configuration on the authWallet. Other networks will be lazily updated\n    // once used. The wallet config is also auto-published to the authChain.\n\n\n    const [_, tx] = await authWallet.useConfig(lastConfig).updateConfig(newConfig, undefined, true, index, quote, callback);\n    return [_extends({}, newConfig, {\n      address: this.address\n    }), tx];\n  } // publishConfig will publish the wallet config to the network via the relayer. Publishing\n  // the config will also store the entire object of signers.\n\n\n  publishConfig(indexed, requireFreshSigners = [], quote, callback) {\n    return this.authWallet().wallet.publishConfig(indexed, undefined, requireFreshSigners, quote, callback);\n  }\n\n  async isDeployed(target) {\n    const wallet = (() => {\n      if (!target) return this.authWallet().wallet;\n\n      if (target.address) {\n        return target;\n      }\n\n      return this.getWalletByNetwork(target).wallet;\n    })();\n\n    return wallet.isDeployed();\n  } // TODO: Split this to it's own class \"configProvider\" or something\n  // this process can be done in different ways (caching, api, utils, etc)\n\n\n  async currentConfig(target) {\n    const wallet = (() => {\n      if (!target) return this.authWallet().wallet;\n\n      if (target.address) {\n        return target;\n      }\n\n      return this.getWalletByNetwork(target).wallet;\n    })();\n\n    return (await this.getConfigFinder().findCurrentConfig({\n      address: this.address,\n      provider: wallet.provider,\n      context: wallet.context,\n      knownConfigs: [wallet.config]\n    })).config;\n  }\n\n  getWallets() {\n    return this._wallets;\n  }\n\n  getWalletByNetwork(chainId) {\n    const networkId = getChainId(chainId);\n\n    const network = this._wallets.find(w => w.network.chainId === networkId);\n\n    if (!network) {\n      throw new Error(`network ${chainId} not found in wallets list`);\n    }\n\n    return network;\n  } // mainWallet is the DefaultChain wallet\n\n\n  mainWallet() {\n    const found = this._wallets.find(w => w.network.isDefaultChain);\n\n    if (!found) {\n      throw new Error('mainWallet not found');\n    }\n\n    return found;\n  } // authWallet is the AuthChain wallet\n\n\n  authWallet() {\n    const found = this._wallets.find(w => w.network.isAuthChain);\n\n    if (!found) {\n      throw new Error('authChain wallet not found');\n    }\n\n    return found;\n  }\n\n  setNetworks(mainnetNetworks, testnetNetworks = [], defaultChainId) {\n    let networks = [];\n    this._chainId = undefined; // clear memoized value\n    // find chain between mainnet and testnet network groups, and set that network group.\n    // otherwise use mainnetNetworks without changes\n\n    if (defaultChainId) {\n      // force-convert to a number in case someone sends a number in a string like \"1\"\n      const defaultChainIdNum = parseInt(defaultChainId);\n      const foundMainnetNetwork = mainnetNetworks.find(n => n.name === defaultChainId || n.chainId === defaultChainIdNum);\n      const foundTestnetNetwork = testnetNetworks.find(n => n.name === defaultChainId || n.chainId === defaultChainIdNum);\n\n      if (foundMainnetNetwork || foundTestnetNetwork) {\n        if (foundMainnetNetwork) {\n          mainnetNetworks.forEach(n => n.isDefaultChain = false);\n          foundMainnetNetwork.isDefaultChain = true;\n          networks = mainnetNetworks;\n        } else if (foundTestnetNetwork) {\n          testnetNetworks.forEach(n => n.isDefaultChain = false);\n          foundTestnetNetwork.isDefaultChain = true;\n          networks = testnetNetworks;\n        }\n      } else {\n        throw new Error(`unable to set default network as chain '${defaultChainId}' does not exist`);\n      }\n    } else {\n      networks = mainnetNetworks;\n    } // assign while validating network list\n    // TODO - we should remove sortNetworks in the future but this is a breaking change\n\n\n    this.options.networks = ensureValidNetworks(sortNetworks(networks)); // Account/wallet instances using the initial configuration and network list\n    //\n    // TODO: we can make an optimization where if mainnetNetworks and testnetNetworks lists\n    // haven't changed between calls, and only the defaultChainId, as well, the group between\n    // mainnet vs testnet has not changed either -- aka just defaultChainId within a group,\n    // then we can avoid rebuilding all of these objects and instead just sort them\n\n    this._wallets = this.options.networks.map(network => {\n      const wallet = new Wallet({\n        config: this.options.initialConfig,\n        context: this.options.context\n      }, ...this._signers);\n\n      if (network.provider) {\n        wallet.setProvider(network.provider);\n      } else if (network.rpcUrl && network.rpcUrl !== '') {\n        wallet.setProvider(network.rpcUrl);\n      } else {\n        throw new Error(`network config is missing provider settings for chainId ${network.chainId}`);\n      }\n\n      if (isRelayer(network.relayer)) {\n        wallet.setRelayer(network.relayer);\n      } else if (isRpcRelayerOptions(network.relayer)) {\n        wallet.setRelayer(new RpcRelayer(_extends({\n          provider: wallet.provider\n        }, network.relayer)));\n      } else {\n        throw new Error(`network config is missing relayer settings for chainId ${network.chainId}`);\n      }\n\n      if (network.isDefaultChain) {\n        this._chainId = network.chainId;\n        this.provider = wallet.provider;\n      }\n\n      return {\n        network: network,\n        wallet: wallet\n      };\n    }); // return the default chain id as number\n\n    return this.options.networks.find(network => network.isDefaultChain).chainId;\n  }\n\n  connect(_) {\n    throw new Error('connect method is not supported in MultiWallet');\n  }\n\n  signTransaction(_) {\n    throw new Error('signTransaction method is not supported in MultiWallet, please use signTransactions(...)');\n  }\n\n}\n\nasync function isValidSignature(address, digest, sig, provider, walletContext, chainId) {\n  // Check if valid EOA signature\n  //\n  // TODO: the EOA check here assume its being passed a digest, but its not a correct assumption\n  // as often the message signing is of a string of text and not a digest.\n  if (isValidEIP712Signature(address, digest, sig) || isValidEthSignSignature(address, digest, sig)) return true; // Check if valid deployed smart wallet (via erc1271 check)\n\n  const erc1271Check = await isValidContractWalletSignature(address, digest, sig, provider);\n\n  if (erc1271Check === undefined) {\n    // If validity of wallet signature can't be determined\n    // it could be a signature of a non-deployed sequence wallet\n    return isValidSequenceUndeployedWalletSignature(address, digest, sig, walletContext, provider, chainId);\n  }\n\n  return erc1271Check;\n}\nfunction isValidEIP712Signature(address, digest, sig) {\n  try {\n    return compareAddr(ethers.utils.recoverAddress(digest, ethers.utils.splitSignature(sig)), address) === 0;\n  } catch (_unused) {\n    return false;\n  }\n}\nfunction isValidEthSignSignature(address, digest, sig) {\n  try {\n    const subDigest = ethers.utils.keccak256(ethers.utils.solidityPack(['string', 'bytes32'], ['\\x19Ethereum Signed Message:\\n32', digest]));\n    return compareAddr(ethers.utils.recoverAddress(subDigest, ethers.utils.splitSignature(sig)), address) === 0;\n  } catch (_unused2) {\n    return false;\n  }\n} // Check if valid Smart Contract Wallet signature, via ERC1271\n\nasync function isValidContractWalletSignature(address, digest, sig, provider) {\n  if (!provider) return undefined;\n\n  try {\n    if ((await provider.getCode(address)) === '0x') {\n      // Signature validity can't be determined\n      return undefined;\n    }\n\n    const wallet = new ethers.Contract(address, walletContracts.erc1271.abi, provider);\n    const response = await wallet.isValidSignature(digest, sig);\n    return walletContracts.erc1271.returns.isValidSignatureBytes32 === response;\n  } catch (_unused3) {\n    return false;\n  }\n}\nasync function isValidSequenceUndeployedWalletSignature(address, digest, sig, walletContext, provider, chainId) {\n  if (!provider && !chainId) return undefined; // Signature validity can't be determined\n\n  if (!walletContext) return undefined; // Signature validity can't be determined\n\n  try {\n    const cid = chainId ? chainId : (await provider.getNetwork()).chainId;\n    const signature = decodeSignature(sig);\n    const subDigest = ethers.utils.arrayify(ethers.utils.keccak256(packMessageData(address, cid, digest)));\n    const config = await recoverConfigFromDigest(subDigest, signature, provider, walletContext, chainId, true);\n    const weight = signature.signers.reduce((v, s) => isDecodedEOASigner(s) || isDecodedFullSigner(s) ? v + s.weight : v, 0);\n    return compareAddr(addressOf(config, walletContext), address) === 0 && weight >= signature.threshold;\n  } catch (_unused4) {\n    return false;\n  }\n}\n\nconst fetchImageHash = async signer => {\n  const address = await signer.getAddress();\n  const walletContract = new Contract(address, walletContracts.mainModuleUpgradable.abi, await signer.getProvider());\n  const currentImageHash = await walletContract.functions.imageHash.call([]).catch(() => []);\n  return currentImageHash && currentImageHash.length > 0 ? currentImageHash[0] : '';\n}; // recoverConfig decodes a WalletConfig from the subDigest and signature combo. Note: the subDigest argument\n// is an encoding format of the original message, encoded by:\n//\n// subDigest = packMessageData(wallet.address, chainId, ethers.utils.keccak256(message))\n\nconst recoverConfig = async (subDigest, signature, provider, context, chainId, walletSignersValidation) => {\n  const digest = ethers.utils.arrayify(ethers.utils.keccak256(subDigest));\n  return recoverConfigFromDigest(digest, signature, provider, context, chainId, walletSignersValidation);\n}; // recoverConfigFromDigest decodes a WalletConfig from a digest and signature combo. Note: the digest\n// is the keccak256 of the subDigest, see `recoverConfig` method.\n\nconst recoverConfigFromDigest = async (digest, signature, provider, context, chainId, walletSignersValidation) => {\n  const decoded = signature.threshold !== undefined ? signature : decodeSignature(signature);\n  const signers = await Promise.all(decoded.signers.map(async s => {\n    if (isDecodedEOASigner(s)) {\n      return {\n        weight: s.weight,\n        address: recoverEOASigner(digest, s)\n      };\n    } else if (isDecodedAddress(s)) {\n      return {\n        weight: s.weight,\n        address: ethers.utils.getAddress(s.address)\n      };\n    } else if (isDecodedFullSigner(s)) {\n      if (walletSignersValidation) {\n        if (!(await isValidSignature(s.address, ethers.utils.arrayify(digest), ethers.utils.hexlify(s.signature), provider, context, chainId))) throw Error('Invalid signature');\n      }\n\n      return {\n        weight: s.weight,\n        address: s.address\n      };\n    } else {\n      throw Error('Uknown signature type');\n    }\n  }));\n  return {\n    threshold: decoded.threshold,\n    signers: signers\n  };\n};\n\nexport { Account, GuardRemoteSigner, InvalidSigner, LocalRemoteSigner, NotEnoughSigners, RemoteSigner, Signer, Wallet, fetchImageHash, findLatestLog, isSequenceSigner, isValidContractWalletSignature, isValidEIP712Signature, isValidEthSignSignature, isValidSequenceUndeployedWalletSignature, isValidSignature, recoverConfig, recoverConfigFromDigest, resolveArrayProperties };\n","import { ethers } from 'ethers';\nimport { Proof, ETHAuth, IsValidSignatureBytes32MagicValue } from '@0xsequence/ethauth';\nimport { SequenceAPIClient } from '@0xsequence/api';\nimport { SequenceUtilsFinder, decodeSignature, isDecodedSigner, editConfig, genConfig } from '@0xsequence/config';\nimport { SequenceIndexerClient } from '@0xsequence/indexer';\nimport { SequenceMetadataClient } from '@0xsequence/metadata';\nimport { findNetworkConfig, getAuthNetwork, sequenceContext } from '@0xsequence/network';\nimport { jwtDecodeClaims } from '@0xsequence/utils';\nimport { Account, isValidSequenceUndeployedWalletSignature } from '@0xsequence/wallet';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\n// Default session expiration of ETHAuth token (1 week)\nconst DEFAULT_SESSION_EXPIRATION = 60 * 60 * 24 * 7; // Long session expiration of ETHAuth token (~1 year)\n\nconst LONG_SESSION_EXPIRATION = 3e7;\nconst EXPIRATION_JWT_MARGIN = 60; // seconds\n\nclass Session {\n  // proof strings are indexed by account address and app name, see getProofStringKey()\n  constructor(sequenceApiUrl, sequenceMetadataUrl, networks, config, context, account, metadata, authProvider, jwt) {\n    this.sequenceApiUrl = sequenceApiUrl;\n    this.sequenceMetadataUrl = sequenceMetadataUrl;\n    this.networks = networks;\n    this.config = config;\n    this.context = context;\n    this.account = account;\n    this.metadata = metadata;\n    this.authProvider = authProvider;\n    this._initialAuthRequest = void 0;\n    this._jwt = void 0;\n    this.proofStrings = new Map();\n    this.onAuthCallbacks = [];\n    this.apiClient = void 0;\n    this.metadataClient = void 0;\n    this.indexerClients = new Map();\n\n    if (jwt) {\n      var _jwt$expiration;\n\n      this._jwt = {\n        token: Promise.resolve(jwt.token),\n        expiration: (_jwt$expiration = jwt.expiration) != null ? _jwt$expiration : getJWTExpiration(jwt.token)\n      };\n    }\n  }\n\n  get name() {\n    return this.metadata.name;\n  }\n\n  get expiration() {\n    return this.metadata.expiration ? Math.max(this.metadata.expiration, 120) : DEFAULT_SESSION_EXPIRATION;\n  }\n\n  onAuth(cb) {\n    this.onAuthCallbacks.push(cb);\n  }\n\n  setAccount(account) {\n    this.account = account;\n  }\n\n  setConfig(config) {\n    this.config = config;\n  }\n\n  async auth(maxTries = 5) {\n    const url = this.sequenceApiUrl;\n    if (!url) throw Error('No sequence api url');\n    let jwtAuth;\n\n    for (let i = 0;; i++) {\n      try {\n        jwtAuth = (await this.getJWT(true)).token;\n        break;\n      } catch (error) {\n        if (i === maxTries - 1) {\n          console.error(`couldn't authenticate after ${maxTries} attempts`, error);\n          throw error;\n        }\n      }\n    }\n\n    return new SequenceAPIClient(url, jwtAuth);\n  }\n\n  get isTestnetMode() {\n    if (!this.networks || this.networks.length === 0) return;\n    return !!this.networks[0].testnet;\n  }\n\n  async getAPIClient(tryAuth = true) {\n    if (!this.apiClient) {\n      const url = this.sequenceApiUrl;\n      if (!url) throw Error('No chaind url');\n      const jwtAuth = (await this.getJWT(tryAuth)).token;\n      this.apiClient = new SequenceAPIClient(url, jwtAuth);\n    }\n\n    return this.apiClient;\n  }\n\n  getMetadataClient() {\n    if (!this.metadataClient) {\n      this.metadataClient = new SequenceMetadataClient(this.sequenceMetadataUrl);\n    }\n\n    return this.metadataClient;\n  }\n\n  async getIndexerClient(chainId) {\n    const network = findNetworkConfig(this.networks, chainId);\n\n    if (!network) {\n      throw Error(`No network for chain ${chainId}`);\n    }\n\n    const jwtAuth = (await this.getJWT(true)).token;\n\n    if (!this.indexerClients.has(network.chainId)) {\n      if (network.indexer) {\n        this.indexerClients.set(network.chainId, network.indexer);\n      } else if (network.indexerUrl) {\n        this.indexerClients.set(network.chainId, new SequenceIndexerClient(network.indexerUrl, jwtAuth));\n      } else {\n        throw Error(`No indexer url for chain ${chainId}`);\n      }\n    }\n\n    return this.indexerClients.get(network.chainId);\n  }\n\n  async getJWT(tryAuth) {\n    var _this = this;\n\n    const url = this.sequenceApiUrl;\n    if (!url) throw Error('No chaind url'); // check if we already have or are waiting for a token\n\n    if (this._jwt) {\n      const _jwt = this._jwt;\n\n      const _token = await _jwt.token;\n\n      if (this.now() < _jwt.expiration) {\n        return {\n          token: _token,\n          expiration: _jwt.expiration\n        };\n      } // token expired, delete it and get a new one\n\n\n      this._jwt = undefined;\n    }\n\n    if (!tryAuth) {\n      throw new Error('no auth token in memory');\n    }\n\n    const proofStringKey = this.getProofStringKey();\n    const {\n      proofString,\n      expiration\n    } = this.getProofString(proofStringKey);\n    const jwt = {\n      token: proofString.then(async function (proofString) {\n        const api = new SequenceAPIClient(url);\n        const authResp = await api.getAuthToken({\n          ewtString: proofString,\n          testnetMode: _this.isTestnetMode\n        });\n\n        if ((authResp == null ? void 0 : authResp.status) === true && authResp.jwtToken.length !== 0) {\n          return authResp.jwtToken;\n        } else {\n          if (!(await _this.isProofStringValid(proofString))) {\n            _this.proofStrings.delete(proofStringKey);\n          }\n\n          throw new Error('no auth token from server');\n        }\n      }).catch(reason => {\n        this._jwt = undefined;\n        throw reason;\n      }),\n      expiration\n    };\n    this._jwt = jwt;\n    jwt.token.then(() => {\n      this.onAuthCallbacks.forEach(cb => {\n        try {\n          cb({\n            status: 'fulfilled',\n            value: undefined\n          });\n        } catch (_unused) {}\n      });\n    }).catch(reason => {\n      this.onAuthCallbacks.forEach(cb => {\n        try {\n          cb({\n            status: 'rejected',\n            reason\n          });\n        } catch (_unused2) {}\n      });\n    });\n    const token = await jwt.token;\n    return {\n      token,\n      expiration\n    };\n  }\n\n  getProofString(key) {\n    // check if we already have or are waiting for a proof string\n    if (this.proofStrings.has(key)) {\n      const _proofString = this.proofStrings.get(key);\n\n      if (this.now() < _proofString.expiration) {\n        return _proofString;\n      } // proof string expired, delete it and make a new one\n\n\n      this.proofStrings.delete(key);\n    }\n\n    const proof = new Proof({\n      address: this.account.address\n    });\n    proof.claims.app = this.name;\n    proof.setExpiryIn(this.expiration);\n    const ethAuth = new ETHAuth();\n    const configFinder = new SequenceUtilsFinder(this.authProvider);\n    const authWallet = this.account.authWallet();\n    const expiration = this.now() + this.expiration - EXPIRATION_JWT_MARGIN;\n    const proofString = {\n      // Fetch latest config\n      // TODO: Should only search for latest config if necessary to be more efficient.\n      //       Perhaps compare local config hash with on-chain hash before doing\n      //       the search through the logs. Should do this accross sequence.js\n      proofString: configFinder.findCurrentConfig({\n        address: authWallet.wallet.address,\n        provider: this.authProvider,\n        context: authWallet.wallet.context,\n        knownConfigs: [authWallet.wallet.config]\n      }).then(val => {\n        if (!val.config) throw Error(\"Can't find latest config\");\n        return authWallet.wallet.useConfig(val.config).sign(proof.messageDigest()).then(signature => {\n          const decodedSignature = decodeSignature(signature);\n          const totalWeight = decodedSignature.signers.filter(isDecodedSigner).reduce((totalWeight, signer) => totalWeight + signer.weight, 0);\n\n          if (totalWeight < decodedSignature.threshold) {\n            throw Error(`insufficient signing power, need ${decodedSignature.threshold}, have ${totalWeight}`);\n          }\n\n          proof.signature = signature;\n          return ethAuth.encodeProof(proof, true);\n        });\n      }).catch(reason => {\n        this.proofStrings.delete(key);\n        throw reason;\n      }),\n      expiration\n    };\n    this.proofStrings.set(key, proofString);\n    return proofString;\n  }\n\n  getProofStringKey() {\n    return `${this.account.address} - ${this.name}`;\n  }\n\n  async isProofStringValid(proofString) {\n    try {\n      const ethAuth = new ETHAuth();\n      ethAuth.provider = this.authProvider;\n      await ethAuth.decodeProof(proofString);\n      return true;\n    } catch (_unused3) {\n      return false;\n    }\n  }\n\n  async dump() {\n    let jwt;\n\n    if (this._jwt) {\n      try {\n        const expiration = this._jwt.expiration;\n        jwt = {\n          token: await this._jwt.token,\n          expiration\n        };\n      } catch (_unused4) {}\n    }\n\n    return {\n      config: this.config,\n      context: this.context,\n      metadata: this.metadata,\n      jwt\n    };\n  }\n\n  now() {\n    return Math.floor(new Date().getTime() / 1000);\n  }\n\n  static async open(args) {\n    const {\n      sequenceApiUrl,\n      sequenceMetadataUrl,\n      context,\n      networks,\n      referenceSigner,\n      signers,\n      threshold,\n      deepSearch,\n      knownConfigs,\n      noIndex,\n      metadata\n    } = args;\n    const authProvider = getAuthProvider(networks);\n    const configFinder = args.configFinder ? args.configFinder : new SequenceUtilsFinder(authProvider);\n    const solvedSigners = Promise.all(signers.map(async function (s) {\n      return _extends({}, s, {\n        address: typeof s.signer === 'string' ? s.signer : await s.signer.getAddress()\n      });\n    }));\n    const fullSigners = signers.filter(s => typeof s.signer !== 'string').map(s => s.signer);\n    const existingWallet = (await configFinder.findLastWalletOfInitialSigner({\n      signer: referenceSigner,\n      context: context,\n      provider: authProvider,\n      requireIndex: deepSearch ? false : true\n    })).wallet;\n\n    if (existingWallet) {\n      // existing account\n      // Find prev configuration\n      const config = (await configFinder.findCurrentConfig({\n        address: existingWallet,\n        provider: authProvider,\n        context: context,\n        knownConfigs\n      })).config;\n      if (!config) throw Error('Wallet config not found'); // Load prev account\n\n      const account = new Account({\n        initialConfig: config,\n        networks: networks,\n        context: context\n      }, ...fullSigners);\n      const session = new Session(sequenceApiUrl, sequenceMetadataUrl, networks, config, context, account, metadata, authProvider); // Update wallet config on-chain on the authChain\n\n      const [newConfig] = await account.updateConfig(editConfig(config, {\n        threshold,\n        set: await solvedSigners\n      }), noIndex ? false : true); // Session is ready, lets update\n\n      session.setConfig(newConfig);\n      session.setAccount(new Account({\n        initialConfig: newConfig,\n        networks: networks,\n        context: context\n      }, ...fullSigners));\n\n      if (sequenceApiUrl) {\n        // Fire JWT requests after updating config\n        session._initialAuthRequest = session.auth();\n      } else {\n        session._initialAuthRequest = Promise.reject('no sequence api url');\n      }\n\n      return session;\n    } else {\n      // fresh account\n      const config = genConfig(threshold, await solvedSigners);\n      const account = new Account({\n        initialConfig: config,\n        networks: networks,\n        context: context\n      }, ...fullSigners); // send referenceSigner as \"requireFreshSigners\"\n      // this ensures the user doesn't end up with multiple accounts if there is a race condition during login\n\n      await account.publishConfig(noIndex ? false : true, [referenceSigner]);\n      const session = new Session(sequenceApiUrl, sequenceMetadataUrl, networks, config, context, account, metadata, authProvider);\n\n      if (sequenceApiUrl) {\n        // Fire JWT requests when opening session\n        session._initialAuthRequest = session.auth();\n      } else {\n        session._initialAuthRequest = Promise.reject('no sequence api url');\n      }\n\n      return session;\n    }\n  }\n\n  static load(args) {\n    const {\n      sequenceApiUrl,\n      sequenceMetadataUrl,\n      dump,\n      signers,\n      networks\n    } = args;\n    return new Session(sequenceApiUrl, sequenceMetadataUrl, networks, dump.config, dump.context, new Account({\n      initialConfig: dump.config,\n      context: dump.context,\n      networks: networks\n    }, ...signers), dump.metadata, getAuthProvider(networks), dump.jwt);\n  }\n\n}\n\nfunction getAuthProvider(networks) {\n  var _authChain$provider;\n\n  const authChain = getAuthNetwork(networks);\n  if (!authChain) throw Error('Auth chain not found');\n  return (_authChain$provider = authChain.provider) != null ? _authChain$provider : new ethers.providers.JsonRpcProvider(authChain.rpcUrl);\n}\n\nfunction getJWTExpiration(jwt) {\n  return jwtDecodeClaims(jwt).exp;\n}\n\n// signAuthorization will perform an EIP712 typed-data message signing of ETHAuth domain via the provided\n// Signer and authorization options.\nconst signAuthorization = async (signer, options) => {\n  const chainId = await signer.getChainId();\n  const address = ethers.utils.getAddress(await signer.getAddress());\n\n  if (!address || address === '' || address === '0x') {\n    throw ErrAccountIsRequired;\n  }\n\n  const proof = new Proof();\n  proof.address = address;\n\n  if (!options || !options.app || options.app === '') {\n    throw new AuthError('authorization options requires app to be set');\n  }\n\n  proof.claims.app = options.app;\n  proof.claims.ogn = options.origin;\n  proof.setExpiryIn(options.expiry ? Math.max(options.expiry, 200) : DEFAULT_SESSION_EXPIRATION);\n  const typedData = proof.messageTypedData();\n  proof.signature = await signer.signTypedData(typedData.domain, typedData.types, typedData.message, chainId);\n  const ethAuth = new ETHAuth();\n  const proofString = await ethAuth.encodeProof(proof, true);\n  return {\n    typedData,\n    proofString\n  };\n}; // TODO: review......\n\nclass AuthError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'AuthError';\n  }\n\n}\nconst ErrAccountIsRequired = new AuthError('auth error: account address is empty');\n\nconst ValidateSequenceDeployedWalletProof = async (provider, chainId, proof) => {\n  if (!provider || provider === undefined || chainId === undefined) {\n    return {\n      isValid: false\n    };\n  } // Compute eip712 message digest from the proof claims\n\n\n  const digest = proof.messageDigest(); // Early check to ensure the contract wallet has been deployed\n\n  const walletCode = await provider.getCode(proof.address);\n\n  if (walletCode === '0x' || walletCode.length <= 2) {\n    throw new Error('ValidateSequenceDeployedWalletProof failed. unable to fetch wallet contract code');\n  } // Call EIP-1271 IsValidSignature(bytes32, bytes) method on the deployed wallet. Note: for undeployed\n  // wallets, you will need to implement your own ValidatorFunc with the additional context.\n\n\n  const abi = ['function isValidSignature(bytes32, bytes) public view returns (bytes4)'];\n  const contract = new ethers.Contract(proof.address, abi, provider); // hash the message digest as required by isValidSignature\n\n  const isValidSignature = await contract.isValidSignature(digest, ethers.utils.arrayify(proof.signature));\n\n  if (isValidSignature === IsValidSignatureBytes32MagicValue) {\n    return {\n      isValid: true\n    };\n  } else {\n    return {\n      isValid: false\n    };\n  }\n};\nconst ValidateSequenceUndeployedWalletProof = context => {\n  return async (provider, chainId, proof) => {\n    if (!provider || provider === undefined || chainId === undefined) {\n      return {\n        isValid: false\n      };\n    } // The contract must not be deployed\n\n\n    const walletCode = ethers.utils.arrayify(await provider.getCode(proof.address));\n    if (walletCode.length !== 0) return {\n      isValid: false\n    }; // Compute eip712 message digest from the proof claims\n\n    const message = proof.messageDigest(); // hash the message digest as required by isValidSignature\n\n    const digest = ethers.utils.arrayify(ethers.utils.keccak256(message));\n    const isValid = await isValidSequenceUndeployedWalletSignature(proof.address, digest, proof.signature, context ? context : sequenceContext, provider, chainId);\n    return {\n      isValid: !!isValid\n    };\n  };\n};\n\nexport { AuthError, DEFAULT_SESSION_EXPIRATION, ErrAccountIsRequired, LONG_SESSION_EXPIRATION, Session, ValidateSequenceDeployedWalletProof, ValidateSequenceUndeployedWalletProof, signAuthorization };\n","function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\n/* eslint-disable */\n// guardd v0.1.0 8d4d548d0af400f36ef39a21c29927fe65f9396c\n// --\n// This file has been generated by https://github.com/webrpc/webrpc using gen/typescript\n// Do not edit by hand. Update your webrpc schema and re-generate.\n// WebRPC description and code-gen version\nconst WebRPCVersion = \"v1\"; // Schema version of your RIDL schema\n\nconst WebRPCSchemaVersion = \"v0.1.0\"; // Schema hash generated from your RIDL schema\n\nconst WebRPCSchemaHash = \"8d4d548d0af400f36ef39a21c29927fe65f9396c\"; //\n// Types\n//\n\n//\n// Client\n//\nclass GuarddService {\n  constructor(hostname, fetch) {\n    this.hostname = void 0;\n    this.fetch = void 0;\n    this.path = '/rpc/GuarddService/';\n\n    this.sign = (args, headers) => {\n      return this.fetch(this.url('Sign'), createHTTPRequest(args, headers)).then(res => {\n        return buildResponse(res).then(_data => {\n          return {\n            sig: _data.sig\n          };\n        });\n      });\n    };\n\n    this.hostname = hostname;\n    this.fetch = fetch;\n  }\n\n  url(name) {\n    return this.hostname + this.path + name;\n  }\n\n}\n\nconst createHTTPRequest = (body = {}, headers = {}) => {\n  return {\n    method: 'POST',\n    headers: _extends({}, headers, {\n      'Content-Type': 'application/json'\n    }),\n    body: JSON.stringify(body || {})\n  };\n};\n\nconst buildResponse = res => {\n  return res.text().then(text => {\n    let data;\n\n    try {\n      data = JSON.parse(text);\n    } catch (err) {\n      throw {\n        code: 'unknown',\n        msg: `expecting JSON, got: ${text}`,\n        status: res.status\n      };\n    }\n\n    if (!res.ok) {\n      throw data; // webrpc error response\n    }\n\n    return data;\n  });\n};\n\nexport { GuarddService, WebRPCSchemaHash, WebRPCSchemaVersion, WebRPCVersion };\n","import { EventEmitter2 } from 'eventemitter2';\nimport { logger, shallowCopy, resolveProperties, encodeMessageDigest, encodeTypedDataDigest, packMessageData, sanitizeNumberString, sanitizeHost, sanitizeAlphanumeric, base64EncodeObject, base64DecodeObject } from '@0xsequence/utils';\nimport { ethers, BigNumber } from 'ethers';\nimport { addressOf, isConfigEqual } from '@0xsequence/config';\nimport { Web3Provider as Web3Provider$1, JsonRpcProvider } from '@ethersproject/providers';\nimport { JsonRpcSender, maybeChainId, allowProviderMiddleware, networkProviderMiddleware, CachedProvider, JsonRpcRouter, loggingProviderMiddleware, exceptionProviderMiddleware, findNetworkConfig, EagerProvider, SigningProvider, updateNetworkConfig, ensureValidNetworks } from '@0xsequence/network';\nimport { Signer, resolveArrayProperties, isValidSignature as isValidSignature$1, recoverConfig } from '@0xsequence/wallet';\nimport { isSignedTransactions } from '@0xsequence/transactions';\nimport { signAuthorization } from '@0xsequence/auth';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\n// ProviderMessageCallback is used to respond to ProviderMessage requests. The error\n// argument is for exceptions during the execution, and response is the response payload\n// which may contain the result or an error payload from the wallet.\nclass WindowSessionParams extends URLSearchParams {\n  static new(init) {\n    return new URLSearchParams(init);\n  }\n\n}\nlet EventType;\n\n(function (EventType) {\n  EventType[\"OPEN\"] = \"open\";\n  EventType[\"CLOSE\"] = \"close\";\n  EventType[\"MESSAGE\"] = \"message\";\n  EventType[\"CONNECT\"] = \"connect\";\n  EventType[\"DISCONNECT\"] = \"disconnect\";\n  EventType[\"ACCOUNTS_CHANGED\"] = \"accountsChanged\";\n  EventType[\"CHAIN_CHANGED\"] = \"chainChanged\";\n  EventType[\"NETWORKS\"] = \"networks\";\n  EventType[\"WALLET_CONTEXT\"] = \"walletContext\";\n  EventType[\"INIT\"] = \"init\";\n  EventType[\"DEBUG\"] = \"_debug\";\n})(EventType || (EventType = {}));\n\nlet OpenState;\n\n(function (OpenState) {\n  OpenState[OpenState[\"CLOSED\"] = 0] = \"CLOSED\";\n  OpenState[OpenState[\"OPENING\"] = 1] = \"OPENING\";\n  OpenState[OpenState[\"OPENED\"] = 2] = \"OPENED\";\n})(OpenState || (OpenState = {}));\n\nlet InitState;\n\n(function (InitState) {\n  InitState[InitState[\"NIL\"] = 0] = \"NIL\";\n  InitState[InitState[\"SENT_NONCE\"] = 1] = \"SENT_NONCE\";\n  InitState[InitState[\"OK\"] = 2] = \"OK\";\n})(InitState || (InitState = {}));\n\nclass ProviderError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'ProviderError';\n  }\n\n}\nconst ErrSignedInRequired = new ProviderError('Wallet is not signed in. Connect a wallet and try again.'); // TODO: lets build some nice error handling tools, prob in /utils ...\n\nconst PROVIDER_OPEN_TIMEOUT = 30000; // in ms\n\nlet _messageIdx = 0;\nconst nextMessageIdx = () => ++_messageIdx;\nclass BaseProviderTransport {\n  constructor() {\n    var _this = this;\n\n    this.pendingMessageRequests = [];\n    this.responseCallbacks = new Map();\n    this.state = void 0;\n    this.confirmationOnly = false;\n    this.events = new EventEmitter2();\n    this.openPayload = void 0;\n    this.connectPayload = void 0;\n    this.accountsChangedPayload = void 0;\n    this.networksPayload = void 0;\n    this.walletContextPayload = void 0;\n    this._sessionId = void 0;\n    this._init = void 0;\n    this._registered = void 0;\n\n    this.sendAsync = async function (request, callback, chainId) {\n      // here, we receive the message from the dapp provider call\n      if (_this.state === OpenState.CLOSED) {\n        // flag the wallet to auto-close once user submits input. ie.\n        // prompting to sign a message or transaction\n        _this.confirmationOnly = true;\n      } // open/focus the wallet.\n      // automatically open the wallet when a provider request makes it here.\n      //\n      // NOTE: if we're not signed in, then the provider will fail, users must first connect+sign in.\n      //\n      // TODO: how does this behave with a session has expired?\n\n\n      _this.openWallet(undefined, {\n        type: 'jsonRpcRequest',\n        method: request.method\n      }, chainId); // send message request, await, and then execute callback after receiving the response\n\n\n      try {\n        if (!_this.isOpened()) {\n          await _this.waitUntilOpened(); // will throw on timeout\n        }\n\n        const response = await _this.sendMessageRequest({\n          idx: nextMessageIdx(),\n          type: EventType.MESSAGE,\n          data: request,\n          chainId: chainId\n        });\n        callback(undefined, response.data);\n      } catch (err) {\n        callback(err);\n      }\n    };\n\n    this.sendMessageRequest = async function (message) {\n      return new Promise((resolve, reject) => {\n        if ((!message.idx || message.idx <= 0) && message.type !== 'init') {\n          reject(new Error('message idx not set'));\n        }\n\n        const responseCallback = (error, response) => {\n          if (error) {\n            reject(error);\n          } else if (response) {\n            resolve(response);\n          } else {\n            throw new Error('no valid response to return');\n          }\n        };\n\n        const idx = message.idx;\n\n        if (!_this.responseCallbacks.get(idx)) {\n          _this.responseCallbacks.set(idx, responseCallback);\n        } else {\n          reject(new Error('duplicate message idx, should never happen'));\n        }\n\n        if (!_this.isOpened()) {\n          logger.debug('pushing to pending requests', message);\n\n          _this.pendingMessageRequests.push(message);\n        } else {\n          _this.sendMessage(message);\n        }\n      });\n    };\n\n    this.waitUntilOpened = async function (openTimeout = PROVIDER_OPEN_TIMEOUT) {\n      let opened = false;\n      return Promise.race([new Promise((_, reject) => {\n        const timeout = setTimeout(() => {\n          clearTimeout(timeout); // only emit close if the timeout wins the race\n\n          if (!opened) {\n            _this.state = OpenState.CLOSED;\n\n            _this.events.emit('close', {\n              code: 1005,\n              message: 'opening wallet timed out'\n            });\n          }\n\n          reject(new Error('opening wallet timed out'));\n        }, openTimeout);\n      }), new Promise(resolve => {\n        if (_this.isOpened()) {\n          var _this$openPayload;\n\n          opened = true;\n          resolve((_this$openPayload = _this.openPayload) == null ? void 0 : _this$openPayload.session);\n          return;\n        }\n\n        _this.events.once('open', openInfo => {\n          _this.openPayload = openInfo;\n          opened = true;\n          resolve(openInfo.session);\n        });\n      })]);\n    };\n\n    this.waitUntilConnected = async function () {\n      await _this.waitUntilOpened();\n      const connect = new Promise(resolve => {\n        if (_this.connectPayload) {\n          resolve(_this.connectPayload);\n          return;\n        }\n\n        _this.events.once('connect', connectDetails => {\n          _this.connectPayload = connectDetails;\n          resolve(connectDetails);\n        });\n      });\n      const closeWallet = new Promise((_, reject) => {\n        _this.events.once('close', error => {\n          if (error) {\n            reject(new Error(`wallet closed due to ${JSON.stringify(error)}`));\n          } else {\n            reject(new Error(`user closed the wallet`));\n          }\n        });\n      });\n      return Promise.race([connect, closeWallet]);\n    };\n\n    this.state = OpenState.CLOSED;\n    this._registered = false;\n    this._init = InitState.NIL;\n  }\n\n  get registered() {\n    return this._registered;\n  }\n\n  register() {\n    throw new Error('abstract method');\n  }\n\n  unregister() {\n    throw new Error('abstract method');\n  }\n\n  openWallet(path, intent, networkId) {\n    throw new Error('abstract method');\n  }\n\n  closeWallet() {\n    throw new Error('abstract method');\n  }\n\n  isOpened() {\n    return this.registered && this.state === OpenState.OPENED;\n  }\n\n  isConnected() {\n    var _this$openPayload2;\n\n    // if we're registered, and we have the account details, then we are connected\n    const session = (_this$openPayload2 = this.openPayload) == null ? void 0 : _this$openPayload2.session;\n    return this.registered && session !== undefined && !!session.accountAddress && session.accountAddress.length === 42 && !!session.networks && session.networks.length > 0;\n  }\n\n  // handleMessage will handle message received from the remote wallet\n  handleMessage(message) {\n    var _this2 = this;\n\n    // init incoming for initial handshake with transport.\n    // always respond to INIT messages, e.g. on popup window reload\n    if (message.type === EventType.INIT) {\n      logger.debug('MessageProvider, received INIT message', message);\n      const {\n        nonce\n      } = message.data;\n\n      if (!nonce || nonce.length == 0) {\n        logger.error('invalid init nonce');\n        return;\n      }\n\n      this._init = InitState.OK;\n      this.sendMessage({\n        idx: -1,\n        type: EventType.INIT,\n        data: {\n          sessionId: this._sessionId,\n          nonce: nonce\n        }\n      });\n    }\n\n    if (this._init !== InitState.OK) {\n      // if provider is not init'd, then we drop any received messages. the only\n      // message we will process is of event type 'init', as our acknowledgement\n      return;\n    } // message is either a notification, or its a ProviderMessageResponse\n\n\n    logger.debug('RECEIVED MESSAGE FROM WALLET', message.idx, message);\n    const requestIdx = message.idx;\n    const responseCallback = this.responseCallbacks.get(requestIdx);\n\n    if (requestIdx) {\n      this.responseCallbacks.delete(requestIdx);\n    } // OPEN response\n    //\n    // Flip opened flag, and flush the pending queue\n\n\n    if (message.type === EventType.OPEN && !this.isOpened()) {\n      var _message$data, _message$data2;\n\n      if (this._sessionId && this._sessionId !== ((_message$data = message.data) == null ? void 0 : _message$data.sessionId)) {\n        logger.debug('open event received from wallet, but does not match sessionId', this._sessionId);\n        return;\n      } // check if open error occured due to invalid defaultNetworkId\n\n\n      if ((_message$data2 = message.data) != null && _message$data2.error) {\n        var _message$data3;\n\n        const err = new Error(`opening wallet failed: received ${(_message$data3 = message.data) == null ? void 0 : _message$data3.error}`);\n        logger.error(err);\n        this.close();\n        throw err;\n      } // success!\n\n\n      this.state = OpenState.OPENED;\n      this.openPayload = message.data;\n      this.events.emit('open', this.openPayload); // flush pending requests when connected\n\n      if (this.pendingMessageRequests.length !== 0) {\n        const pendingMessageRequests = this.pendingMessageRequests.splice(0, this.pendingMessageRequests.length);\n        pendingMessageRequests.forEach(async function (pendingMessageRequest) {\n          _this2.sendMessage(pendingMessageRequest);\n        });\n      }\n\n      return;\n    } // MESSAGE resposne\n\n\n    if (message.type === EventType.MESSAGE) {\n      // Require user confirmation, bring up wallet to prompt for input then close\n      // TODO: perhaps apply technique like in multicall to queue messages within\n      // a period of time, then close the window if responseCallbacks is empty, this is better.\n      if (this.confirmationOnly) {\n        setTimeout(() => {\n          if (this.responseCallbacks.size === 0) {\n            this.closeWallet();\n          }\n        }, 500); // TODO: be smarter about timer as we're processing the response callbacks..\n      }\n\n      if (!responseCallback) {\n        // NOTE: this would occur if 'idx' isn't set, which should never happen\n        // or when we register two handler, or duplicate messages with the same idx are sent,\n        // all of which should be prevented prior to getting to this point\n        throw new Error('impossible state');\n      } // Callback to original caller\n\n\n      if (responseCallback) {\n        this.events.emit('message', message);\n        responseCallback(message.data.error, message);\n        return;\n      }\n    } // ACCOUNTS_CHANGED -- when a user logs in or out\n\n\n    if (message.type === EventType.ACCOUNTS_CHANGED) {\n      this.accountsChangedPayload = {\n        accounts: []\n      };\n\n      if (message.data && message.data.length > 0) {\n        this.accountsChangedPayload = {\n          accounts: [ethers.utils.getAddress(message.data[0])],\n          origin: message.origin\n        };\n        this.events.emit('accountsChanged', this.accountsChangedPayload.accounts, this.accountsChangedPayload.origin);\n      } else {\n        this.events.emit('accountsChanged', [], message.origin);\n      }\n\n      return;\n    } // CHAIN_CHANGED -- when a user changes their default chain\n\n\n    if (message.type === EventType.CHAIN_CHANGED) {\n      this.events.emit('chainChanged', message.data);\n      return;\n    } // NOTIFY NETWORKS -- when a user connects or logs in\n\n\n    if (message.type === EventType.NETWORKS) {\n      this.networksPayload = message.data;\n      this.events.emit('networks', this.networksPayload);\n      return;\n    } // NOTIFY WALLET_CONTEXT -- when a user connects or logs in\n\n\n    if (message.type === EventType.WALLET_CONTEXT) {\n      this.walletContextPayload = message.data;\n      this.events.emit('walletContext', this.walletContextPayload);\n      return;\n    } // NOTIFY CLOSE -- when wallet instructs to close\n\n\n    if (message.type === EventType.CLOSE) {\n      if (this.state !== OpenState.CLOSED) {\n        this.close(message.data);\n      }\n    } // NOTIFY CONNECT -- when wallet instructs we've connected\n\n\n    if (message.type === EventType.CONNECT) {\n      this.connectPayload = message.data;\n      this.events.emit('connect', this.connectPayload);\n    } // NOTIFY DISCONNECT -- when wallet instructs to disconnect\n\n\n    if (message.type === EventType.DISCONNECT) {\n      if (this.isConnected()) {\n        this.events.emit('disconnect', message.data);\n        this.close();\n      }\n    }\n  } // sendMessageRequest sends a ProviderMessageRequest over the wire to the wallet\n\n\n  sendMessage(message) {\n    throw new Error('abstract method');\n  }\n\n  on(event, fn) {\n    this.events.on(event, fn);\n  }\n\n  once(event, fn) {\n    this.events.once(event, fn);\n  }\n\n  emit(event, ...args) {\n    return this.events.emit(event, ...args);\n  }\n\n  close(error) {\n    if (this.state === OpenState.CLOSED) return;\n    this.state = OpenState.CLOSED;\n    this.confirmationOnly = false;\n    this._sessionId = undefined;\n    logger.info('closing wallet and flushing!'); // flush pending requests and return error to all callbacks\n\n    this.pendingMessageRequests.length = 0;\n    this.responseCallbacks.forEach(responseCallback => {\n      responseCallback(_extends({}, new Error('wallet closed'), {\n        code: 4001\n      }));\n    });\n    this.responseCallbacks.clear();\n    this.connectPayload = undefined;\n    this.openPayload = undefined;\n    this.accountsChangedPayload = undefined;\n    this.networksPayload = undefined;\n    this.walletContextPayload = undefined;\n    this.events.emit('close', error);\n  }\n\n}\n\nconst SIGNER_READY_TIMEOUT = 10000;\nclass WalletRequestHandler {\n  // signer interface of the wallet. A null value means there is no signer (ie. user not signed in). An undefined\n  // value means the signer state is unknown, usually meaning the wallet app is booting up and initializing. Of course\n  // a Signer value is the actually interface to a signed-in account\n  constructor(_signer, prompter, mainnetNetworks, testnetNetworks = []) {\n    var _this = this;\n\n    this.signer = void 0;\n    this.signerReadyCallbacks = [];\n    this.prompter = void 0;\n    this.mainnetNetworks = void 0;\n    this.testnetNetworks = void 0;\n    this._openIntent = void 0;\n    this._connectOptions = void 0;\n    this._defaultNetworkId = void 0;\n    this._chainId = void 0;\n    this.events = new EventEmitter2();\n\n    this.promptConnect = async function (options) {\n      if (!options && !_this._connectOptions) {\n        // this is an unexpected state and should not happen\n        throw new Error('prompter connect options are empty');\n      }\n\n      if (!_this.prompter) {\n        // if prompter is null, we'll auto connect\n        return _this.connect(options);\n      }\n\n      const promptConnectDetails = await _this.prompter.promptConnect(options || _this._connectOptions).catch(_ => {\n        return {\n          connected: false\n        };\n      });\n      const connectDetails = promptConnectDetails;\n\n      if (connectDetails.connected && !connectDetails.session) {\n        connectDetails.session = await _this.walletSession();\n      }\n\n      return promptConnectDetails;\n    };\n\n    this.sendAsync = async function (request, callback, chainId) {\n      const response = {\n        jsonrpc: '2.0',\n        id: request.id,\n        result: null\n      };\n      await _this.getSigner();\n\n      try {\n        // only allow public json rpc method to the provider when user is not logged in, aka signer is not set\n        if ((!_this.signer || _this.signer === null) && !permittedJsonRpcMethods.includes(request.method)) {\n          // throw new Error(`not logged in. ${request.method} is unavailable`)\n          throw ErrSignedInRequired;\n        } // wallet signer\n\n\n        const signer = _this.signer;\n        if (!signer) throw new Error('WalletRequestHandler: wallet signer is not configured'); // fetch the provider for the specific chain, or undefined will select defaultChain\n\n        const provider = await signer.getProvider(chainId);\n        if (!provider) throw new Error(`WalletRequestHandler: wallet provider is not configured for chainId ${chainId}`);\n\n        switch (request.method) {\n          case 'net_version':\n            {\n              const result = await provider.send('net_version', []);\n              response.result = result;\n              break;\n            }\n\n          case 'eth_chainId':\n            {\n              const result = await provider.send('eth_chainId', []);\n              response.result = result;\n              break;\n            }\n\n          case 'eth_accounts':\n            {\n              const walletAddress = await signer.getAddress();\n              response.result = [walletAddress];\n              break;\n            }\n\n          case 'eth_getBalance':\n            {\n              const [accountAddress, blockTag] = request.params;\n              const walletBalance = await provider.getBalance(accountAddress, blockTag);\n              response.result = walletBalance.toHexString();\n              break;\n            }\n\n          case 'personal_sign':\n          case 'eth_sign':\n            {\n              // note: message from json-rpc input is in hex format\n              let message; // there is a difference in the order of the params:\n              // personal_sign: [data, address]\n              // eth_sign: [address, data]\n\n              if (request.method === 'personal_sign') {\n                const [data, address] = request.params;\n                message = data;\n              } else {\n                const [address, data] = request.params;\n                message = data;\n              }\n\n              let sig = ''; // Message must be prefixed with \"\\x19Ethereum Signed Message:\\n\"\n              // as defined by EIP-191\n\n              const prefixedMessage = prefixEIP191Message(message); // TODO:\n              // if (process.env.TEST_MODE === 'true' && this.prompter === null) {\n\n              if (_this.prompter === null) {\n                // prompter is null, so we'll sign from here\n                sig = await signer.signMessage(prefixedMessage, chainId);\n              } else {\n                const promptResultForDeployment = await _this.handleConfirmWalletDeployPrompt(_this.prompter, signer, chainId);\n\n                if (promptResultForDeployment) {\n                  sig = await _this.prompter.promptSignMessage({\n                    chainId: chainId,\n                    message: prefixedMessage\n                  }, _this.connectOptions);\n                }\n              }\n\n              if (sig && sig.length > 0) {\n                response.result = sig;\n              } else {\n                // The user has declined the request when value is null\n                throw new Error('declined by user');\n              }\n\n              break;\n            }\n\n          case 'eth_signTypedData':\n          case 'eth_signTypedData_v4':\n            {\n              // note: signingAddress from json-rpc input is in hex format, and typedDataObject\n              // should be an object, but in some instances may be double string encoded\n              const [signingAddress, typedDataObject] = request.params;\n              let typedData = undefined;\n\n              if (typeof typedDataObject === 'string') {\n                try {\n                  typedData = JSON.parse(typedDataObject);\n                } catch (e) {}\n              } else {\n                typedData = typedDataObject;\n              }\n\n              if (!typedData || !typedData.domain || !typedData.types || !typedData.message) {\n                throw new Error('invalid typedData object');\n              }\n\n              let sig = '';\n\n              if (_this.prompter === null) {\n                // prompter is null, so we'll sign from here\n                sig = await signer.signTypedData(typedData.domain, typedData.types, typedData.message, chainId);\n              } else {\n                const promptResultForDeployment = await _this.handleConfirmWalletDeployPrompt(_this.prompter, signer, chainId);\n\n                if (promptResultForDeployment) {\n                  sig = await _this.prompter.promptSignMessage({\n                    chainId: chainId,\n                    typedData: typedData\n                  }, _this.connectOptions);\n                }\n              }\n\n              if (sig && sig.length > 0) {\n                response.result = sig;\n              } else {\n                // The user has declined the request when value is null\n                throw new Error('declined by user');\n              }\n\n              break;\n            }\n\n          case 'eth_sendTransaction':\n            {\n              // https://eth.wiki/json-rpc/API#eth_sendtransaction\n              const [transactionParams] = request.params;\n              let txnHash = '';\n\n              if (_this.prompter === null) {\n                // prompter is null, so we'll send from here\n                const txnResponse = await signer.sendTransaction(transactionParams, chainId);\n                txnHash = txnResponse.hash;\n              } else {\n                // prompt user to provide the response\n                txnHash = await _this.prompter.promptSendTransaction(transactionParams, chainId, _this.connectOptions);\n              }\n\n              if (txnHash) {\n                response.result = txnHash;\n              } else {\n                // The user has declined the request when value is null\n                throw new Error('declined by user');\n              }\n\n              break;\n            }\n\n          case 'eth_signTransaction':\n            {\n              // https://eth.wiki/json-rpc/API#eth_signTransaction\n              const [transaction] = request.params;\n              const sender = ethers.utils.getAddress(transaction.from);\n\n              if (sender !== (await signer.getAddress())) {\n                throw new Error('sender address does not match wallet');\n              }\n\n              if (_this.prompter === null) {\n                // The eth_signTransaction method expects a `string` return value we instead return a `SignedTransactions` object,\n                // this can only be broadcasted using an RPC provider with support for signed Sequence transactions, like this one.\n                //\n                // TODO: verify serializing / transporting the SignedTransaction object works as expected, most likely however\n                // we will want to resolveProperties the bignumber values to hex strings\n                response.result = await signer.signTransactions(transaction, chainId);\n              } else {\n                response.result = await _this.prompter.promptSignTransaction(transaction, chainId, _this.connectOptions);\n              }\n\n              break;\n            }\n\n          case 'eth_sendRawTransaction':\n            {\n              // NOTE: we're not using a prompter here as the transaction is already signed\n              // and would have prompted the user upon signing.\n              // https://eth.wiki/json-rpc/API#eth_sendRawTransaction\n              if (isSignedTransactions(request.params[0])) {\n                const txChainId = BigNumber.from(request.params[0].chainId).toNumber();\n                const tx = await (await signer.getRelayer(txChainId)).relay(request.params[0]);\n                response.result = (await tx).hash;\n              } else {\n                const tx = await provider.sendTransaction(request.params[0]);\n                response.result = tx.hash;\n              }\n\n              break;\n            }\n\n          case 'eth_getTransactionCount':\n            {\n              const address = ethers.utils.getAddress(request.params[0]);\n              const tag = request.params[1];\n              const walletAddress = ethers.utils.getAddress(await signer.getAddress());\n\n              if (address === walletAddress) {\n                const count = await signer.getTransactionCount(tag);\n                response.result = ethers.BigNumber.from(count).toHexString();\n              } else {\n                const count = await provider.getTransactionCount(address, tag);\n                response.result = ethers.BigNumber.from(count).toHexString();\n              }\n\n              break;\n            }\n\n          case 'eth_blockNumber':\n            {\n              response.result = await provider.getBlockNumber();\n              break;\n            }\n\n          case 'eth_getBlockByNumber':\n            {\n              response.result = await provider.getBlock(request.params[0]\n              /* , jsonRpcRequest.params[1] */\n              );\n              break;\n            }\n\n          case 'eth_getBlockByHash':\n            {\n              response.result = await provider.getBlock(request.params[0]\n              /* , jsonRpcRequest.params[1] */\n              );\n              break;\n            }\n\n          case 'eth_getTransactionByHash':\n            {\n              response.result = await provider.getTransaction(request.params[0]);\n              break;\n            }\n\n          case 'eth_call':\n            {\n              const [transactionObject, blockTag] = request.params;\n              response.result = await provider.call(transactionObject, blockTag);\n              break;\n            }\n\n          case 'eth_getCode':\n            {\n              const [contractAddress, blockTag] = request.params;\n              response.result = await provider.getCode(contractAddress, blockTag);\n              break;\n            }\n\n          case 'eth_estimateGas':\n            {\n              const [transactionObject] = request.params;\n              response.result = await provider.estimateGas(transactionObject);\n              break;\n            }\n\n          case 'eth_gasPrice':\n            {\n              const gasPrice = await provider.getGasPrice();\n              response.result = gasPrice.toHexString();\n              break;\n            }\n\n          case 'wallet_switchEthereumChain':\n            {\n              const [switchParams] = request.params;\n\n              if (!switchParams.chainId || switchParams.chainId.length === 0) {\n                throw new Error('invalid chainId');\n              }\n\n              const _chainId = ethers.BigNumber.from(switchParams.chainId);\n\n              const ok = await _this.setDefaultNetwork(_chainId.toString(), true);\n\n              if (!ok) {\n                throw new Error(`unable to set chainId ${_chainId}`);\n              }\n\n              response.result = null; // success\n\n              break;\n            }\n          // smart wallet method\n\n          case 'sequence_getWalletContext':\n            {\n              response.result = await signer.getWalletContext();\n              break;\n            }\n          // smart wallet method\n\n          case 'sequence_getWalletConfig':\n            {\n              const [_chainId2] = request.params;\n              response.result = await signer.getWalletConfig(_chainId2);\n              break;\n            }\n          // smart wallet method\n\n          case 'sequence_getWalletState':\n            {\n              const [_chainId3] = request.params;\n              response.result = await signer.getWalletState(_chainId3);\n              break;\n            }\n          // smart wallet method\n\n          case 'sequence_getNetworks':\n            {\n              // NOTE: must ensure that the response result below returns clean serialized data, which is to omit\n              // the provider and relayer objects and only return the urls so can be reinstantiated on dapp side.\n              // This is handled by this.getNetworks() but noted here for future readers.\n              response.result = await _this.getNetworks(true);\n              break;\n            }\n          // smart wallet method\n\n          case 'sequence_updateConfig':\n            {\n              throw new Error('sequence_updateConfig method is not allowed from a dapp'); // NOTE: method is disabled as we don't need a dapp to request to update a config.\n              // However, if we ever want this, we can enable it but must also use the prompter\n              // for confirmation.\n              //\n              // const [newConfig] = request.params\n              // response.result = await signer.updateConfig(newConfig)\n\n              break;\n            }\n          // smart wallet method\n\n          case 'sequence_publishConfig':\n            {\n              throw new Error('sequence_publishConfig method is not allowed from a dapp');\n              break;\n            }\n          // relayer method\n\n          case 'sequence_estimateGasLimits':\n            {\n              // TODO\n              break;\n            }\n          // relayer method\n\n          case 'sequence_gasRefundOptions':\n            {\n              // TODO\n              break;\n            }\n          // relayer method\n\n          case 'sequence_getNonce':\n            {\n              // TODO\n              break;\n            }\n          // relayer method\n\n          case 'sequence_relay':\n            {\n              // TODO\n              break;\n            }\n          // set default network of wallet\n\n          case 'sequence_setDefaultNetwork':\n            {\n              const [defaultNetworkId] = request.params;\n\n              if (!defaultNetworkId) {\n                throw new Error('invalid request, method argument defaultNetworkId cannot be empty');\n              }\n\n              const ok = await _this.setDefaultNetwork(defaultNetworkId);\n\n              if (!ok) {\n                throw new Error(`unable to set default network ${defaultNetworkId}`);\n              }\n\n              response.result = await _this.getNetworks(true);\n              break;\n            }\n\n          default:\n            {\n              // NOTE: provider here will be chain-bound if chainId is provided\n              const providerResponse = await provider.send(request.method, request.params);\n              response.result = providerResponse;\n            }\n        }\n      } catch (err) {\n        logger.error(err); // See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1193.md#rpc-errors\n\n        response.result = null;\n        response.error = _extends({}, new Error(err), {\n          code: 4001\n        });\n      }\n\n      callback(undefined, response);\n    };\n\n    this.isSignedIn = async function () {\n      await _this.signerReady();\n      return !!_this.signer;\n    };\n\n    this.getSigner = async function () {\n      await _this.signerReady();\n\n      if (_this.signer === undefined) {\n        throw new Error('signerReady failed resolve');\n      }\n\n      return _this.signer;\n    };\n\n    this.signer = _signer;\n    this.prompter = prompter;\n    this.mainnetNetworks = mainnetNetworks;\n    this.testnetNetworks = testnetNetworks;\n  }\n\n  async signIn(signer, options = {}) {\n    this.setSigner(signer);\n    const {\n      connect,\n      mainnetNetworks,\n      testnetNetworks,\n      defaultNetworkId\n    } = options;\n\n    if (mainnetNetworks && mainnetNetworks.length > 0) {\n      this.mainnetNetworks = mainnetNetworks;\n    }\n\n    if (testnetNetworks && testnetNetworks.length > 0) {\n      this.testnetNetworks = testnetNetworks;\n    }\n\n    if ((!this.mainnetNetworks || this.mainnetNetworks.length === 0) && (!this.testnetNetworks || this.testnetNetworks.length === 0)) {\n      throw new Error('signIn failed as network configuration is empty');\n    }\n\n    const networkId = defaultNetworkId || this._defaultNetworkId;\n\n    if (networkId) {\n      if (!(await this.setDefaultNetwork(networkId, false))) {\n        throw new Error(`WalletRequestHandler setup unable to set defaultNetworkId ${networkId}`);\n      }\n    } // Optionally, connect the dapp and wallet. In case connectOptions are provided, we will perform\n    // necessary auth request, and then notify the dapp of the 'connect' details.\n    //\n    // NOTE: if a user is signing into a dapp from a fresh state, and and auth request is made\n    // we don't trigger the promptConnect flow, as we consider the user just authenticated\n    // for this dapp, so its safe to authorize in the connect() method without the prompt.\n    //\n    // NOTE: signIn can optionally connect and notify dapp at this time for new signIn flows\n\n\n    if (connect) {\n      const connectOptions = this._connectOptions;\n      const connectDetails = await this.connect(connectOptions);\n      this.notifyConnect(connectDetails);\n\n      if (!connectOptions || connectOptions.keepWalletOpened !== true) {\n        this.notifyClose();\n      }\n    }\n  }\n\n  signOut() {\n    // signed out state\n    this.setSigner(null);\n  }\n\n  signerReset() {\n    // resetting signer puts the wallet in an uninitialized state, which requires the app to\n    // re-initiatize and set the signer either as \"null\" (ie. no signer) or \"Signer\" (ie. signed in).\n    this.signer = undefined;\n  }\n\n  signerReady(timeout = SIGNER_READY_TIMEOUT) {\n    return new Promise((resolve, reject) => {\n      if (this.signer !== undefined) {\n        resolve();\n      } else {\n        setTimeout(() => {\n          if (this.signer === undefined) {\n            this.signerReadyCallbacks = [];\n            reject(`signerReady timed out`);\n          }\n        }, timeout);\n        this.signerReadyCallbacks.push(resolve);\n      }\n    });\n  }\n\n  async connect(options) {\n    if (!this.signer) {\n      return {\n        connected: false,\n        chainId: '0x0',\n        error: 'unable to connect without signed in account'\n      };\n    }\n\n    const connectDetails = {\n      connected: true,\n      chainId: ethers.utils.hexlify(await this.getChainId())\n    };\n\n    if (options && options.authorize) {\n      // Perform ethauth eip712 request and construct the ConnectDetails response\n      // including the auth proof\n      const authOptions = {\n        app: options.app,\n        origin: options.origin,\n        expiry: options.expiry\n      }; // if (typeof(options.authorize) === 'object') {\n      //   authOptions = { ...authOptions, ...options.authorize }\n      // }\n\n      try {\n        connectDetails.proof = await signAuthorization(this.signer, authOptions);\n      } catch (err) {\n        logger.warn(`connect, signAuthorization failed for options: ${JSON.stringify(options)}, due to: ${err.message}`);\n        return {\n          connected: false,\n          chainId: '0x0',\n          error: `signAuthorization failed: ${err.message}`\n        };\n      }\n    } // Build session response for connect details\n\n\n    connectDetails.session = await this.walletSession();\n    return connectDetails;\n  }\n\n  // sendMessageRequest will unwrap the ProviderMessageRequest and send it to the JsonRpcHandler\n  // (aka, the signer in this instance) and then responds with a wrapped response of\n  // ProviderMessageResponse to be sent over the transport\n  sendMessageRequest(message) {\n    return new Promise(resolve => {\n      this.sendAsync(message.data, (error, response) => {\n        // TODO: if response includes data.error, why do we need a separate error argument here?\n        const responseMessage = _extends({}, message, {\n          data: response\n        }); // NOTE: we always resolve here, are the sendAsync call will wrap any exceptions\n        // in the error field of the response to ensure we send back to the user\n\n\n        resolve(responseMessage);\n      }, message.chainId);\n    });\n  } // sendAsync implements the JsonRpcHandler interface for sending JsonRpcRequests to the wallet\n\n\n  on(event, fn) {\n    this.events.on(event, fn);\n  }\n\n  once(event, fn) {\n    this.events.once(event, fn);\n  }\n\n  async getAddress() {\n    if (!this.signer) {\n      return '';\n    } else {\n      return this.signer.getAddress();\n    }\n  }\n\n  async getChainId() {\n    if (!this.signer) {\n      return 0;\n    } else {\n      if (this._chainId) return this._chainId; // memoized\n\n      this._chainId = await this.signer.getChainId();\n      return this._chainId;\n    }\n  }\n\n  get openIntent() {\n    return this._openIntent;\n  }\n\n  setOpenIntent(intent) {\n    this._openIntent = intent;\n  }\n\n  get connectOptions() {\n    return this._connectOptions;\n  }\n\n  setConnectOptions(options) {\n    this._connectOptions = options;\n  }\n\n  get defaultNetworkId() {\n    return this._defaultNetworkId;\n  }\n\n  async setDefaultNetwork(chainId, notifyNetworks = true) {\n    if (!chainId) return undefined;\n    this._defaultNetworkId = chainId;\n    this._chainId = undefined;\n\n    if (this.signer && this.signer.setNetworks) {\n      const defaultChainId = this.signer.setNetworks(this.mainnetNetworks, this.testnetNetworks, chainId);\n\n      if (defaultChainId && notifyNetworks) {\n        await this.notifyNetworks();\n      }\n\n      return defaultChainId;\n    } else {\n      return undefined;\n    }\n  }\n\n  async getNetworks(jsonRpcResponse) {\n    if (!this.signer) {\n      logger.warn('signer not set: getNetworks is returning an empty list');\n      return [];\n    }\n\n    const networks = await this.signer.getNetworks();\n\n    if (jsonRpcResponse) {\n      // omit provider and relayer objects as they are not serializable\n      return networks.map(n => {\n        const network = _extends({}, n);\n\n        network.provider = undefined;\n        network.relayer = undefined;\n        return network;\n      });\n    } else {\n      return networks;\n    }\n  }\n\n  async walletSession() {\n    return !this.signer ? undefined : {\n      walletContext: await this.signer.getWalletContext(),\n      accountAddress: await this.signer.getAddress(),\n      networks: await this.getNetworks(true)\n    };\n  }\n\n  notifyConnect(connectDetails, origin) {\n    var _connectDetails$sessi;\n\n    this.events.emit('connect', connectDetails);\n\n    if ((_connectDetails$sessi = connectDetails.session) != null && _connectDetails$sessi.accountAddress) {\n      var _connectDetails$sessi2;\n\n      this.events.emit('accountsChanged', [(_connectDetails$sessi2 = connectDetails.session) == null ? void 0 : _connectDetails$sessi2.accountAddress], origin);\n    }\n  }\n\n  notifyDisconnect(origin) {\n    this.events.emit('accountsChanged', [], origin);\n    this.events.emit('disconnect');\n  }\n\n  async notifyNetworks(networks) {\n    const n = networks || (await this.getNetworks(true));\n    this.events.emit('networks', n);\n\n    if (n.length > 0) {\n      const defaultNetwork = n.find(network => network.isDefaultChain);\n\n      if (defaultNetwork) {\n        this.events.emit('chainChanged', ethers.utils.hexlify(defaultNetwork.chainId));\n      }\n    } else {\n      this.events.emit('chainChanged', '0x0');\n    }\n  }\n\n  async notifyWalletContext() {\n    if (!this.signer) {\n      logger.warn('signer not set: skipping to notify wallet context');\n      return;\n    }\n\n    const walletContext = await this.signer.getWalletContext();\n    this.events.emit('walletContext', walletContext);\n  }\n\n  notifyClose(error) {\n    this.events.emit('close', error);\n  }\n\n  setSigner(signer) {\n    this.signer = signer;\n\n    if (signer !== undefined) {\n      for (let i = 0; i < this.signerReadyCallbacks.length; i++) {\n        this.signerReadyCallbacks[i]();\n      }\n\n      this.signerReadyCallbacks = [];\n    }\n  }\n\n  async handleConfirmWalletDeployPrompt(prompter, signer, chainId) {\n    // check if wallet is deployed and up to date, if not, prompt user to deploy\n    // if no chainId is provided, we'll assume the wallet is auth chain wallet and is up to date\n    if (!chainId) {\n      return true;\n    }\n\n    const isUpToDate = await isWalletUpToDate(signer, chainId);\n\n    if (isUpToDate) {\n      return true;\n    }\n\n    const promptResult = await prompter.promptConfirmWalletDeploy(chainId, this.connectOptions); // if client returned true, check again to make sure wallet is deployed and up to date\n\n    if (promptResult) {\n      const isPromptResultCorrect = await isWalletUpToDate(signer, chainId);\n\n      if (!isPromptResultCorrect) {\n        logger.error('WalletRequestHandler: result for promptConfirmWalletDeploy is not correct');\n        return false;\n      } else {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n}\nconst permittedJsonRpcMethods = ['net_version', 'eth_chainId', 'eth_getBalance', 'eth_getTransactionCount', 'eth_blockNumber', 'eth_getBlockByNumber', 'eth_getBlockByHash', 'eth_getTransactionByHash', 'eth_getCode', 'eth_estimateGas', 'eth_gasPrice', 'sequence_getWalletContext', 'sequence_getNetworks', 'sequence_setDefaultNetwork'];\n\nclass Web3Provider extends Web3Provider$1 {\n  static isSequenceProvider(cand) {\n    return isSequenceProvider(cand);\n  }\n\n  constructor(provider, defaultChainId) {\n    const sender = new JsonRpcSender(provider, maybeChainId(defaultChainId));\n    provider = sender;\n    super(provider, 'any');\n    this._sender = void 0;\n    this._isSequenceProvider = void 0;\n    this._defaultChainId = void 0;\n    this._sender = sender;\n    this._isSequenceProvider = true;\n    this._defaultChainId = maybeChainId(defaultChainId);\n  }\n\n  sendAsync(request, callback, chainId) {\n    this._sender.sendAsync(request, callback, chainId);\n  }\n\n  send(method, params, chainId) {\n    return this._sender.send(method, params, chainId);\n  }\n\n  request(request) {\n    return this.send(request.method, request.params || [], request.chainId);\n  }\n\n  getSigner() {\n    return new Web3Signer(this, this._defaultChainId);\n  }\n\n  async getChainId() {\n    // TODO: is it safe to memoize this?\n    const result = await this.send('eth_chainId', []);\n    const chainId = ethers.BigNumber.from(result).toNumber();\n\n    if (this._defaultChainId && this._defaultChainId !== chainId) {\n      throw new Error(`provider chainId (${chainId}) does not match provider-bound chainId ${this._defaultChainId}`);\n    }\n\n    return chainId;\n  }\n\n}\nfunction isSequenceProvider(provider) {\n  const cand = provider;\n  return cand && cand.send !== undefined && cand._isSequenceProvider === true;\n}\nclass LocalWeb3Provider extends Web3Provider {\n  constructor(signer, networks) {\n    const walletRequestHandler = new WalletRequestHandler(signer, null, networks || []);\n    super(walletRequestHandler);\n  }\n\n}\nclass Web3Signer extends Signer {\n  constructor(provider, defaultChainId) {\n    super();\n    this.provider = void 0;\n    this.defaultChainId = void 0;\n    this._address = void 0;\n    this._index = void 0;\n    this._context = void 0;\n    this._networks = void 0;\n    this._providers = {};\n    this.provider = provider;\n    this.defaultChainId = defaultChainId;\n  } // memoized\n\n\n  //\n  // ethers AbstractSigner methods\n  //\n  async getAddress() {\n    if (this._address) return this._address;\n    const accounts = await this.provider.send('eth_accounts', []);\n    this._address = accounts[0];\n    this._index = 0;\n    return ethers.utils.getAddress(this._address);\n  }\n\n  signTransaction(transaction) {\n    // TODO .. since ethers isn't using this method, perhaps we will?\n    throw new Error('signTransaction is unsupported, use signTransactions instead');\n  }\n\n  connect(provider) {\n    throw new Error('unsupported: cannot alter JSON-RPC Signer connection');\n  } //\n  // Sequence Signer methods\n  //\n  // getProvider returns a Web3Provider instance for the current chain. Note that this method\n  // and signer is bound to a particular chain to prevent misuse. If you'd like a provider\n  // for a specific chain, try getSender(chainId), or wallet.getProvider(chainId).\n\n\n  async getProvider(chainId) {\n    if (chainId) {\n      const currentChainId = await this.getChainId();\n\n      if (currentChainId !== chainId) {\n        throw new Error(`signer is attempting to access chain ${chainId}, but is already bound to chain ${currentChainId}`);\n      }\n    }\n\n    return this.provider;\n  } // getSender returns a Web3Provider instance via the signer transport. Note: for our case\n  // the of sequence wallet, this will bring up the wallet window whenever using it, as the json-rpc\n  // requests are sent to the window transport. Therefore, for anything non-signing related\n  // you can write a higher-order JsonRpcRouter sender to route to the public provider endpoints\n  // as we do in the WalletProvider.\n  //\n  // This method is primarily utilized internally when routing requests to a particular chainId.\n\n\n  async getSender(chainId) {\n    if (!chainId || chainId && chainId === this.defaultChainId) {\n      return this.provider;\n    }\n\n    if (!this._providers[chainId]) {\n      this._providers[chainId] = new Web3Provider(new JsonRpcSender(this.provider, chainId), chainId);\n    }\n\n    return this._providers[chainId];\n  }\n\n  getRelayer(chainId) {\n    // TODO: JsonRpcRelayer ......? or, Web3Relayer.. or SequenceRelayer?\n    // sequence_estimateGasLimits\n    // sequence_gasRefundOptions\n    // sequence_getNonce\n    // sequence_relay\n    throw new Error('TODO');\n  }\n\n  async getWalletContext() {\n    if (!this._context) {\n      this._context = await this.provider.send('sequence_getWalletContext', []);\n    }\n\n    return this._context;\n  }\n\n  async getWalletConfig(chainId) {\n    return await this.provider.send('sequence_getWalletConfig', [maybeChainId(chainId)], maybeChainId(chainId) || this.defaultChainId);\n  }\n\n  async getWalletState(chainId) {\n    return await this.provider.send('sequence_getWalletState', [maybeChainId(chainId)], maybeChainId(chainId) || this.defaultChainId);\n  }\n\n  async getNetworks() {\n    if (!this._networks) {\n      this._networks = await this.provider.send('sequence_getNetworks', []);\n    }\n\n    return this._networks;\n  }\n\n  async getSigners() {\n    const networks = await this.getNetworks();\n    const authChainId = networks.find(n => n.isAuthChain);\n\n    if (!authChainId) {\n      throw new Error('authChainId could not be determined from network list');\n    }\n\n    const walletConfig = await this.getWalletConfig(authChainId);\n\n    if (!walletConfig || walletConfig.length === 0) {\n      throw new Error(`walletConfig returned zero results for authChainId {authChainId}`);\n    }\n\n    return walletConfig[0].signers.map(s => s.address);\n  } // signMessage matches implementation from ethers JsonRpcSigner for compatibility, but with\n  // multi-chain support.\n\n\n  async signMessage(message, chainId, allSigners) {\n    const provider = await this.getSender(maybeChainId(chainId) || this.defaultChainId);\n    const data = typeof message === 'string' ? ethers.utils.toUtf8Bytes(message) : message;\n    const address = await this.getAddress(); // NOTE: as of ethers v5.5, it switched to using personal_sign, see\n    // https://github.com/ethers-io/ethers.js/pull/1542 and see\n    // https://github.com/WalletConnect/walletconnect-docs/issues/32 for additional info.\n\n    return await provider.send('personal_sign', [ethers.utils.hexlify(data), address]);\n  } // signTypedData matches implementation from ethers JsonRpcSigner for compatibility, but with\n  // multi-chain support.\n\n\n  async signTypedData(domain, types, message, chainId, allSigners) {\n    // Populate any ENS names (in-place)\n    // const populated = await ethers.utils._TypedDataEncoder.resolveNames(domain, types, message, (name: string) => {\n    //   return this.provider.resolveName(name)\n    // })\n    return await this.provider.send('eth_signTypedData_v4', [await this.getAddress(), ethers.utils._TypedDataEncoder.getPayload(domain, types, message)], maybeChainId(chainId) || this.defaultChainId);\n  } // sendTransaction matches implementation from ethers JsonRpcSigner for compatibility, but with\n  // multi-chain support.\n\n\n  async sendTransaction(transaction, chainId, allSigners) {\n    const provider = await this.getSender(maybeChainId(chainId) || this.defaultChainId);\n    const tx = this.sendUncheckedTransaction(transaction, chainId).then(hash => {\n      return ethers.utils.poll(() => {\n        return provider.getTransaction(hash).then(tx => {\n          if (tx === null) {\n            return undefined;\n          }\n\n          return provider._wrapTransaction(tx, hash);\n        });\n      }, {\n        onceBlock: this.provider\n      }).catch(error => {\n        error.transactionHash = hash;\n        throw error;\n      });\n    }); // @ts-ignore\n\n    return tx;\n  } // sendTransactionBatch is a convenience method to call sendTransaction in a batch format, allowing you to\n  // send multiple transaction as a single payload and just one on-chain transaction.\n\n\n  async sendTransactionBatch(transactions, chainId, allSigners) {\n    const batch = await resolveArrayProperties(transactions);\n\n    if (!batch || batch.length === 0) {\n      throw new Error('cannot send empty batch');\n    } // sendTransactionBatch only accepts TransactionRequest, not TransactionResponses\n\n\n    if (batch.find(v => v.wait !== undefined && v.wait !== null)) {\n      throw new Error('transaction request expected for sendTransactionBatch, transaction response found');\n    }\n\n    const tx = _extends({}, batch[0]);\n\n    if (batch.length > 1) {\n      tx.auxiliary = batch.splice(1);\n    }\n\n    return this.sendTransaction(tx, chainId, allSigners);\n  }\n\n  signTransactions(transaction, chainId, allSigners) {\n    transaction = shallowCopy(transaction); // TODO: transaction argument..? make sure to resolve any properties and serialize property before sending over\n    // the wire.. see sendUncheckedTransaction and resolveProperties\n\n    return this.provider.send('eth_signTransaction', [transaction], maybeChainId(chainId) || this.defaultChainId);\n  }\n\n  sendSignedTransactions(signedTxs, chainId) {\n    // sequence_relay\n    throw new Error('TODO');\n  } // updateConfig..\n  // NOTE: this is not supported by the remote wallet by default.\n\n\n  async updateConfig(newConfig) {\n    // sequence_updateConfig\n    const [config, tx] = await this.provider.send('sequence_updateConfig', [newConfig], this.defaultChainId);\n\n    if (tx === null) {\n      return [config, undefined];\n    }\n\n    const provider = await this.getSender(this.defaultChainId);\n    return [config, provider._wrapTransaction(tx, tx.hash)];\n  } // publishConfig..\n  // NOTE: this is not supported by the remote wallet by default.\n\n\n  async publishConfig() {\n    const provider = await this.getSender(this.defaultChainId);\n    const tx = await provider.send('sequence_publishConfig', []);\n\n    if (tx === null) {\n      return undefined;\n    }\n\n    return provider._wrapTransaction(tx, tx.hash);\n  }\n\n  async isDeployed(chainId) {\n    const provider = await this.getSender(maybeChainId(chainId));\n    const walletCode = await provider.getCode(await this.getAddress());\n    return !!walletCode && walletCode !== '0x';\n  } //\n  // ethers JsonRpcSigner methods\n  //\n\n\n  async _legacySignMessage(message, chainId, allSigners) {\n    const provider = await this.getSender(maybeChainId(chainId) || this.defaultChainId);\n    const data = typeof message === 'string' ? ethers.utils.toUtf8Bytes(message) : message;\n    const address = await this.getAddress(); // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n    // NOTE: ethers since 5.5 has switched to using personal_sign, we should review, etc.\n\n    return await provider.send('eth_sign', [address, ethers.utils.hexlify(data)]);\n  }\n\n  async _signTypedData(domain, types, message, chainId, allSigners) {\n    return this.signTypedData(domain, types, message, chainId, allSigners);\n  }\n\n  async sendUncheckedTransaction(transaction, chainId) {\n    transaction = shallowCopy(transaction);\n    const fromAddress = this.getAddress(); // NOTE: we do not use provider estimation, and instead rely on our relayer to determine the gasLimit and gasPrice\n    //\n    // TODO: alternatively/one day, we could write a provider middleware to eth_estimateGas\n    // and send it to our relayer url instead for estimation..\n    //\n    // if (!transaction.gasLimit) {\n    //   const estimate = shallowCopy(transaction)\n    //   estimate.from = fromAddress\n    //   transaction.gasLimit = this.provider.estimateGas(estimate)\n    // }\n\n    const provider = await this.getSender(maybeChainId(chainId) || this.defaultChainId);\n    return resolveProperties({\n      tx: resolveProperties(transaction),\n      sender: await fromAddress\n    }).then(({\n      tx,\n      sender\n    }) => {\n      if (tx.from != null) {\n        if (ethers.utils.getAddress(tx.from) !== sender) {\n          // logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction)\n          throw new Error(`from address mismatch for transaction ${transaction}`);\n        }\n      } else {\n        tx.from = sender;\n      }\n\n      const hexTx = hexlifyTransaction(tx);\n      return provider.send('eth_sendTransaction', [hexTx]).then(hash => {\n        return hash;\n      }, error => {\n        // return checkError(\"sendTransaction\", error, hexTx)\n        throw new Error(`sendTransaction ${error}`);\n      });\n    });\n  }\n\n  connectUnchecked() {\n    throw new Error('connectUnchecked is unsupported');\n  }\n\n  async unlock(password) {\n    const address = await this.getAddress();\n    return this.provider.send('personal_unlockAccount', [address, password, null]);\n  }\n\n} // NOTE: method has been copied + modified from ethers.js JsonRpcProvider\n// Convert an ethers.js transaction into a JSON-RPC transaction\n\nconst allowedTransactionKeys = {\n  chainId: true,\n  data: true,\n  gasLimit: true,\n  gasPrice: true,\n  nonce: true,\n  to: true,\n  value: true,\n  from: true,\n  auxiliary: true,\n  expiration: true,\n  afterNonce: true,\n  delegateCall: true,\n  revertOnError: true\n};\n\nconst hexlifyTransaction = (transaction, allowExtra) => {\n  // Check only allowed properties are given\n  const allowed = shallowCopy(allowedTransactionKeys);\n\n  if (allowExtra) {\n    for (const key in allowExtra) {\n      if (allowExtra[key]) {\n        allowed[key] = true;\n      }\n    }\n  }\n\n  ethers.utils.checkProperties(transaction, allowed);\n  const result = {} // Some nodes (INFURA ropsten; INFURA mainnet is fine) do not like leading zeros.\n  ;\n  ['gasLimit', 'gasPrice', 'nonce', 'value'].forEach(key => {\n    if (!transaction[key]) {\n      return;\n    }\n\n    const value = ethers.utils.hexValue(transaction[key]);\n\n    if (key === 'gasLimit') {\n      key = 'gas';\n    }\n\n    result[key] = value;\n  });\n  ['from', 'to', 'data'].forEach(key => {\n    if (!transaction[key]) {\n      return;\n    }\n\n    result[key] = ethers.utils.hexlify(transaction[key]);\n  });\n  const auxiliary = transaction['auxiliary'];\n\n  if (auxiliary && auxiliary.length > 0) {\n    result['auxiliary'] = [];\n    auxiliary.forEach(a => {\n      result['auxiliary'].push(hexlifyTransaction(a));\n    });\n  }\n\n  return result;\n};\n\nconst eip191prefix = ethers.utils.toUtf8Bytes('\\x19Ethereum Signed Message:\\n');\nconst messageToBytes = message => {\n  if (ethers.utils.isBytes(message) || ethers.utils.isHexString(message)) {\n    return ethers.utils.arrayify(message);\n  }\n\n  return ethers.utils.toUtf8Bytes(message);\n};\nconst prefixEIP191Message = message => {\n  const messageBytes = messageToBytes(message);\n  return ethers.utils.concat([eip191prefix, ethers.utils.toUtf8Bytes(String(messageBytes.length)), messageBytes]);\n};\nconst isValidSignature = async (address, digest, sig, provider, chainId, walletContext) => {\n  if (!chainId) {\n    var _await$provider$getNe;\n\n    chainId = (_await$provider$getNe = await provider.getNetwork()) == null ? void 0 : _await$provider$getNe.chainId;\n  }\n\n  if (!walletContext && Web3Provider.isSequenceProvider(provider)) {\n    walletContext = await provider.getSigner().getWalletContext();\n  }\n\n  return isValidSignature$1(address, digest, sig, provider, walletContext, chainId);\n};\nconst isValidMessageSignature = async (address, message, signature, provider, chainId, walletContext) => {\n  const prefixed = prefixEIP191Message(message);\n  const digest = encodeMessageDigest(prefixed);\n  return isValidSignature(address, digest, signature, provider, chainId, walletContext);\n};\nconst isValidTypedDataSignature = (address, typedData, signature, provider, chainId, walletContext) => {\n  return isValidSignature(address, encodeTypedDataDigest(typedData), signature, provider, chainId, walletContext);\n};\nconst recoverWalletConfig = async (address, digest, signature, chainId, walletContext) => {\n  const subDigest = packMessageData(address, chainId, digest);\n  const config = await recoverConfig(subDigest, signature);\n\n  if (walletContext) {\n    const recoveredWalletAddress = addressOf(config, walletContext);\n\n    if (config.address && config.address !== recoveredWalletAddress) {\n      throw new Error('recovered address does not match the WalletConfig address, check the WalletContext');\n    } else {\n      config.address = recoveredWalletAddress;\n    }\n  }\n\n  return config;\n};\nconst isBrowserExtension = () => window.location.protocol === 'chrome-extension:' || window.location.protocol === 'moz-extension:';\n/**\n * Returns the status of a signer's wallet on given chain by checking wallet deployment and config status\n *\n * @param {Signer} signer\n * @param {number} chainId\n * @return {Promise<boolean>} Promise that returns true if the wallet is up to date, false otherwise\n */\n\nconst isWalletUpToDate = async (signer, chainId) => {\n  var _walletState$find;\n\n  const walletState = await signer.getWalletState();\n  const networks = await signer.getNetworks();\n  const walletStateForRequiredChain = walletState.find(state => state.chainId === chainId);\n\n  if (!walletStateForRequiredChain) {\n    throw new Error(`WalletRequestHandler: could not find wallet state for chainId ${chainId}`);\n  }\n\n  const isDeployed = walletStateForRequiredChain.deployed;\n\n  if (!networks) {\n    throw new Error(`isWalletUpToDate util: could not get networks from signer`);\n  }\n\n  const authChain = networks.find(network => network.isAuthChain);\n\n  if (!authChain) {\n    throw new Error(`isWalletUpToDate util: could not get auth chain network information`);\n  }\n\n  const authChainId = authChain.chainId;\n  const authChainConfig = (_walletState$find = walletState.find(state => state.chainId === authChainId)) == null ? void 0 : _walletState$find.config;\n\n  if (!authChainConfig) {\n    throw new Error(`isWalletUpToDate util: could not get auth chain config`);\n  }\n\n  const requiredChainConfig = walletStateForRequiredChain.config;\n\n  if (!requiredChainConfig) {\n    throw new Error(`isWalletUpToDate util: could not get config for chainId ${chainId}`);\n  }\n\n  const isUpToDate = isConfigEqual(authChainConfig, requiredChainConfig);\n  return isDeployed && isUpToDate;\n};\nclass LocalStorage {\n  constructor() {}\n\n  static getInstance() {\n    if (!LocalStorage._instance) {\n      LocalStorage._instance = {\n        getItem: key => Promise.resolve(window.localStorage.getItem(key)),\n        setItem: (key, value) => Promise.resolve(window.localStorage.setItem(key, value)),\n        removeItem: key => Promise.resolve(window.localStorage.removeItem(key))\n      };\n    }\n\n    return this._instance;\n  }\n\n  static use(instance) {\n    LocalStorage._instance = instance;\n  }\n\n} // window.localstorage helper\n\nLocalStorage._instance = void 0;\nclass LocalStore {\n  constructor(key, def) {\n    this.def = def;\n    this.key = void 0;\n    this.key = key;\n  }\n\n  async get() {\n    const val = await LocalStorage.getInstance().getItem(this.key);\n\n    if (val === null) {\n      return this.def;\n    }\n\n    try {\n      return JSON.parse(val);\n    } catch (err) {\n      console.error(err);\n    }\n\n    return;\n  }\n\n  set(val) {\n    val ? LocalStorage.getInstance().setItem(this.key, JSON.stringify(val)) : LocalStorage.getInstance().removeItem(this.key);\n  }\n\n  del() {\n    LocalStorage.getInstance().removeItem(this.key);\n  }\n\n}\n\nconst TRANSPORT_SESSION_LS_KEY = '@sequence.transportSession';\nclass BaseWalletTransport {\n  // appOrigin identifies the dapp's origin which opened the app. A transport\n  // will auto-detect and set this value if it can. This is determined\n  // as the parent app/window which opened the wallet.\n  constructor(walletRequestHandler) {\n    var _this = this;\n\n    this.walletRequestHandler = void 0;\n    this._sessionId = void 0;\n    this._registered = void 0;\n    this._init = void 0;\n    this._initNonce = void 0;\n    this._initCallback = void 0;\n    this.appOrigin = void 0;\n\n    this.sendAsync = async function (request, callback, chainId) {\n      throw new Error('abstract method');\n    };\n\n    this.handleMessage = async function (message) {\n      const request = message; // ensure initial handshake is complete before accepting\n      // other kinds of messages.\n\n      if (_this._init !== InitState.OK) {\n        if (request.type === EventType.INIT) {\n          if (_this.isValidInitAck(message)) {\n            // successful init\n            if (_this._initCallback) _this._initCallback();\n          } else {\n            // failed init\n            if (_this._initCallback) _this._initCallback('invalid init');\n            return;\n          }\n        }\n\n        return;\n      } // ensure signer is ready to handle requests\n      // if (this.walletRequestHandler.getSigner() === undefined) {\n      //   await this.walletRequestHandler.signerReady()\n      // }\n      // handle request\n\n\n      switch (request.type) {\n        case EventType.OPEN:\n          {\n            if (_this._init !== InitState.OK) return;\n            const session = {\n              sessionId: request.data.sessionId,\n              intent: request.data.intent,\n              networkId: request.data.networkId\n            };\n            await _this.open(session);\n            return;\n          }\n\n        case EventType.CLOSE:\n          {\n            if (_this._init !== InitState.OK) return; // noop. just here to capture the message so event emitters may be notified\n\n            return;\n          }\n\n        case EventType.MESSAGE:\n          {\n            const response = await _this.walletRequestHandler.sendMessageRequest(request);\n\n            _this.sendMessage(response);\n\n            if (response.data.error) ;\n\n            return;\n          }\n\n        default:\n          {\n            logger.error(`unexpected payload type ${request.type}`);\n          }\n      }\n    };\n\n    this.sendMessageRequest = async function (message) {\n      return _this.walletRequestHandler.sendMessageRequest(message);\n    };\n\n    this.open = async function ({\n      sessionId,\n      intent,\n      networkId\n    }) {\n      if (sessionId) {\n        _this._sessionId = sanitizeNumberString(sessionId); // persist transport session in localstorage for restoring after redirect/reload\n\n        _this.saveTransportSession({\n          sessionId,\n          intent,\n          networkId\n        });\n      }\n\n      _this.walletRequestHandler.setOpenIntent(intent); // init handshake for certain transports, before we can open the communication.\n      //\n      // for example, with the window-transport, we have to exchange messages to determine the\n      // origin host of the dapp.\n\n\n      await _this.init(); // Prepare connect options from intent\n\n      if (intent && intent.type === 'connect' && intent.options) {\n        const connectOptions = intent.options;\n        const authorizeOptions = connectOptions; // overlapping types\n        // Sanity/integrity check the intent payload, and set authorization origin\n        // if its been determined as part of the init handshake from earlier.\n\n        if (_this.appOrigin && authorizeOptions != null && authorizeOptions.origin) {\n          if (!isBrowserExtension()) {\n            if (authorizeOptions.origin !== _this.appOrigin) {\n              throw new Error('origin is invalid');\n            }\n          }\n        } else if (!_this.appOrigin && authorizeOptions != null && authorizeOptions.origin) {\n          // ie. when we can't determine the origin in our transport, but dapp provides it to us.\n          // we just sanitize the origin host.\n          connectOptions.origin = sanitizeHost(authorizeOptions.origin);\n        } else if (_this.appOrigin) {\n          // ie. when we auto-determine the origin such as in window-transport\n          connectOptions.origin = _this.appOrigin;\n        }\n\n        if (connectOptions.app) {\n          connectOptions.app = sanitizeAlphanumeric(connectOptions.app);\n        } // Set connect options on the walletRequestHandler as our primary\n        // wallet controller\n\n\n        _this.walletRequestHandler.setConnectOptions(connectOptions);\n\n        if (connectOptions.networkId) {\n          networkId = connectOptions.networkId;\n        }\n      } else {\n        _this.walletRequestHandler.setConnectOptions(undefined);\n      } // ensure signer is ready\n\n\n      await _this.walletRequestHandler.getSigner(); // Notify open and proceed to prompt for connection if intended\n\n      if (!(await _this.walletRequestHandler.isSignedIn())) {\n        // open wallet without a specific connected chainId, as the user is not signed in\n        _this.notifyOpen({\n          sessionId: _this._sessionId\n        });\n\n        return true;\n      } else {\n        // Set default network, in case of error chainId will be undefined or 0\n        let chainId = undefined;\n\n        try {\n          if (networkId) {\n            chainId = await _this.walletRequestHandler.setDefaultNetwork(networkId, false);\n          } else {\n            chainId = await _this.walletRequestHandler.getChainId();\n          }\n        } catch (err) {\n          console.error(err);\n        } // Failed to set default network on open -- quit + close\n\n\n        if (!chainId || chainId <= 0) {\n          _this.notifyOpen({\n            sessionId: _this._sessionId,\n            error: `failed to open wallet on network ${networkId}`\n          });\n\n          return false;\n        } // prompt user with a connect request. the options will be used as previously set above.\n        // upon success, the walletRequestHandler will notify the dapp with the ConnectDetails.\n        // upon cancellation by user, the walletRequestHandler will throw an error\n\n\n        if (intent && intent.type === 'connect') {\n          // notify wallet is opened, without session details\n          _this.notifyOpen({\n            sessionId: _this._sessionId\n          });\n\n          try {\n            const connectDetails = await _this.walletRequestHandler.promptConnect(intent.options);\n\n            if (connectDetails.connected) {\n              _this.walletRequestHandler.notifyConnect(connectDetails);\n            }\n          } catch (err) {\n            logger.warn('promptConnect not connected:', err);\n          } finally {\n            // auto-close by default, unless intent is to keep open\n            if (!intent.options || intent.options.keepWalletOpened !== true) {\n              _this.notifyClose();\n            }\n          }\n        } else {\n          // user is already connected, notify session details.\n          // TODO: in future, keep list if 'connected' dapps / sessions in the session\n          // controller, and only sync with allowed apps\n          _this.notifyOpen({\n            sessionId: _this._sessionId,\n            chainId: `${chainId}`,\n            session: await _this.walletRequestHandler.walletSession()\n          });\n        }\n      }\n\n      return true;\n    };\n\n    this.saveTransportSession = session => {\n      LocalStorage.getInstance().setItem(TRANSPORT_SESSION_LS_KEY, JSON.stringify(session));\n    };\n\n    this.getCachedTransportSession = async function () {\n      const session = await LocalStorage.getInstance().getItem(TRANSPORT_SESSION_LS_KEY);\n\n      try {\n        return session ? JSON.parse(session) : null;\n      } catch (err) {\n        console.error(`unable to parse transport session: ${session}`);\n        return null;\n      }\n    };\n\n    this.walletRequestHandler = walletRequestHandler;\n    this._init = InitState.NIL;\n    this.walletRequestHandler.on('connect', connectDetails => {\n      if (!this.registered) return; // means user has logged in and wallet is connected to the app\n\n      this.notifyConnect(connectDetails);\n    });\n    this.walletRequestHandler.on('disconnect', error => {\n      if (!this.registered) return; // means user has logged out the app / disconnected wallet from the app\n\n      this.notifyDisconnect(error);\n    });\n    this.walletRequestHandler.on('accountsChanged', (accounts, origin) => {\n      if (!this.registered) return;\n      this.notifyAccountsChanged(accounts, origin);\n    });\n    this.walletRequestHandler.on('networks', networks => {\n      if (!this.registered) return;\n      this.notifyNetworks(networks);\n\n      if (!networks || networks.length === 0) {\n        this.notifyChainChanged('0x0');\n      } else {\n        this.notifyChainChanged(ethers.utils.hexlify(networks.find(network => network.isDefaultChain).chainId));\n      }\n    });\n    this.walletRequestHandler.on('walletContext', walletContext => {\n      if (!this.registered || !walletContext) return;\n      this.notifyWalletContext(walletContext);\n    });\n    this.walletRequestHandler.on('close', error => {\n      if (!this.registered) return;\n      this.notifyClose(error);\n    });\n  }\n\n  get registered() {\n    return this._registered;\n  }\n\n  register() {\n    throw new Error('abstract method');\n  }\n\n  unregister() {\n    throw new Error('abstract method');\n  }\n\n  sendMessage(message) {\n    throw new Error('abstract method');\n  }\n\n  notifyOpen(openInfo) {\n    const {\n      chainId,\n      sessionId,\n      session,\n      error\n    } = openInfo;\n    this.sendMessage({\n      idx: -1,\n      type: EventType.OPEN,\n      data: {\n        chainId,\n        sessionId,\n        session,\n        error\n      }\n    });\n  }\n\n  notifyClose(error) {\n    this.sendMessage({\n      idx: -1,\n      type: EventType.CLOSE,\n      data: error ? {\n        error\n      } : null\n    });\n  }\n\n  notifyConnect(connectDetails) {\n    this.sendMessage({\n      idx: -1,\n      type: EventType.CONNECT,\n      data: connectDetails\n    });\n  }\n\n  notifyDisconnect(error) {\n    this.sendMessage({\n      idx: -1,\n      type: EventType.DISCONNECT,\n      data: error ? {\n        error\n      } : null\n    });\n  }\n\n  notifyAccountsChanged(accounts, origin) {\n    this.sendMessage({\n      idx: -1,\n      type: EventType.ACCOUNTS_CHANGED,\n      data: accounts,\n      origin: origin\n    });\n  }\n\n  notifyChainChanged(chainIdHex) {\n    this.sendMessage({\n      idx: -1,\n      type: EventType.CHAIN_CHANGED,\n      data: chainIdHex\n    });\n  }\n\n  notifyNetworks(networks) {\n    this.sendMessage({\n      idx: -1,\n      type: EventType.NETWORKS,\n      data: networks\n    });\n  }\n\n  notifyWalletContext(walletContext) {\n    this.sendMessage({\n      idx: -1,\n      type: EventType.WALLET_CONTEXT,\n      data: walletContext\n    });\n  }\n\n  isValidInitAck(message) {\n    if (this._init === InitState.OK) {\n      // we're already in init state, we shouldn't handle this message\n      logger.warn(\"isValidInitAck, already in init'd state, so inquiry is invalid.\");\n      return false;\n    }\n\n    if (message.type !== EventType.INIT) {\n      logger.warn('isValidInitAck, invalid message type, expecting init');\n      return false;\n    }\n\n    const {\n      sessionId,\n      nonce\n    } = message.data;\n\n    if (!sessionId || sessionId.length === 0 || !nonce || nonce.length === 0) {\n      logger.error('invalid init ack');\n      return false;\n    }\n\n    if (sessionId !== this._sessionId || nonce !== this._initNonce) {\n      logger.error('invalid init ack match');\n      return false;\n    } // all checks pass, its true\n\n\n    return true;\n  }\n\n  init() {\n    return new Promise((resolve, reject) => {\n      // avoid re-init`ing, or if there is a transport which doesn't require\n      // it, then it may set this._init to OK in its constructor.\n      if (this._init === InitState.OK) {\n        resolve();\n        return;\n      }\n\n      if (this._init !== InitState.NIL || this._initCallback) {\n        reject('transport init is in progress');\n        return;\n      } // start init timeout, if we don't receive confirmation\n      // from provider within this amount of time, then we timeout\n\n\n      const initTimeout = setTimeout(() => {\n        logger.warn('transport init timed out');\n\n        if (this._initCallback) {\n          this._initCallback('transport init timed out');\n        }\n      }, PROVIDER_OPEN_TIMEOUT / 2); // setup callback as we receive the init message async in the handleMessage function\n\n      this._initCallback = error => {\n        this._initCallback = undefined; // reset\n\n        clearTimeout(initTimeout);\n\n        if (error) {\n          reject(error);\n        } else {\n          this._init = InitState.OK;\n          resolve();\n        }\n      }; // send init request with random nonce to the provider, where we expect\n      // for the provider to echo it back to us as complete handshake\n\n\n      this._initNonce = `${performance.now()}`;\n      this.sendMessage({\n        idx: -1,\n        type: EventType.INIT,\n        data: {\n          nonce: this._initNonce\n        }\n      });\n      this._init = InitState.SENT_NONCE; // NOTE: the promise will resolve in the _initCallback method\n      // which will be called from either handleMessage or the initTimeout\n    });\n  }\n\n}\n\nclass ProxyMessageChannel {\n  constructor() {\n    this.app = void 0;\n    this.wallet = void 0;\n    const port1 = new ProxyMessageChannelPort();\n    const port2 = new ProxyMessageChannelPort();\n    port1.conn = port2;\n    port2.conn = port1;\n    this.app = port1;\n    this.wallet = port2;\n  }\n\n}\nclass ProxyMessageChannelPort {\n  constructor() {\n    this.conn = void 0;\n    this.events = new EventEmitter2();\n\n    this.handleMessage = message => {\n      throw new Error('ProxyMessageChannelPort is not registered');\n    };\n\n    this.sendMessage = message => {\n      this.conn.handleMessage(message); // trigger events\n\n      if (message.type === 'open') {\n        this.events.emit('open', message);\n      }\n\n      if (message.type === 'close') {\n        this.events.emit('close', message);\n      }\n\n      if (message.type === 'connect') {\n        this.events.emit('connect', message);\n      }\n\n      if (message.type === 'disconnect') {\n        this.events.emit('disconnect', message);\n      }\n    };\n  }\n\n  on(event, fn) {\n    this.events.on(event, fn);\n  }\n\n  once(event, fn) {\n    this.events.once(event, fn);\n  }\n\n}\n\nclass ProxyMessageProvider extends BaseProviderTransport {\n  constructor(port) {\n    super();\n    this.port = void 0;\n\n    this.register = () => {\n      this.port.handleMessage = message => {\n        this.handleMessage(message);\n      };\n\n      this.on('open', (...args) => {\n        this.port.events.emit('open', ...args);\n      });\n      this.on('close', (...args) => {\n        this.port.events.emit('close', ...args);\n      });\n      this.on('connect', (...args) => {\n        this.port.events.emit('connect', ...args);\n      });\n      this.on('disconnect', (...args) => {\n        this.port.events.emit('disconnect', ...args);\n      });\n      this._registered = true;\n    };\n\n    this.unregister = () => {\n      this._registered = false;\n      this.closeWallet();\n      this.events.removeAllListeners(); // @ts-ignore\n\n      this.port.handleMessage = undefined;\n    };\n\n    this.openWallet = (path, intent, networkId) => {\n      if (this.state === OpenState.CLOSED) {\n        this.state = OpenState.OPENING;\n        const sessionId = `${performance.now()}`;\n        this._sessionId = sessionId;\n        this.sendMessage({\n          idx: -1,\n          type: EventType.OPEN,\n          data: {\n            path,\n            intent,\n            networkId,\n            sessionId\n          }\n        });\n      }\n    };\n\n    this.state = OpenState.CLOSED;\n    this.port = port;\n\n    if (!port) {\n      throw new Error('port argument cannot be empty');\n    } // disable init handshake for proxy-transport, we set it to OK, to\n    // consider it in completed state.\n\n\n    this._init = InitState.OK;\n  }\n\n  closeWallet() {\n    this.sendMessage({\n      idx: -1,\n      type: EventType.CLOSE,\n      data: null\n    });\n    this.close();\n  }\n\n  sendMessage(message) {\n    if (!message.idx) {\n      throw new Error('message idx is empty');\n    }\n\n    this.port.sendMessage(message);\n  }\n\n}\n\nclass ProxyMessageHandler extends BaseWalletTransport {\n  constructor(walletRequestHandler, port) {\n    super(walletRequestHandler);\n    this.port = void 0;\n    this.port = port;\n    this._init = InitState.OK;\n  }\n\n  register() {\n    this.port.handleMessage = message => {\n      this.handleMessage(message);\n    };\n\n    this._registered = true;\n  } // note: we can't decide whether to restore the session within register(), because session info is\n  // received asyncronously via EventType.OPEN after register() is executed.\n  // And in the case of a redirect/reload, EventType.OPEN is not sent at all,\n  // because the wallet is already open.\n  //\n  // call this method from wallet redirect hander when a session restore is needed\n\n\n  async restoreSession() {\n    const cachedSession = await this.getCachedTransportSession();\n\n    if (cachedSession) {\n      this.open(cachedSession);\n    }\n  }\n\n  unregister() {\n    // @ts-ignore\n    this.port.handleMessage = undefined;\n    this._registered = false;\n  }\n\n  sendMessage(message) {\n    this.port.sendMessage(message);\n  }\n\n}\n\nclass MuxMessageProvider {\n  constructor(...messageProviders) {\n    var _this = this;\n\n    this.messageProviders = void 0;\n    this.provider = void 0;\n\n    this.register = () => {\n      if (this.messageProviders.length === 1) {\n        this.provider = this.messageProviders[0];\n        this.provider.register();\n        return;\n      } // REVIEW/NOTE: ........ this method does not work for the chrome-extension. The issue becomes\n      // when the browser quits or restarts, the \"open\" event is never triggered. Perhaps the code here is fine,\n      // or maybe its not. What should happen is when a dapp makes a request, it will call openWallet\n      // below, in which case one of the events will register. So perhaps this is fine.\n\n\n      this.messageProviders.forEach(m => {\n        m.register();\n        m.once('open', () => {\n          // the first one to open is the winner, and others will be unregistered\n          if (!this.provider) {\n            this.provider = m; // unregister other providers\n\n            this.messageProviders.forEach(m => {\n              if (this.provider !== m) {\n                m.unregister();\n              }\n            });\n          }\n        });\n      });\n    };\n\n    this.unregister = () => {\n      this.messageProviders.forEach(m => m.unregister());\n      this.provider = undefined;\n    };\n\n    this.openWallet = (path, intent, networkId) => {\n      if (this.provider) {\n        this.provider.openWallet(path, intent, networkId);\n        return;\n      }\n\n      this.messageProviders.forEach(m => m.openWallet(path, intent, networkId));\n    };\n\n    this.sendAsync = async function (request, callback, chainId) {\n      if (_this.provider) {\n        _this.provider.sendAsync(request, callback, chainId);\n\n        return;\n      }\n\n      throw new Error('impossible state, wallet must be opened first');\n    };\n\n    this.sendMessageRequest = async function (message) {\n      if (_this.provider) {\n        return _this.provider.sendMessageRequest(message);\n      }\n\n      throw new Error('impossible state, wallet must be opened first');\n    };\n\n    this.waitUntilOpened = async function () {\n      if (_this.provider) {\n        return _this.provider.waitUntilOpened();\n      }\n\n      return Promise.race(_this.messageProviders.map(p => p.waitUntilOpened()));\n    };\n\n    this.waitUntilConnected = async function () {\n      if (_this.provider) {\n        return _this.provider.waitUntilConnected();\n      }\n\n      throw new Error('impossible state, wallet must be opened first');\n    };\n\n    this.messageProviders = messageProviders;\n    this.provider = undefined;\n  }\n\n  add(...messageProviders) {\n    this.messageProviders.push(...messageProviders);\n  }\n\n  closeWallet() {\n    if (this.provider) {\n      this.provider.closeWallet();\n    }\n  }\n\n  isOpened() {\n    if (this.provider) {\n      return this.provider.isOpened();\n    }\n\n    return false;\n  }\n\n  isConnected() {\n    if (this.provider) {\n      return this.provider.isConnected();\n    }\n\n    return false;\n  }\n\n  on(event, fn) {\n    if (this.provider) {\n      this.provider.on(event, fn);\n      return;\n    }\n\n    this.messageProviders.forEach(m => {\n      m.on(event, fn);\n    });\n  }\n\n  once(event, fn) {\n    if (this.provider) {\n      this.provider.once(event, fn);\n      return;\n    }\n\n    this.messageProviders.forEach(m => {\n      m.once(event, fn);\n    });\n  }\n\n  emit(event, ...args) {\n    if (this.provider) {\n      return this.provider.emit(event, ...args);\n    }\n\n    for (let i = 0; i < this.messageProviders.length; i++) {\n      this.messageProviders[i].emit(event, ...args);\n    }\n\n    return true;\n  }\n\n  sendMessage(message) {\n    if (!message.idx || message.idx <= 0) {\n      throw new Error('message idx is empty');\n    }\n\n    if (this.provider) {\n      this.provider.sendMessage(message);\n    } else {\n      throw new Error('impossible state, wallet must be opened first');\n    }\n  }\n\n  handleMessage(message) {\n    if (this.provider) {\n      this.provider.handleMessage(message);\n      return;\n    }\n\n    throw new Error('impossible state, wallet must be opened first');\n  }\n\n}\n\nlet registeredWindowMessageProvider;\nclass WindowMessageProvider extends BaseProviderTransport {\n  constructor(walletAppURL) {\n    super();\n    this.walletURL = void 0;\n    this.walletWindow = void 0;\n\n    this.register = () => {\n      if (registeredWindowMessageProvider) {\n        // overriding the registered message provider\n        registeredWindowMessageProvider.unregister();\n        registeredWindowMessageProvider = this;\n      } // listen for incoming messages from wallet\n\n\n      window.addEventListener('message', this.onWindowEvent);\n      registeredWindowMessageProvider = this; // open heartbeat\n\n      this.on('open', () => {\n        // Heartbeat to track if window closed\n        const popup = this.walletWindow;\n        const interval = setInterval(() => {\n          if (popup && popup.closed) {\n            clearInterval(interval);\n            this.close();\n          }\n        }, 500);\n      }); // close clean up\n\n      this.on('close', () => {\n        if (this.walletWindow) {\n          this.walletWindow.close();\n          this.walletWindow = null;\n        }\n      });\n      this._registered = true;\n    };\n\n    this.unregister = () => {\n      this._registered = false;\n      this.closeWallet(); // disable message listener\n\n      if (registeredWindowMessageProvider === this) {\n        registeredWindowMessageProvider = undefined;\n      }\n\n      window.removeEventListener('message', this.onWindowEvent); // clear event listeners\n\n      this.events.removeAllListeners();\n    };\n\n    this.openWallet = (path, intent, networkId) => {\n      if (this.walletWindow && this.isOpened()) {\n        // TODO: update the location of window to path\n        this.walletWindow.focus();\n        return;\n      } // Instantiate new walletURL for this call\n\n\n      const walletURL = new URL(this.walletURL.href);\n      const windowSessionParams = new WindowSessionParams();\n\n      if (path && path !== '') {\n        walletURL.pathname = path.toLowerCase();\n      } // Set session, intent and network id on walletURL\n\n\n      this._init = InitState.NIL;\n      this._sessionId = `${performance.now()}`;\n      windowSessionParams.set('sid', this._sessionId);\n\n      if (intent) {\n        // for the window-transport, we eagerly/optimistically set the origin host\n        // when connecting to the wallet, however, this will be verified and enforced\n        // on the wallet-side, so if a dapp provides the wrong origin, it will be dropped.\n        if (intent.type === 'connect') {\n          if (!intent.options) intent.options = {}; // skip setting origin host if we're in an browser extension execution context\n          // allow origin that is passed in\n\n          if (!isBrowserExtension()) {\n            intent.options.origin = window.location.origin;\n          }\n        } // encode intent as base64 url-encoded param\n\n\n        windowSessionParams.set('intent', base64EncodeObject(intent));\n      }\n\n      if (networkId) {\n        windowSessionParams.set('net', `${networkId}`);\n      } // Open popup window on center of the app window\n\n\n      let windowSize;\n      let windowPos;\n\n      if (isBrowserExtension()) {\n        windowSize = [450, 750];\n        windowPos = [Math.abs(window.screen.width / 2 - windowSize[0] / 2), Math.abs(window.screen.height / 2 - windowSize[1] / 2)];\n      } else {\n        windowSize = [450, 750];\n        windowPos = [Math.abs(window.screenX + window.innerWidth / 2 - windowSize[0] / 2), Math.abs(window.screenY + window.innerHeight / 2 - windowSize[1] / 2)];\n      }\n\n      const windowFeatures = `toolbar=0,location=0,menubar=0,scrollbars=yes,status=yes` + `,width=${windowSize[0]},height=${windowSize[1]}` + `,left=${windowPos[0]},top=${windowPos[1]}`; // serialize params\n\n      walletURL.search = windowSessionParams.toString();\n      this.walletWindow = window.open(walletURL.href, 'sequence.app', windowFeatures); // TODO: move this somewhere else\n      // TODO: perhaps we trigger a .on('openTimeout') event..? maybe.. could help.\n      // Popup blocking detection and notice\n      // let warned = false\n      // const warnPopupBlocked = () => {\n      //   if (warned) return\n      //   warned = true\n      //   // alert('popup is blocked! hey yo') // NOTE: for debug purposes only\n      //   throw new Error('popup is blocked')\n      // }\n      // const popupCheck = setTimeout(() => {\n      //   if (!popup || popup.closed || typeof popup.closed === 'undefined') {\n      //     // popup is definitely blocked if we reach here.\n      //     warnPopupBlocked()\n      //   }\n      // }, 1000)\n      // const popupBlocked = popup === null || popup === undefined\n      // if (popupBlocked) {\n      //   warnPopupBlocked()\n      //   return\n      // }\n    };\n\n    this.onWindowEvent = event => {\n      // Security check, ensure message is coming from wallet origin url\n      if (event.origin !== this.walletURL.origin) {\n        // Safetly can skip events not from the wallet\n        return;\n      }\n\n      let message;\n\n      try {\n        message = JSON.parse(event.data);\n      } catch (err) {\n        // event is not a ProviderMessage JSON object, skip\n        return;\n      }\n\n      if (!message) {\n        throw new Error('ProviderMessage object is empty');\n      } // handle message with base message provider\n\n\n      this.handleMessage(message);\n    };\n\n    this.walletURL = new URL(walletAppURL);\n  }\n\n  closeWallet() {\n    var _this$walletWindow;\n\n    this.close();\n    (_this$walletWindow = this.walletWindow) == null ? void 0 : _this$walletWindow.close();\n  } // onmessage, receives ProviderMessageResponse from the wallet post-message transport\n\n\n  sendMessage(message) {\n    if (!this.walletWindow) {\n      logger.warn('WindowMessageProvider: sendMessage failed as walletWindow is unavailable');\n      return;\n    }\n\n    const postedMessage = typeof message !== 'string' ? JSON.stringify(message) : message;\n    this.walletWindow.postMessage(postedMessage, this.walletURL.origin);\n  }\n\n}\n\nclass WindowMessageHandler extends BaseWalletTransport {\n  constructor(walletRequestHandler) {\n    var _this;\n\n    super(walletRequestHandler);\n    _this = this;\n    this.parentWindow = void 0;\n    this._isPopup = false;\n\n    this.onWindowEvent = async function (event) {\n      if (!event.origin || event.origin === '') {\n        // skip same-origin or when event.origin is empty/undefined\n        return;\n      }\n\n      if (_this.appOrigin && event.origin !== _this.appOrigin) {\n        // skip message as not from expected app origin\n        return;\n      } // Wallet always expects json-rpc request messages from a dapp\n\n\n      let request;\n\n      try {\n        request = JSON.parse(event.data);\n      } catch (err) {\n        // event is not a ProviderMessage JSON object, skip\n        return;\n      }\n\n      logger.debug('RECEIVED MESSAGE', request); // Record event origin for valid init ack\n\n      if (_this._init !== InitState.OK && _this.isValidInitAck(request)) {\n        _this.appOrigin = event.origin;\n      }\n\n      if (_this._init === InitState.OK && (!_this.appOrigin || _this.appOrigin.length < 8)) {\n        // impossible state\n        logger.error('impossible state, init.OK and appOrigin required');\n        return;\n      } // Handle message via the base transport\n\n\n      _this.handleMessage(request);\n    };\n\n    this.getWindowTransportSession = windowParams => {\n      const params = new WindowSessionParams(windowParams);\n      return {\n        sessionId: params.get('sid'),\n        networkId: params.get('net'),\n        intent: base64DecodeObject(params.get('intent'))\n      };\n    };\n\n    this._init = InitState.NIL;\n  }\n\n  async register(windowHref) {\n    const isPopup = parent.window.opener !== null;\n    this._isPopup = isPopup;\n\n    if (isPopup !== true) {\n      return;\n    } // record open details (sessionId + default network) from the window url\n\n\n    const {\n      pathname,\n      search: rawParams\n    } = new URL(windowHref || window.location.href);\n    let session = this.getWindowTransportSession(rawParams); // provider should always include sid when opening a new window\n\n    const isNewWindowSession = !!session.sessionId; // attempt to restore previous session in the case of a redirect or window reload\n\n    if (!isNewWindowSession) {\n      session = await this.getCachedTransportSession();\n    }\n\n    if (!session) {\n      logger.error('window session is undefined');\n      return;\n    } // record parent window instance for communication\n\n\n    this.parentWindow = parent.window.opener; // listen for window-transport requests\n\n    window.addEventListener('message', this.onWindowEvent, false);\n    this._registered = true; // send open event to the app which opened us\n\n    this.open(session).then(opened => {\n      if (!opened) {\n        var _session;\n\n        const err = `failed to open to network ${(_session = session) == null ? void 0 : _session.networkId}`;\n        logger.error(err);\n        this.notifyClose({\n          message: err\n        });\n        window.close();\n      }\n    }).catch(e => {\n      var _session2;\n\n      const err = `failed to open to network ${(_session2 = session) == null ? void 0 : _session2.networkId}, due to: ${e}`;\n      logger.error(err);\n      this.notifyClose({\n        message: err\n      });\n      window.close();\n    });\n  }\n\n  unregister() {\n    window.removeEventListener('message', this.onWindowEvent);\n    this._registered = false;\n  } // onmessage is called when (the wallet) receives request messages from the dapp\n  // over the window post-messaging transport\n\n\n  // postMessage sends message to the dapp window\n  sendMessage(message) {\n    // prepare payload\n    const payload = JSON.stringify(message); // post-message to app.\n    // only for init requests, we send to '*' origin\n\n    if (message.type === EventType.INIT) {\n      this.postMessage(payload, true);\n    } else {\n      this.postMessage(payload);\n    }\n  }\n\n  get isPopup() {\n    return this._isPopup;\n  }\n\n  postMessage(message, init = false) {\n    if (init !== true && this._init !== InitState.OK) {\n      logger.error('impossible state, should not be calling postMessage until inited');\n      return;\n    }\n\n    if (init) {\n      // init message transmission to global target -- for 'init' payloads only\n      this.parentWindow.postMessage(message, '*');\n    } else {\n      // open message transmission\n      if (this.appOrigin && this.appOrigin.length > 4) {\n        // just above '.com'\n        this.parentWindow.postMessage(message, this.appOrigin);\n      } else {\n        logger.error('unable to postMessage as parentOrigin is invalid');\n      }\n    }\n  }\n\n}\n\nconst CHANNEL_ID = 'sequence-extension-message-handler';\nclass ExtensionMessageHandler extends BaseWalletTransport {\n  constructor(walletRequestHandler, runtime) {\n    super(walletRequestHandler);\n    this.runtime = runtime;\n    this.port = void 0;\n    this._init = InitState.OK;\n  }\n\n  register() {\n    this._registered = true;\n    this.port = this.runtime.connect({\n      name: CHANNEL_ID\n    });\n  }\n\n  sendMessage(message) {\n    logger.info('[ExtensionMessageHandler send]', message);\n    this.port.postMessage(message);\n  }\n\n}\n\nclass ExtensionMessageProvider extends BaseProviderTransport {\n  constructor(runtime) {\n    super();\n\n    this.register = () => {\n      this._registered = true;\n    };\n\n    runtime.onConnect.addListener(port => {\n      if (port.name === CHANNEL_ID) {\n        this._init = InitState.OK;\n        port.onMessage.addListener(message => {\n          this.handleMessage(message);\n        });\n      }\n    });\n  }\n\n  sendMessage(message) {//noop\n  }\n\n  unregister() {//noop\n  }\n\n  openWallet(path, intent, networkId) {//noop\n  }\n\n  closeWallet() {//noop\n  }\n\n}\n\n// to be used on injected window.ethereum EIP1193 proxy\nclass BaseInjectedTransport extends EventEmitter2 {\n  constructor(stream) {\n    var _this;\n\n    super();\n    _this = this;\n    this.stream = stream;\n    this.responseCallbacks = new Map();\n    this._messageIdx = 0;\n\n    this.nextMessageIdx = () => ++this._messageIdx;\n\n    this.handleMessage = message => {\n      if (!message.type || !message.data) {\n        return;\n      }\n\n      logger.info('[received message]', message);\n      const requestIdx = message.idx;\n      const responseCallback = this.responseCallbacks.get(requestIdx);\n\n      if (requestIdx) {\n        this.responseCallbacks.delete(requestIdx);\n      }\n\n      switch (message.type) {\n        case EventType.MESSAGE:\n          if (responseCallback) {\n            this.emit(EventType.MESSAGE, message);\n            responseCallback(message.data.error, message);\n          } else {\n            // NOTE: this would occur if 'idx' isn't set, which should never happen\n            // or when we register two handler, or duplicate messages with the same idx are sent,\n            // all of which should be prevented prior to getting to this point\n            throw new Error('impossible state');\n          }\n\n          break;\n\n        case EventType.DISCONNECT:\n        case EventType.ACCOUNTS_CHANGED:\n        case EventType.CHAIN_CHANGED:\n          this.emit(message.type, message.data);\n          break;\n\n        default:\n          console.error('unknown message type', message);\n          break;\n      }\n    };\n\n    this.sendMessageRequest = async function (message) {\n      return new Promise((resolve, reject) => {\n        if (!message.idx || message.idx <= 0) {\n          reject(new Error('message idx not set'));\n        }\n\n        const responseCallback = (error, response) => {\n          if (error) {\n            reject(error);\n          } else if (response) {\n            resolve(response);\n          } else {\n            throw new Error('no valid response to return');\n          }\n        };\n\n        const {\n          idx\n        } = message;\n\n        if (!_this.responseCallbacks.get(idx)) {\n          _this.responseCallbacks.set(idx, responseCallback);\n        } else {\n          reject(new Error('duplicate message idx, should never happen'));\n        }\n\n        _this.sendMessage(message);\n      });\n    };\n\n    this.stream.on('data', this.handleMessage);\n  }\n\n  sendMessage(message) {\n    if (!this.stream.writable) {\n      console.error('window post message stream is not writable');\n    }\n\n    this.stream.write(message);\n  }\n\n}\n\n/**\n * This will redirect console logs from Sequence.js & the wallet to the Unreal console, for debugging purposes.\n */\nfunction overrideLogs(side) {\n  var _window$ue;\n\n  if ((_window$ue = window.ue) != null && _window$ue.sequencewallettransport && !window.logsOverriddenForUnreal) {\n    var _window$ue2;\n\n    const t = (_window$ue2 = window.ue) == null ? void 0 : _window$ue2.sequencewallettransport;\n\n    console.log = (...args) => {\n      t.logfromjs(`${side}: ${stringify(args)}`);\n    };\n\n    console.warn = (...args) => {\n      t.warnfromjs(`${side}: ${stringify(args)}`);\n    };\n\n    console.error = (...args) => {\n      t.errorfromjs(`${side}: ${stringify(args)}`);\n    };\n\n    window.logsOverriddenForUnreal = true;\n  }\n}\n\nfunction stringify(things) {\n  return things.map(a => typeof a === 'object' ? a instanceof Error ? a.message : JSON.stringify(a) : String(a)).join(' ');\n}\n\nlet registeredUnrealMessageProvider; // all lowercase is an annoying limitation of Unreal CEF BindUObject\n\n/**\n * Initialized on dApp side\n */\nclass UnrealMessageProvider extends BaseProviderTransport {\n  constructor(walletAppURL) {\n    super();\n    this.walletURL = void 0;\n\n    this.register = () => {\n      var _window$ue;\n\n      overrideLogs('dapp');\n\n      if (registeredUnrealMessageProvider) {\n        // overriding the registered message provider\n        registeredUnrealMessageProvider.unregister();\n        registeredUnrealMessageProvider = this;\n      } // listen for incoming messages from wallet\n\n\n      if ((_window$ue = window.ue) != null && _window$ue.sequencewallettransport) {\n        window.ue.sequencewallettransport.onmessagefromwallet = this.onUnrealCallback;\n      }\n\n      registeredUnrealMessageProvider = this;\n      this._registered = true;\n      console.log('registering transport!');\n    };\n\n    this.unregister = () => {\n      var _window$ue2, _window$ue2$sequencew;\n\n      this._registered = false;\n      this.closeWallet(); // disable message listener\n\n      if (registeredUnrealMessageProvider === this) {\n        registeredUnrealMessageProvider = undefined;\n      }\n\n      if (((_window$ue2 = window.ue) == null ? void 0 : (_window$ue2$sequencew = _window$ue2.sequencewallettransport) == null ? void 0 : _window$ue2$sequencew.onmessagefromwallet) === this.onUnrealCallback) {\n        delete window.ue.sequencewallettransport.onmessagefromwallet;\n      } // clear event listeners\n\n\n      this.events.removeAllListeners();\n    };\n\n    this.openWallet = (path, intent, networkId) => {\n      if (this.isOpened()) {\n        // TODO focus wallet\n        console.log('wallet already open!');\n        return;\n      }\n\n      console.log('opening wallet!'); // Instantiate new walletURL for this call\n\n      const walletURL = new URL(this.walletURL.href);\n      const windowSessionParams = new WindowSessionParams();\n\n      if (path) {\n        walletURL.pathname = path.toLowerCase();\n      } // Set session, intent and network id on walletURL\n\n\n      this._init = InitState.NIL;\n      this._sessionId = `${performance.now()}`;\n      windowSessionParams.set('sid', this._sessionId);\n\n      if (intent) {\n        // encode intent as base64 url-encoded param\n        windowSessionParams.set('intent', base64EncodeObject(intent));\n      }\n\n      if (networkId) {\n        windowSessionParams.set('net', `${networkId}`);\n      } // serialize params\n\n\n      walletURL.search = windowSessionParams.toString();\n      console.log('opening wallet to', walletURL.href);\n      window.open(walletURL.href);\n    };\n\n    this.onUnrealCallback = message => {\n      if (!message) {\n        throw new Error('ProviderMessage object is empty');\n      } // handle message with base message provider\n\n\n      this.handleMessage(message);\n    };\n\n    this.walletURL = new URL(walletAppURL);\n  }\n\n  closeWallet() {\n    this.close();\n  } // onmessage, receives ProviderMessageResponse from the wallet unreal transport\n\n\n  // all lowercase is an annoying limitation of Unreal CEF BindUObject\n  sendMessage(message) {\n    var _window$ue3, _window$ue3$sequencew;\n\n    const postedMessage = typeof message !== 'string' ? JSON.stringify(message) : message;\n    console.log('Sending message to wallet:', postedMessage);\n    (_window$ue3 = window.ue) == null ? void 0 : (_window$ue3$sequencew = _window$ue3.sequencewallettransport) == null ? void 0 : _window$ue3$sequencew.sendmessagetowallet(postedMessage);\n  }\n\n}\n\n/**\n * Initialized on Wallet side\n */\nclass UnrealMessageHandler extends BaseWalletTransport {\n  constructor(walletRequestHandler) {\n    super(walletRequestHandler);\n\n    this.onMessageFromUnreal = request => {\n      // Wallet always expects json-rpc request messages from a dapp\n      logger.debug('RECEIVED MESSAGE', request); // Handle message via the base transport\n\n      this.handleMessage(request);\n    };\n\n    this.getUnrealTransportSession = windowParams => {\n      const params = new WindowSessionParams(windowParams);\n      return {\n        sessionId: params.get('sid'),\n        networkId: params.get('net'),\n        intent: base64DecodeObject(params.get('intent'))\n      };\n    };\n\n    this._init = InitState.NIL;\n  }\n\n  async register(windowHref) {\n    var _window$ue;\n\n    if (((_window$ue = window.ue) == null ? void 0 : _window$ue.sequencewallettransport) === undefined) {\n      return;\n    }\n\n    overrideLogs('wallet'); // record open details (sessionId + default network) from the window url\n\n    const {\n      search: rawParams\n    } = new URL(windowHref || window.location.href);\n    let session = this.getUnrealTransportSession(rawParams); // provider should always include sid when opening a new window\n\n    const isNewWindowSession = !!session.sessionId; // attempt to restore previous session in the case of a redirect or window reload\n\n    if (!isNewWindowSession) {\n      session = await this.getCachedTransportSession();\n    }\n\n    if (!session) {\n      logger.error('unreal session is undefined');\n      return;\n    } // listen for window-transport requests\n\n\n    window.ue.sequencewallettransport.onmessagefromsequencejs = this.onMessageFromUnreal;\n    this._registered = true; // send open event to the app which opened us\n\n    this.open(session).then(opened => {\n      if (!opened) {\n        var _session;\n\n        const err = `failed to open to network ${(_session = session) == null ? void 0 : _session.networkId}`;\n        logger.error(err);\n        this.notifyClose({\n          message: err\n        });\n        window.close();\n      }\n    }).catch(e => {\n      var _session2;\n\n      const err = `failed to open to network ${(_session2 = session) == null ? void 0 : _session2.networkId}, due to: ${e}`;\n      logger.error(err);\n      this.notifyClose({\n        message: err\n      });\n      window.close();\n    });\n  }\n\n  unregister() {\n    var _window$ue2, _window$ue2$sequencew;\n\n    if (((_window$ue2 = window.ue) == null ? void 0 : (_window$ue2$sequencew = _window$ue2.sequencewallettransport) == null ? void 0 : _window$ue2$sequencew.onmessagefromsequencejs) === this.onMessageFromUnreal) {\n      delete window.ue.sequencewallettransport.onmessagefromsequencejs;\n    }\n\n    this._registered = false;\n  } // onmessage is called when (the wallet) receives request messages from the dapp\n  // over the unreal json-messaging transport\n\n\n  // sendMessage sends message to the dapp window\n  sendMessage(message) {\n    var _window$ue3, _window$ue3$sequencew;\n\n    if (message.type !== EventType.INIT && this._init !== InitState.OK) {\n      logger.error('impossible state, should not be calling postMessage until inited');\n      return;\n    } // prepare payload\n\n\n    const payload = JSON.stringify(message); // post-message to app.\n\n    (_window$ue3 = window.ue) == null ? void 0 : (_window$ue3$sequencew = _window$ue3.sequencewallettransport) == null ? void 0 : _window$ue3$sequencew.sendmessagetosequencejs(payload);\n  }\n\n}\n\nclass WalletUtils {\n  constructor(walletProvider) {\n    var _this = this;\n\n    this.wallet = void 0;\n\n    this.recoverWalletConfig = async function (address, digest, signature, chainId, walletContext) {\n      walletContext = walletContext || (await _this.wallet.getWalletContext());\n      return recoverWalletConfig(address, digest, signature, chainId, walletContext);\n    };\n\n    this.recoverWalletConfigFromMessage = async function (address, message, signature, chainId, walletContext) {\n      walletContext = walletContext || (await _this.wallet.getWalletContext());\n      return recoverWalletConfig(address, encodeMessageDigest(prefixEIP191Message(message)), signature, chainId, walletContext);\n    };\n\n    this.recoverWalletConfigFromTypedData = async function (address, typedData, signature, chainId, walletContext) {\n      walletContext = walletContext || (await _this.wallet.getWalletContext());\n      return recoverWalletConfig(address, encodeTypedDataDigest(typedData), signature, chainId, walletContext);\n    };\n\n    this.wallet = walletProvider;\n  } // Sign message on a specified chain, or DefaultChain by default\n\n\n  signMessage(message, chainId, allSigners) {\n    const signer = this.wallet.getSigner();\n    if (!signer) throw new Error('unable to get signer');\n    return signer.signMessage(message, chainId, allSigners);\n  } // Sign message on the AuthChain\n\n\n  async signAuthMessage(message, allSigners) {\n    const signer = await this.wallet.getAuthSigner();\n    if (!signer) throw new Error('unable to get AuthChain signer');\n    return signer.signMessage(message, await signer.getChainId(), allSigners);\n  } // Sign EIP-712 TypedData on a specified chain, or DefaultChain by default\n\n\n  signTypedData(domain, types, message, chainId, allSigners) {\n    const signer = this.wallet.getSigner();\n    if (!signer) throw new Error('unable to get signer');\n    return signer.signTypedData(domain, types, message, chainId, allSigners);\n  } // Sign EIP-712 TypedData on the AuthChain\n\n\n  async signAuthTypedData(domain, types, message, allSigners) {\n    const signer = await this.wallet.getAuthSigner();\n    if (!signer) throw new Error('unable to get AuthChain signer');\n    return signer.signTypedData(domain, types, message, await signer.getChainId(), allSigners);\n  } // Verify signature of a digest, one of a message, typedData or other\n\n\n  async isValidSignature(address, digest, signature, chainId, walletContext) {\n    const provider = this.wallet.getProvider(chainId);\n    if (!provider) throw new Error(`unable to get provider for chainId ${chainId}`);\n    return isValidSignature(address, digest, signature, provider, chainId, walletContext);\n  } // Verify message signature\n\n\n  async isValidMessageSignature(address, message, signature, chainId, walletContext) {\n    const provider = this.wallet.getProvider(chainId);\n    if (!provider) throw new Error(`unable to get provider for chainId ${chainId}`);\n    const prefixed = prefixEIP191Message(message);\n    const digest = encodeMessageDigest(prefixed);\n    return isValidSignature(address, digest, signature, provider, chainId, walletContext);\n  } // Verify typedData signature\n\n\n  isValidTypedDataSignature(address, typedData, signature, chainId, walletContext) {\n    return this.isValidSignature(address, encodeTypedDataDigest(typedData), signature, chainId, walletContext);\n  } // Recover the WalletConfig from a signature + digest combo\n  // sendTransaction()\n  // sendTransactions()\n  // sendETH()\n  // sendToken()\n  // sendCoin() -- sugar for sendToken()\n  // sendCollectible() -- sugar for sendToken()\n  // callContract()\n  // transactionHistory()\n  // getReceipt()\n  // getLogs()\n  // // ..\n  // isWalletDeployed()\n  // deployWallet()\n  // validateSignature()\n  // recoverWalletConfig()\n  // recoverAddress()\n\n\n}\n\nclass Wallet {\n  constructor(_network, config) {\n    var _this = this;\n\n    this.utils = void 0;\n    this.config = void 0;\n    this.session = void 0;\n    this.connectedSites = void 0;\n    this.transport = void 0;\n    this.networks = void 0;\n    this.providers = void 0;\n\n    this.init = () => {\n      var _this$config$transpor, _this$config$transpor2, _this$config$transpor3, _this$config$transpor4, _this$config$transpor5, _this$config$transpor6, _this$config$transpor7, _this$config$transpor8;\n\n      if (this.transport.provider) {\n        // init must have already been called\n        return;\n      } // Setup provider\n\n\n      this.transport.messageProvider = new MuxMessageProvider(); // multiple message provider setup, first one to connect will be the main transport\n\n      if ((_this$config$transpor = this.config.transports) != null && (_this$config$transpor2 = _this$config$transpor.windowTransport) != null && _this$config$transpor2.enabled) {\n        this.transport.windowMessageProvider = new WindowMessageProvider(this.config.walletAppURL);\n        this.transport.messageProvider.add(this.transport.windowMessageProvider);\n      }\n\n      if ((_this$config$transpor3 = this.config.transports) != null && (_this$config$transpor4 = _this$config$transpor3.proxyTransport) != null && _this$config$transpor4.enabled) {\n        this.transport.proxyMessageProvider = new ProxyMessageProvider(this.config.transports.proxyTransport.appPort);\n        this.transport.messageProvider.add(this.transport.proxyMessageProvider);\n      }\n\n      if ((_this$config$transpor5 = this.config.transports) != null && (_this$config$transpor6 = _this$config$transpor5.extensionTransport) != null && _this$config$transpor6.enabled) {\n        this.transport.extensionMessageProvider = new ExtensionMessageProvider(this.config.transports.extensionTransport.runtime); // this.transport.extensionMessageProvider.register()\n\n        this.transport.messageProvider.add(this.transport.extensionMessageProvider); // NOTE/REVIEW: see note in mux-message-provider\n        //\n        // We don't add the extensionMessageProvider here because we don't send requests to it anyways, we seem to\n        // send all requests to the WindowMessageProvider anyways. By allowing it, if browser restarts, it will break\n        // the entire extension because messageProvider.provider will be undefined. So this is a hack to fix it.\n        //\n        // this.transport.messageProvider.add(this.transport.extensionMessageProvider)\n      }\n\n      if ((_this$config$transpor7 = this.config.transports) != null && (_this$config$transpor8 = _this$config$transpor7.unrealTransport) != null && _this$config$transpor8.enabled) {\n        this.transport.unrealMessageProvider = new UnrealMessageProvider(this.config.walletAppURL);\n        this.transport.messageProvider.add(this.transport.unrealMessageProvider);\n      }\n\n      this.transport.messageProvider.register(); // .....\n\n      this.transport.allowProvider = allowProviderMiddleware(request => {\n        if (request.method === 'sequence_setDefaultNetwork') return true;\n        const isConnected = this.isConnected();\n\n        if (!isConnected) {\n          throw new Error('Sequence: wallet not connected');\n        }\n\n        return isConnected;\n      }); // ...\n\n      this.transport.networkProvider = networkProviderMiddleware(request => {\n        // return stub chainId of 0 when not connected to any\n        if (!this.networks || this.networks.length === 0) return 0; // return the default chainId as we're connected\n\n        return this.networks.find(network => network.isDefaultChain).chainId;\n      }); // Provider proxy to support middleware stack of logging, caching and read-only rpc calls\n\n      this.transport.cachedProvider = new CachedProvider();\n      this.transport.cachedProvider.onUpdate(() => {\n        if (!this.session) this.session = {\n          providerCache: {}\n        };\n        this.session.providerCache = this.transport.cachedProvider.getCache();\n        this.saveSession(this.session);\n      }); // ..\n\n      this.transport.router = new JsonRpcRouter([loggingProviderMiddleware, this.transport.networkProvider, this.transport.allowProvider, exceptionProviderMiddleware, this.transport.cachedProvider], this.transport.messageProvider);\n      this.transport.provider = new Web3Provider(this.transport.router); // NOTE: we don't listen on 'connect' even here as we handle it within connect() method\n      // in more synchronous flow.\n      // below will update the wallet session object and persist it. In case the session\n      // is undefined, we consider the session to have been removed by the user, so we clear it.\n\n      this.transport.messageProvider.on('open', openInfo => {\n        const {\n          session\n        } = openInfo;\n\n        if (!session) {\n          if (this.session && this.session.accountAddress) {\n            // emit disconnect even if previously we had a session, and now we don't.\n            this.transport.messageProvider.emit('disconnect');\n          }\n\n          this.clearSession();\n        } else {\n          this.useSession(session, true);\n        }\n      }); // below will update the account upon wallet connect/disconnect - aka, login/logout.\n      // if an origin is provided, this operation should be performed only on that origin\n      // and shouldn't affect the session of the wallet.\n\n      this.transport.messageProvider.on('accountsChanged', (accounts, origin) => {\n        if (origin) {\n          if (accounts.length > 0) {\n            this.useSession({\n              accountAddress: accounts[0]\n            }, true);\n          }\n\n          return;\n        }\n\n        if (!accounts || accounts.length === 0 || accounts[0] === '') {\n          this.clearSession();\n        } else {\n          this.useSession({\n            accountAddress: accounts[0]\n          }, true);\n        }\n      }); // below will update the networks automatically when the wallet networks change\n\n      this.transport.messageProvider.on('networks', networks => {\n        this.useSession({\n          networks: networks\n        }, true);\n      }); // below will update the wallet context automatically\n\n      this.transport.messageProvider.on('walletContext', walletContext => {\n        this.useSession({\n          walletContext: walletContext\n        }, true);\n      });\n    };\n\n    this.loadSession = async function () {\n      const data = await LocalStorage.getInstance().getItem('@sequence.session');\n\n      if (!data || data === '') {\n        return undefined;\n      }\n\n      try {\n        const session = JSON.parse(data);\n\n        if (session) {\n          _this.useSession(session, false);\n        }\n\n        return session;\n      } catch (err) {\n        logger.warn('loadSession failed, unable to parse session payload from storage.');\n        return undefined;\n      }\n    };\n\n    this.connect = async function (options) {\n      if ((options == null ? void 0 : options.refresh) === true) {\n        _this.disconnect();\n      }\n\n      if (_this.isConnected() && (await _this.isSiteConnected(options == null ? void 0 : options.origin)) && !!_this.session && !(options != null && options.authorize) && !(options != null && options.askForEmail)) {\n        return {\n          connected: true,\n          session: _this.session,\n          chainId: ethers.utils.hexlify(await _this.getChainId())\n        };\n      }\n\n      if (options) {\n        if (options.authorize && (!options.app || options.app === '')) {\n          throw new Error(`connecting with 'authorize' option also requires 'app' to be set`);\n        }\n      }\n\n      await _this.openWallet(undefined, {\n        type: 'connect',\n        options\n      });\n      const connectDetails = await _this.transport.messageProvider.waitUntilConnected().catch(_ => {\n        return {\n          connected: false\n        };\n      });\n\n      if (connectDetails.connected) {\n        if (!!connectDetails.session) {\n          _this.useSession(connectDetails.session, true);\n\n          _this.addConnectedSite(options == null ? void 0 : options.origin);\n        } else {\n          throw new Error('impossible state, connect response is missing session');\n        }\n      }\n\n      return connectDetails;\n    };\n\n    this.authorize = async function (options) {\n      return _this.connect(_extends({}, options, {\n        authorize: true\n      }));\n    };\n\n    this.getSession = () => {\n      if (!this.isConnected()) {\n        return undefined;\n      }\n\n      return this.session;\n    };\n\n    this.getAddress = async function () {\n      if (!_this.isConnected()) {\n        throw new Error('connect first');\n      }\n\n      const session = _this.getSession();\n\n      return session.accountAddress;\n    };\n\n    this.getNetworks = async function (chainId) {\n      if (!_this.isConnected() || !_this.networks) {\n        throw new Error('connect first');\n      }\n\n      if (chainId) {\n        // filter list to just the specific chain requested\n        const network = findNetworkConfig(_this.networks, chainId);\n        return network ? [network] : [];\n      }\n\n      return _this.networks;\n    };\n\n    this.getChainId = async function () {\n      if (!_this.networks || _this.networks.length < 1) {\n        throw new Error('networks have not been set by session. connect first.');\n      }\n\n      const network = _this.networks.find(network => network.isDefaultChain);\n\n      if (!network) {\n        throw new Error('networks must have a default chain specified');\n      }\n\n      return network.chainId;\n    };\n\n    this.getAuthChainId = async function () {\n      if (!_this.networks || _this.networks.length < 1) {\n        throw new Error('networks have not been set by session. connect first.');\n      }\n\n      const network = _this.networks.find(network => network.isAuthChain);\n\n      if (!network) {\n        throw new Error('networks must have an auth chain specified');\n      }\n\n      return network.chainId;\n    };\n\n    this.openWallet = async function (path, intent, networkId) {\n      if ((intent == null ? void 0 : intent.type) !== 'connect' && !_this.isConnected()) {\n        throw new Error('connect first');\n      }\n\n      let currentNetworkId;\n\n      if (!_this.networks || _this.networks.length < 1) {\n        currentNetworkId = _this.config.defaultNetworkId;\n      } else {\n        currentNetworkId = await _this.getChainId();\n      }\n\n      _this.transport.messageProvider.openWallet(path, intent, networkId || currentNetworkId);\n\n      await _this.transport.messageProvider.waitUntilOpened();\n      return true;\n    };\n\n    this.closeWallet = () => {\n      this.transport.messageProvider.closeWallet();\n    };\n\n    this.saveSession = async function (session) {\n      logger.debug('wallet provider: saving session');\n      const data = JSON.stringify(session);\n      await LocalStorage.getInstance().setItem('@sequence.session', data);\n    };\n\n    this.useSession = async function (session, autoSave = true) {\n      if (!_this.session) _this.session = {}; // setup wallet context\n\n      if (_this.config.walletContext) {\n        _this.session.walletContext = _this.config.walletContext;\n      } else if (session.walletContext) {\n        _this.session.walletContext = session.walletContext;\n      } // setup account\n\n\n      if (session.accountAddress) {\n        _this.useAccountAddress(session.accountAddress);\n      } // setup networks\n\n\n      if (session.networks) {\n        _this.useNetworks(session.networks);\n      } // setup provider cache\n\n\n      if (session.providerCache) {\n        _this.transport.cachedProvider.setCache(session.providerCache);\n      } // persist\n\n\n      if (autoSave) {\n        _this.saveSession(_this.session);\n      }\n    };\n\n    // config is a Partial, so that we may intersect it with the DefaultProviderConfig,\n    // which allows easy overriding and control of the config.\n    this.config = _extends({}, DefaultProviderConfig);\n\n    if (config) {\n      this.config = _extends({}, this.config, config);\n    }\n\n    if (_network) {\n      this.config.defaultNetworkId = _network;\n    } else if (!this.config.defaultNetworkId) {\n      this.config.defaultNetworkId = 'mainnet';\n    }\n\n    if (config != null && config.localStorage) {\n      LocalStorage.use(config.localStorage);\n    }\n\n    this.transport = {};\n    this.networks = [];\n    this.providers = {};\n    this.connectedSites = new LocalStore('@sequence.connectedSites', []);\n    this.utils = new WalletUtils(this);\n    this.init();\n  }\n\n  async addConnectedSite(origin) {\n    origin = origin || window.location.origin;\n    const connectedSites = await this.connectedSites.get();\n\n    if (connectedSites) {\n      if (connectedSites.includes(origin)) {\n        return;\n      }\n\n      this.connectedSites.set([...connectedSites, origin]);\n    } else {\n      this.connectedSites.set([origin]);\n    }\n  }\n\n  async removeConnectedSite(origin) {\n    const authorized = await this.connectedSites.get();\n\n    if (authorized) {\n      this.connectedSites.set(authorized.filter(domain => domain !== origin));\n    }\n  }\n\n  getConnectedSites() {\n    return this.connectedSites.get();\n  }\n\n  async isSiteConnected(origin) {\n    const authorized = await this.connectedSites.get();\n    return !!authorized && authorized.includes(origin || window.location.origin);\n  }\n\n  disconnect() {\n    if (this.isOpened()) {\n      this.closeWallet();\n    }\n\n    this.clearSession();\n  } // TODO: add switchNetwork(network: string | number) which will call wallet_switchEthereumChain\n  // and on successful response, will update the provider info here, etc.\n\n\n  getProviderConfig() {\n    return this.config;\n  }\n\n  isOpened() {\n    return this.transport.messageProvider.isOpened();\n  }\n\n  isConnected() {\n    return this.session !== undefined && this.session.networks !== undefined && this.session.networks.length > 0 && this.networks !== undefined && this.networks.length > 0 && !!this.session.accountAddress && this.session.accountAddress.startsWith('0x');\n  }\n\n  getProvider(chainId) {\n    // return the top-level provider message transport when chainId is unspecified\n    // and user has not logged in\n    if (!this.isConnected()) {\n      if (chainId) {\n        throw new Error(`session is empty. connect and try again.`);\n      } else {\n        return this.transport.provider;\n      }\n    }\n\n    let network = this.networks.find(network => network.isDefaultChain);\n\n    if (chainId) {\n      network = findNetworkConfig(this.networks, chainId);\n\n      if (!network) {\n        throw new Error(`network ${chainId} is not in the network list`);\n      }\n    } // return memoized network provider\n\n\n    if (this.providers[network.chainId]) {\n      return this.providers[network.chainId];\n    } // builder web3 provider stack\n\n\n    let provider; // network.provider may be set by the ProviderConfig override\n\n    const rpcProvider = network.provider ? network.provider : new JsonRpcProvider(network.rpcUrl, network.chainId);\n\n    if (network.isDefaultChain) {\n      // communicating with defaultChain will prioritize the wallet message transport\n      const router = new JsonRpcRouter([loggingProviderMiddleware, exceptionProviderMiddleware, new EagerProvider({\n        accountAddress: this.session.accountAddress,\n        walletContext: this.session.walletContext\n      }), new SigningProvider(this.transport.provider), this.transport.cachedProvider], new JsonRpcSender(rpcProvider));\n      provider = new Web3Provider(router, network.chainId);\n    } else {\n      // communicating with another chain will bind to that network, but will forward\n      // any signing-related requests to the wallet message transport\n      const router = new JsonRpcRouter([loggingProviderMiddleware, exceptionProviderMiddleware, new EagerProvider({\n        accountAddress: this.session.accountAddress,\n        walletContext: this.session.walletContext,\n        chainId: network.chainId\n      }), new SigningProvider(this.transport.provider), new CachedProvider(network.chainId)], new JsonRpcSender(rpcProvider));\n      provider = new Web3Provider(router, network.chainId);\n    }\n\n    this.providers[network.chainId] = provider;\n    return provider;\n  }\n\n  async getAuthProvider() {\n    return this.getProvider((await this.getAuthNetwork()).chainId);\n  }\n\n  async getAuthNetwork() {\n    return (await this.getNetworks()).find(n => n.isAuthChain);\n  }\n\n  getAllProviders() {\n    return this.providers;\n  }\n\n  getSigner(chainId) {\n    return this.getProvider(chainId).getSigner();\n  }\n\n  async getAuthSigner() {\n    return (await this.getAuthProvider()).getSigner();\n  }\n\n  getWalletConfig(chainId) {\n    return this.getSigner().getWalletConfig(chainId);\n  }\n\n  getWalletState(chainId) {\n    return this.getSigner().getWalletState(chainId);\n  }\n\n  getWalletContext() {\n    return this.getSigner().getWalletContext();\n  }\n\n  isDeployed(chainId) {\n    return this.getSigner(chainId).isDeployed();\n  }\n\n  on(event, fn) {\n    this.transport.messageProvider.on(event, fn);\n  }\n\n  once(event, fn) {\n    this.transport.messageProvider.once(event, fn);\n  }\n\n  useAccountAddress(accountAddress) {\n    if (!this.session) this.session = {};\n    this.session.accountAddress = ethers.utils.getAddress(accountAddress);\n  }\n\n  useNetworks(networks) {\n    // set networks in the session\n    if (!this.session) this.session = {}; // set networks on session object\n\n    this.session.networks = networks; // short-circuit if setting empty network list (aka logged out state)\n\n    if (!this.session.networks || this.session.networks.length === 0) {\n      return;\n    } // check if any custom network settings, otherwise return early\n\n\n    if (!this.config.networks && !this.config.networkRpcUrl) {\n      this.networks = networks;\n      return;\n    } // init networks\n\n\n    this.networks = networks; // combine custom network config with networks in the session\n\n    if (this.config.networks) {\n      this.networks = networks.map(n => _extends({}, n)); // copy\n\n      this.config.networks.forEach(n => {\n        const network = findNetworkConfig(this.networks, n.chainId || n.name);\n        if (!network) return;\n        updateNetworkConfig(n, network);\n      });\n      ensureValidNetworks(this.networks, true);\n    } // an extra override for convenience\n\n\n    if (this.config.networkRpcUrl) {\n      const network = this.networks.find(network => network.isDefaultChain);\n\n      if (network) {\n        network.rpcUrl = this.config.networkRpcUrl;\n      }\n    }\n  }\n\n  clearSession() {\n    var _this$transport$cache;\n\n    logger.debug('wallet provider: clearing session');\n    LocalStorage.getInstance().removeItem('@sequence.session');\n    this.session = undefined;\n    this.networks = [];\n    this.providers = {};\n    (_this$transport$cache = this.transport.cachedProvider) == null ? void 0 : _this$transport$cache.clearCache();\n  }\n\n}\nconst DefaultProviderConfig = {\n  walletAppURL: 'https://sequence.app',\n  // walletSessionURL: 'https://session.sequence.app',\n  transports: {\n    windowTransport: {\n      enabled: true\n    },\n    proxyTransport: {\n      enabled: false\n    }\n  }\n};\nlet walletInstance;\nconst initWallet = async (network, config) => {\n  if (walletInstance && walletInstance.isOpened()) {\n    walletInstance.closeWallet();\n  }\n\n  walletInstance = new Wallet(network, config);\n  await walletInstance.loadSession();\n  return walletInstance;\n};\nconst getWallet = () => {\n  if (!walletInstance) {\n    throw new Error('Wallet has not been initialized, call sequence.initWallet(network, config) first.');\n  }\n\n  return walletInstance;\n};\n\nexport { BaseInjectedTransport, BaseProviderTransport, BaseWalletTransport, CHANNEL_ID, DefaultProviderConfig, ErrSignedInRequired, EventType, ExtensionMessageHandler, ExtensionMessageProvider, InitState, LocalStorage, LocalStore, LocalWeb3Provider, MuxMessageProvider, OpenState, PROVIDER_OPEN_TIMEOUT, ProviderError, ProxyMessageChannel, ProxyMessageChannelPort, ProxyMessageHandler, ProxyMessageProvider, UnrealMessageHandler, UnrealMessageProvider, Wallet, WalletRequestHandler, Web3Provider, Web3Signer, WindowMessageHandler, WindowMessageProvider, WindowSessionParams, getWallet, initWallet, isBrowserExtension, isSequenceProvider, isValidMessageSignature, isValidSignature, isValidTypedDataSignature, isWalletUpToDate, messageToBytes, nextMessageIdx, prefixEIP191Message, recoverWalletConfig };\n","import * as abi$1 from '@0xsequence/abi';\nimport * as api$1 from '@0xsequence/api';\nimport * as auth$1 from '@0xsequence/auth';\nimport * as config$1 from '@0xsequence/config';\nimport * as guard$1 from '@0xsequence/guard';\nimport * as indexer$1 from '@0xsequence/indexer';\nimport * as metadata$1 from '@0xsequence/metadata';\nimport * as multicall$1 from '@0xsequence/multicall';\nimport * as network$1 from '@0xsequence/network';\nimport * as provider$1 from '@0xsequence/provider';\nimport { isValidSignature, isValidMessageSignature, isValidTypedDataSignature, recoverWalletConfig, isWalletUpToDate, initWallet, getWallet, Wallet } from '@0xsequence/provider';\nexport { Wallet, getWallet, initWallet } from '@0xsequence/provider';\nimport * as relayer$1 from '@0xsequence/relayer';\nimport * as transactions$1 from '@0xsequence/transactions';\nimport * as utils$1 from '@0xsequence/utils';\n\nfunction _mergeNamespaces(n, m) {\n  m.forEach(function (e) {\n    e && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {\n      if (k !== 'default' && !(k in n)) {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  });\n  return Object.freeze(n);\n}\n\nvar abi = /*#__PURE__*/Object.freeze(/*#__PURE__*/_mergeNamespaces({\n  __proto__: null\n}, [abi$1]));\n\nvar api = /*#__PURE__*/Object.freeze(/*#__PURE__*/_mergeNamespaces({\n  __proto__: null\n}, [api$1]));\n\nvar auth = /*#__PURE__*/Object.freeze(/*#__PURE__*/_mergeNamespaces({\n  __proto__: null\n}, [auth$1]));\n\nvar config = /*#__PURE__*/Object.freeze(/*#__PURE__*/_mergeNamespaces({\n  __proto__: null\n}, [config$1]));\n\nvar guard = /*#__PURE__*/Object.freeze(/*#__PURE__*/_mergeNamespaces({\n  __proto__: null\n}, [guard$1]));\n\nvar indexer = /*#__PURE__*/Object.freeze(/*#__PURE__*/_mergeNamespaces({\n  __proto__: null\n}, [indexer$1]));\n\nvar metadata = /*#__PURE__*/Object.freeze(/*#__PURE__*/_mergeNamespaces({\n  __proto__: null\n}, [metadata$1]));\n\nvar multicall = /*#__PURE__*/Object.freeze(/*#__PURE__*/_mergeNamespaces({\n  __proto__: null\n}, [multicall$1]));\n\nvar network = /*#__PURE__*/Object.freeze(/*#__PURE__*/_mergeNamespaces({\n  __proto__: null\n}, [network$1]));\n\nvar provider = /*#__PURE__*/Object.freeze(/*#__PURE__*/_mergeNamespaces({\n  __proto__: null\n}, [provider$1]));\n\nvar relayer = /*#__PURE__*/Object.freeze(/*#__PURE__*/_mergeNamespaces({\n  __proto__: null\n}, [relayer$1]));\n\nvar transactions = /*#__PURE__*/Object.freeze(/*#__PURE__*/_mergeNamespaces({\n  __proto__: null\n}, [transactions$1]));\n\nvar utils = /*#__PURE__*/Object.freeze(/*#__PURE__*/_mergeNamespaces({\n  __proto__: null,\n  isValidSignature: isValidSignature,\n  isValidMessageSignature: isValidMessageSignature,\n  isValidTypedDataSignature: isValidTypedDataSignature,\n  recoverWalletConfig: recoverWalletConfig,\n  isWalletUpToDate: isWalletUpToDate\n}, [utils$1]));\n\nvar sequence = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  abi: abi,\n  api: api,\n  auth: auth,\n  config: config,\n  guard: guard,\n  indexer: indexer,\n  metadata: metadata,\n  multicall: multicall,\n  network: network,\n  provider: provider,\n  relayer: relayer,\n  transactions: transactions,\n  utils: utils,\n  initWallet: initWallet,\n  getWallet: getWallet,\n  Wallet: Wallet\n});\n\nexport { sequence };\n"],"names":["walletContracts","erc1271","Object","freeze","__proto__","abi","type","name","constant","inputs","outputs","payable","stateMutability","returns","isValidSignatureBytes32","factory","mainModule","components","mainModuleUpgradable","sequenceUtils","internalType","anonymous","indexed","requireFreshSigner","_extends","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","this","SmartRampOrderStatus","SortOrder","WebRPCVersion","WebRPCSchemaVersion","WebRPCSchemaHash","API","hostname","fetch","path","ping","headers","url","createHTTPRequest","then","res","buildResponse","_data","status","version","runtimeStatus","getSequenceContext","data","getAuthToken","args","jwtToken","address","user","sendPasswordlessLink","friendList","page","friends","getFriendByAddress","friend","searchFriends","addFriend","updateFriendNickname","removeFriend","contractCall","decodeContractCall","lookupContractCallSelectors","signatures","userStorageFetch","object","userStorageSave","ok","userStorageDelete","userStorageFetchAll","objects","getMoonpayLink","signedUrl","isUsingGoogleMail","yes","isValidSignature","isValid","isValidMessageSignature","isValidTypedDataSignature","isValidETHAuthProof","getCoinPrices","tokenPrices","getCollectiblePrices","getExchangeRate","exchangeRate","listPayCardsOnFile","payCards","savePayCard","payCard","updatePayCardCVC","deletePayCard","smartRampQuote","quoteDetails","smartRampPurchase","processing","receipt","smartRampWaitOrderConfirmation","done","smartRampGetOrder","order","smartRampCheckCardAuthorization","cardAuth","smartRampSubmitCardAuthorization","smartRampOrdersList","orders","getInviteInfo","inviteInfo","isValidAccessCode","internalClaimAccessCode","walletRecover","encryptedWallet","body","method","JSON","stringify","text","parse","err","code","msg","SequenceAPIClient","jwtAuth","endsWith","slice","_fetch","input","init","__assign","t","s","n","p","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","__generator","f","y","g","_","label","sent","trys","ops","verb","Symbol","iterator","v","op","TypeError","pop","push","encodeTypedDataHash","typedData","ethers","domain","types","message","Proof","prefix","ETHAuthPrefix","toLowerCase","claims","app","iat","exp","ETHAuthVersion","signature","extra","setIssuedAtNow","Math","round","Date","getTime","setExpiryIn","seconds","validateClaims","messageDigest","messageTypedData","ETHAuthEIP712Domain","Claims","typ","ogn","Error","now","max","ValidateEOAProof","provider","chainId","proof","_a","ValidateContractAccountProof","walletCode","undefined","getCode","IsValidSignatureBytes32MagicValue","ETHAuth","_this","validators","_i","configJsonRpcProvider","ethereumJsonRpcURL","netVersion","send","parseInt","NaN","configValidators","encodeProof","skipSignatureValidation","claimsJSON","proofString","validateProof","Base64","decodeProof","parts","messageBase64","split","isValidClaims","validateProofClaims","concat","validateProofSignature","retIsValid","validator","isNetworkConfig","cand","rpcUrl","relayer","ChainId","getChainId","toNumber","maybeChainId","getAuthNetwork","networks","find","network","isAuthChain","isValidNetworkConfig","networkConfig","raise","skipRelayerCheck","configs","Array","isArray","chainIds","map","c","sort","dupes","filter","indexOf","forEach","names","nameDupes","defaultChain","authChain","isDefaultChain","ensureValidNetworks","ensureUniqueNetworks","updateNetworkConfig","src","dest","ensAddress","createNetworkConfig","defaultChainId","vars","config","mainNetwork","sortNetworks","findNetworkConfig","startsWith","id","checkNetworkConfig","networksIndex","index","a","b","defaultConfigIdx","findIndex","splice","authConfigIdx","MAINNET","title","blockExplorer","rootUrl","ROPSTEN","testnet","RINKEBY","GOERLI","KOVAN","POLYGON","POLYGON_MUMBAI","BSC","BSC_TESTNET","OPTIMISM","OPTIMISM_TESTNET","ARBITRUM","ARBITRUM_TESTNET","AVALANCHE","AVALANCHE_TESTNET","FANTOM","FANTOM_TESTNET","GNOSIS","AURORA","AURORA_TESTNET","mainnetNetworks","urlClean","baseRpcUrl","baseRelayerUrl","testnetNetworks","sequenceContext","guestModule","libs","JsonRpcVersion","JsonRpcRouter","middlewares","sender","handler","setMiddleware","createJsonRpcMiddlewareStack","sendAsync","request","callback","chain","toMiddleware","sendAsyncMiddleware","isJsonRpcProvider","constructor","defaultUrl","detectNetwork","getSigner","perform","isJsonRpcHandler","JsonRpcMethod","_nextId","JsonRpcSender","params","r","jsonrpc","catch","bind","error","response","JsonRpcExternalProvider","AllowProvider","isAllowedFunc","allowProviderMiddleware","fn","isAllowed","CachedProvider","cachableJsonRpcMethods","cache","onUpdateCallback","includes","cacheKey","getCacheValue","setCacheValue","getCache","setCache","clearCache","EagerProvider","props","accountAddress","walletContext","exceptionProviderMiddleware","loggingProviderMiddleware","chainIdLabel","logger","networkProviderMiddleware","networkChainId","SignerJsonRpcMethods","SigningProvider","PublicProvider","privateJsonRpcMethods","setRpcUrl","JsonRpcProvider","safeSolve","promise","def","d","Function","partition","array","reduce","element","parseBlockTag","BigNumber","DefaultMulticallOptions","batchSize","timeWindow","contract","verbose","Multicall","options","batchableJsonRpcMethods","ethCall","ethGetCode","ethGetBalance","multicallInterface","timeout","queue","scheduleExecution","clearTimeout","setTimeout","run","handle","m","console","log","limit","min","forward","items","item","from","gasPrice","itemBlockTag","blockTag","eq","_unused","discartItems","callParams","delegateCall","revertOnError","to","gasLimit","gas","encodeFunctionData","getFunction","_unused2","encodedCall","reqId","getRandomInt","promisify","decoded","decodeFunctionResult","DefaultOptions","entries","conf","isMulticallOptions","storage","ProxyMethods","MulticallProvider","multicall","getNetwork","listenerCount","getResolver","ogResolver","req","getBalance","isMulticall","resp","transaction","rpcCall","addressOrName","MulticallExternalProvider","isMetaMask","isStatus","multicallMiddleware","lib","WalletContractBytecode","listKey","configKey","imageHash","localStorage","Map","getItem","_map$get","get","setItem","set","removeItem","delete","getCachedConfig","_storage$getItem","pushImageHash","_storage$getItem2","imageHashes","hash","shift","createWalletConfig","threshold","signers","weight","Signer","signer","getAddress","isUsableConfig","add","gte","isValidConfigSigners","valid","addressOf","salt","context","ignoreAddress","codeHash","sortConfig","cacheConfig","compareAddr","isConfigEqual","bigA","bigB","lt","editConfig","normSigner","normSrcSigners","normSetSigners","normDelAddress","del","normSetAddress","newSigners","genConfig","ConfigFinder","findCurrentConfig","findLastWalletOfInitialSigner","SignatureType","SequenceUtilsFinder","authProvider","ignoreIndex","requireIndex","skipCache","chainIdPromise","knownConfigs","findCurrentImageHash","findConfigForImageHash","found","authContract","Contract","lastSignerUpdate","logBlockHeight","wallet","filters","RequiredSigner","findLatestLog","fromBlock","toBlock","lastLog","event","interface","decodeEventLog","topics","_wallet","image","kc","cached","lastImageHashUpdate","imageHashHeight","RequiredConfig","_signers","_threshold","walletContract","functions","currentImageHash","normalizedAddress","knownImageHashes","knownImageHash","findFirstLog","gotImageHash","getBlockNumber","getLogs","logs","pivot","floor","nhalf","isDecodedAddress","isDecodedSigner","isDecodedEOASigner","isDecodedEOASplitSigner","isDecodedFullSigner","decodeSignature","auxsig","replace","rindex","signatureType","Address","addr","EOA","sig","Full","size","mul","_signature","splitDecodedEOASigner","recoverEOASigner","digest","subDigest","joinSignatures","joinTwoSignatures","encodeSignature","accountBytes","signatureSize","fill","signerOf","part","mutateSignature","allSigners","buildStubSignature","multicallProvider","all","arrayify","isEOA","sortedSigners","totalWeight","willSign","stubSig","finalSigners","substring","ContractType","EventLogType","EventLogDataType","TxnTransferType","SequenceIndexerServices","Indexer","getChainID","chainID","getEtherBalance","balance","getTokenBalances","balances","getTokenSupplies","contractType","tokenIDs","getTokenSuppliesMap","supplies","getBalanceUpdates","getTransactionHistory","transactions","syncBalance","SequenceIndexerClient","SwapType","Metadata","getTokenMetadata","tokenMetadata","getTokenMetadataBatch","contractTokenMetadata","searchTokenMetadata","searchTokenIDs","tokenIds","getContractInfo","contractInfo","getContractInfoBatch","contractInfoMap","searchContractInfo","contractInfoList","searchContractInfoBatch","contractInfoByChain","getNiftyswapTokenQuantity","quantity","getNiftyswapUnitPrices","prices","SequenceMetadataClient","MetaTransactionsType","packMetaTransactionsData","txs","nonce","readSequenceNonce","packMetaTransactionsNonceData","sequenceTxAbiEncode","digestOfTransactions","digestOfTransactionsNonce","computeMetaTxnHash","subDigestOf","toSequenceTransactions","allTxs","flattenAuxTransactions","nonces","tx","toSequenceTransaction","auxiliary","isSequenceTransaction","txGas","walletInterface","Interface","isAsyncSendable","hasSequenceTransactions","sample","sampleNonce","_t$to","appendNonce","makeExpirable","expiration","makeAfterNonce","dep","space","encodeNonce","bspace","bnonce","shl","div","decodeNonce","shr","mod","isSignedTransactions","fromTransactionish","stx","afterNonce","after","isBaseRelayerOptions","obj","bundleCreation","creationGasLimit","isBigNumberish","providers","BaseRelayerDefaults","BaseRelayer","opts","walletAddress","factoryInterface","signedTransactions","encodedSignature","isWalletDeployed","prepareWalletDeploy","execute","prependWalletDeploy","DEFAULT_GAS_LIMIT","ProviderRelayerDefaults","waitPollRate","deltaBlocksLog","fromBlockLog","isProviderRelayerOptions","Provider","ProviderRelayer","estimateGas","executed","succeeded","gasUsed","walletAddr","simulate","results","module","readNonce","metaTxnId","wait","timeoutTime","lastBlock","block","normalMetaTxnId","l","getTransactionReceipt","transactionHash","getTransaction","isLocalRelayerOptions","ETHTxnStatus","TransferType","FeeTokenType","LocalRelayer","txnOptions","walletDeployTxn","sendTransaction","_config","_context","getFeeOptions","transactionRequest","signedTxs","quote","Relayer","sendMetaTxn","txnHash","getMetaTxnNonce","getMetaTxnReceipt","updateMetaTxnGasLimits","payload","feeTokens","isFeeRequired","tokens","feeOptions","getMetaTxnNetworkFeeOptions","sentTransactions","pendingTransactions","relayer_gen","FAILED_STATUSES","FAILED","PARTIALLY_FAILED","DROPPED","isRpcRelayerOptions","RpcRelayer","service","fetchPonyfill","metaTxnHash","waitReceipt","metaTxID","txnReceipt","coder","encoded","encode","prevNonce","getNonce","walletConfig","decode","modTxns","symbols","token","symbol","join","_tag","_quote","encodedNonce","toHexString","walletContractAddress","decodedSpace","decodedNonce","typecheckedQuote","metaTxn","MetaTransactionResponseException","txReceipt","blockHash","blockNumber","confirmations","raw","waitForTransaction","isRelayer","estimateGasLimits","gasRefundOptions","relay","isSequenceSigner","Signer$1","updateConfig","publishConfig","getWalletContext","getWalletConfig","NotEnoughSigners","RemoteSigner","signMessageWithData","isRemoteSigner","signMessage","resolveArrayProperties","o","resolveProperties","Wallet","strict","nonStrict","setProvider","setRelayer","jsonProvider","getChainIdNumber","isDeployed","fetchImageHash","state","deployed","lastImageHash","signTransactions","signChainId","providedNonce","sign","isDigest","domainChainId","encodeTypedDataDigest","signTypedData","solvedChainId","signWith","auxData","signersAddr","warn","localSigners","packMsgAndSig","localSignature","remoteSigners","remoteSignature","getSigners","sconfig","publish","buildUpdateConfigTransaction","requireFreshSigners","buildPublishConfigTransaction","buildPublishSignersTransaction","_this2","getStorageAt","implementation","isUpgradable","preTransaction","mainModuleInterface","postTransaction","sequenceUtilsInterface","requireFreshSignersInterface","decodedSignature","filteredSignature","contextRequireFreshSigner","_this$context$libs","connectedChainId","signWeight","owner","Account","_wallets","_chainId","setNetworks","w","useSigners","configFinder","authWallet","wallets","getWalletByNetwork","flat","configsPromise","getConfigFinder","getWalletState","states","idx","getAuthChainId","currentConfig","_configs$i","_this$mainWallet","mainWallet","getProvider","_this$_wallets$find","_this$mainWallet2","getRelayer","_this$_wallets$find2","thisConfig","useConfig","toString","_this$authWallet","hasEnoughSigners","prependConfigUpdate","updatedTransaction","finalTransactions","dtransactionish","sendSignedTransactions","skipThresholdCheck","lastConfig","transactionParts","newConfig","networkId","defaultChainIdNum","foundMainnetNetwork","foundTestnetNetwork","initialConfig","isValidEIP712Signature","isValidEthSignSignature","isValidContractWalletSignature","erc1271Check","isValidSequenceUndeployedWalletSignature","cid","packMessageData","recoverConfigFromDigest","recoverConfig","walletSignersValidation","DEFAULT_SESSION_EXPIRATION","LONG_SESSION_EXPIRATION","Session","sequenceApiUrl","sequenceMetadataUrl","account","metadata","jwt","_jwt$expiration","_initialAuthRequest","_jwt","proofStrings","onAuthCallbacks","apiClient","metadataClient","indexerClients","getJWTExpiration","cb","maxTries","getJWT","tryAuth","has","indexer","indexerUrl","_token","proofStringKey","getProofStringKey","getProofString","api","ewtString","testnetMode","isTestnetMode","authResp","isProofStringValid","reason","_proofString","ethAuth","val","referenceSigner","deepSearch","noIndex","getAuthProvider","solvedSigners","fullSigners","existingWallet","session","setConfig","setAccount","auth","dump","_authChain$provider","jwtDecodeClaims","signAuthorization","ErrAccountIsRequired","AuthError","origin","expiry","ValidateSequenceDeployedWalletProof","ValidateSequenceUndeployedWalletProof","GuarddService","EventType","OpenState","InitState","WindowSessionParams","URLSearchParams","ProviderError","ErrSignedInRequired","PROVIDER_OPEN_TIMEOUT","_messageIdx","nextMessageIdx","BaseProviderTransport","pendingMessageRequests","responseCallbacks","confirmationOnly","events","EventEmitter2","openPayload","connectPayload","accountsChangedPayload","networksPayload","walletContextPayload","_sessionId","_init","_registered","CLOSED","openWallet","isOpened","waitUntilOpened","sendMessageRequest","MESSAGE","sendMessage","openTimeout","opened","race","emit","_this$openPayload","once","openInfo","waitUntilConnected","connect","connectDetails","closeWallet","NIL","intent","registered","OPENED","_this$openPayload2","INIT","OK","sessionId","requestIdx","responseCallback","OPEN","ACCOUNTS_CHANGED","accounts","CHAIN_CHANGED","NETWORKS","WALLET_CONTEXT","CLOSE","close","CONNECT","DISCONNECT","isConnected","_message$data","_message$data2","_message$data3","pendingMessageRequest","on","clear","WalletRequestHandler","_signer","prompter","signerReadyCallbacks","_openIntent","_connectOptions","_defaultNetworkId","promptConnect","connected","promptConnectDetails","walletSession","permittedJsonRpcMethods","walletBalance","prefixedMessage","prefixEIP191Message","handleConfirmWalletDeployPrompt","promptSignMessage","connectOptions","typedDataObject","transactionParams","txnResponse","promptSendTransaction","promptSignTransaction","txChainId","tag","getTransactionCount","count","getBlock","transactionObject","contractAddress","getGasPrice","switchParams","setDefaultNetwork","_chainId2","_chainId3","getNetworks","defaultNetworkId","providerResponse","isSignedIn","signerReady","setSigner","notifyConnect","keepWalletOpened","notifyClose","hexlify","authorize","authOptions","responseMessage","notifyNetworks","jsonRpcResponse","_connectDetails$sessi","_connectDetails$sessi2","defaultNetwork","isWalletUpToDate","promptConfirmWalletDeploy","Web3Provider","_sender","_isSequenceProvider","_defaultChainId","Web3Signer","isSequenceProvider","Web3Provider$1","LocalWeb3Provider","walletRequestHandler","_address","_index","_networks","_providers","currentChainId","authChainId","getSender","sendUncheckedTransaction","_wrapTransaction","onceBlock","batch","shallowCopy","fromAddress","hexTx","hexlifyTransaction","password","allowedTransactionKeys","allowExtra","allowed","eip191prefix","messageToBytes","messageBytes","String","_await$provider$getNe","isValidSignature$1","prefixed","encodeMessageDigest","recoverWalletConfig","recoveredWalletAddress","isBrowserExtension","window","location","protocol","walletState","walletStateForRequiredChain","authChainConfig","_walletState$find","requiredChainConfig","isUpToDate","LocalStorage","_instance","instance","registeredWindowMessageProvider","registeredUnrealMessageProvider","LocalStore","getInstance","TRANSPORT_SESSION_LS_KEY","BaseWalletTransport","_initNonce","_initCallback","appOrigin","handleMessage","isValidInitAck","open","sanitizeNumberString","saveTransportSession","setOpenIntent","authorizeOptions","sanitizeHost","sanitizeAlphanumeric","setConnectOptions","notifyOpen","getCachedTransportSession","notifyDisconnect","notifyAccountsChanged","notifyChainChanged","notifyWalletContext","chainIdHex","initTimeout","performance","SENT_NONCE","ProxyMessageChannel","port1","ProxyMessageChannelPort","port2","conn","ProxyMessageProvider","port","register","unregister","removeAllListeners","OPENING","ProxyMessageHandler","cachedSession","MuxMessageProvider","messageProviders","WindowMessageProvider","walletAppURL","walletURL","walletWindow","addEventListener","onWindowEvent","popup","interval","setInterval","closed","clearInterval","removeEventListener","focus","windowSize","windowPos","URL","href","windowSessionParams","pathname","base64EncodeObject","abs","screen","width","height","screenX","innerWidth","screenY","innerHeight","windowFeatures","search","_this$walletWindow","postedMessage","postMessage","WindowMessageHandler","parentWindow","_isPopup","getWindowTransportSession","windowParams","base64DecodeObject","windowHref","isPopup","parent","opener","rawParams","_session","_session2","CHANNEL_ID","ExtensionMessageHandler","runtime","ExtensionMessageProvider","onConnect","addListener","onMessage","BaseInjectedTransport","stream","writable","write","overrideLogs","side","_window$ue","ue","sequencewallettransport","logsOverriddenForUnreal","_window$ue2","logfromjs","warnfromjs","errorfromjs","things","walletInstance","UnrealMessageProvider","onmessagefromwallet","onUnrealCallback","_window$ue2$sequencew","_window$ue3","_window$ue3$sequencew","sendmessagetowallet","UnrealMessageHandler","onMessageFromUnreal","getUnrealTransportSession","onmessagefromsequencejs","sendmessagetosequencejs","WalletUtils","walletProvider","recoverWalletConfigFromMessage","recoverWalletConfigFromTypedData","getAuthSigner","_network","utils","connectedSites","transport","_this$config$transpor","_this$config$transpor2","_this$config$transpor3","_this$config$transpor4","_this$config$transpor5","_this$config$transpor6","_this$config$transpor7","_this$config$transpor8","messageProvider","transports","windowTransport","enabled","windowMessageProvider","proxyTransport","proxyMessageProvider","appPort","extensionTransport","extensionMessageProvider","unrealTransport","unrealMessageProvider","allowProvider","networkProvider","cachedProvider","onUpdate","providerCache","saveSession","router","useSession","clearSession","loadSession","refresh","disconnect","isSiteConnected","askForEmail","addConnectedSite","getSession","currentNetworkId","autoSave","useAccountAddress","useNetworks","DefaultProviderConfig","use","authorized","rpcProvider","networkRpcUrl","_this$transport$cache","initWallet","getWallet","_mergeNamespaces","keys","k","getOwnPropertyDescriptor","defineProperty","enumerable","abi$1","api$1","auth$1","config$1","guard","guard$1","indexer$1","metadata$1","multicall$1","network$1","provider$1","relayer$1","transactions$1","utils$1","sequence"],"sourceRoot":""}